// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#ifndef WINRT_Component_Params_H
#define WINRT_Component_Params_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.000000.0"), "Mismatched C++/WinRT headers.");
#include "winrt/impl/Component.Structs.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Component.Params.2.h"
#include "winrt/Component.h"
namespace winrt::impl
{
    template <typename D> void consume_Component_Params_IClass<D>::SyncCall(param::hstring const& a, Windows::Foundation::IReference<int32_t> const& b, param::iterable<int32_t> const& c, param::vector_view<int32_t> const& d, param::map_view<int32_t, int32_t> const& e, param::vector<int32_t> const& f, param::map<int32_t, int32_t> const& g) const
    {
        check_hresult(WINRT_SHIM(Component::Params::IClass)->SyncCall(get_abi(a), get_abi(b), get_abi(c), get_abi(d), get_abi(e), get_abi(f), get_abi(g)));
    }
    template <typename D> Windows::Foundation::IAsyncAction consume_Component_Params_IClass<D>::NotSyncCall(param::hstring const& a, Windows::Foundation::IReference<int32_t> const& b, param::iterable<int32_t> const& c, param::vector_view<int32_t> const& d, param::map_view<int32_t, int32_t> const& e, param::vector<int32_t> const& f, param::map<int32_t, int32_t> const& g) const
    {
        void* operation;
        check_hresult(WINRT_SHIM(Component::Params::IClass)->NotSyncCall(get_abi(a), get_abi(b), get_abi(c), get_abi(d), get_abi(e), get_abi(f), get_abi(g), &operation));
        return { operation, take_ownership_from_abi };
    }
    template <typename D> Component::Structs::Simple consume_Component_Params_IClass<D>::Structs(Component::Structs::Simple const& a, Component::Structs::Simple& b) const
    {
        Component::Structs::Simple result;
        check_hresult(WINRT_SHIM(Component::Params::IClass)->Structs(get_abi(a), put_abi(b), put_abi(result)));
        return result;
    }
    template <typename D>
    struct produce<D, Component::Params::IClass> : produce_base<D, Component::Params::IClass>
    {
        int32_t WINRT_CALL SyncCall(void* a, void* b, void* c, void* d, void* e, void* f, void* g) noexcept final
        {
            try
            {
                typename D::abi_guard guard(this->shim());
                this->shim().SyncCall(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<Windows::Foundation::IReference<int32_t> const*>(&b), *reinterpret_cast<Windows::Foundation::Collections::IIterable<int32_t> const*>(&c), *reinterpret_cast<Windows::Foundation::Collections::IVectorView<int32_t> const*>(&d), *reinterpret_cast<Windows::Foundation::Collections::IMapView<int32_t, int32_t> const*>(&e), *reinterpret_cast<Windows::Foundation::Collections::IVector<int32_t> const*>(&f), *reinterpret_cast<Windows::Foundation::Collections::IMap<int32_t, int32_t> const*>(&g));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL NotSyncCall(void* a, void* b, void* c, void* d, void* e, void* f, void* g, void** operation) noexcept final
        {
            try
            {
                *operation = nullptr;
                typename D::abi_guard guard(this->shim());
                *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().NotSyncCall(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<Windows::Foundation::IReference<int32_t> const*>(&b), *reinterpret_cast<Windows::Foundation::Collections::IIterable<int32_t> const*>(&c), *reinterpret_cast<Windows::Foundation::Collections::IVectorView<int32_t> const*>(&d), *reinterpret_cast<Windows::Foundation::Collections::IMapView<int32_t, int32_t> const*>(&e), *reinterpret_cast<Windows::Foundation::Collections::IVector<int32_t> const*>(&f), *reinterpret_cast<Windows::Foundation::Collections::IMap<int32_t, int32_t> const*>(&g)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL Structs(struct struct_Component_Structs_Simple a, struct struct_Component_Structs_Simple* b, struct struct_Component_Structs_Simple* result) noexcept final
        {
            try
            {
                typename D::abi_guard guard(this->shim());
                *result = detach_from<Component::Structs::Simple>(this->shim().Structs(*reinterpret_cast<Component::Structs::Simple const*>(&a), *reinterpret_cast<Component::Structs::Simple*>(b)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
}
namespace winrt::Component::Params
{
    inline Class::Class() :
        Class(impl::call_factory<Class>([](auto&& f) { return f.template ActivateInstance<Class>(); }))
    {
    }
}
namespace std
{
    template<> struct hash<winrt::Component::Params::IClass> : winrt::impl::hash_base<winrt::Component::Params::IClass> {};
    template<> struct hash<winrt::Component::Params::Class> : winrt::impl::hash_base<winrt::Component::Params::Class> {};
}
#endif
