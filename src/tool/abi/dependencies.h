#pragma once

#include <algorithm>
#include <set>
#include <string_view>
#include <vector>

#include "common.h"
#include "meta_reader.h"

struct namespace_reference
{
    std::string_view full_namespace;
    xlang::meta::reader::cache::namespace_members const* members;
};

// NOTE: Ideally we would generate header files that identically match those generated by MIDLRT, which would make
//       validation of this tool much easier. Unfortunately this is impossible since MIDLRT mostly follows the ordering
//       in the .idl file. The .idl files in the SDK, on the other hand, are generated via WINMDIDL, and therefore has a
//       predictable ordering that we can try and replicate. The ordering is roughly
//          1.  Forward declare dependencies (e.g. from function arguments) from _other_ namespaces, in alphabetical
//              order by fully qualified name (e.g. 'Windows.Foundation.DateTime')
//          2.  Forward declare dependencies for the namespace(s) being processed ordered categorically: apicontract,
//              enum, struct, delegate, interface, then class. Types within each category are ordered alphabetically, as
//              described above
//          3.  Forward declare generic instantiations in the same alphabetical order described above
//          4.  Type definitions in the same category order described above
struct fqn_compare
{
    using is_transparent = void;

    template <typename LhsT, typename RhsT>
    static int compare(LhsT const& lhs, RhsT const& rhs) noexcept
    {
        auto leftStr = lhs.TypeNamespace();
        auto rightStr = rhs.TypeNamespace();
        auto [posLeft, posRight] = std::mismatch(leftStr.begin(), leftStr.end(), rightStr.begin(), rightStr.end());

        if (posLeft != leftStr.end())
        {
            if (posRight != rightStr.end())
            {
                return *posLeft < *posRight ? -1 : 1;
            }

            if (*posLeft != '.')
            {
                return 1;
            }

            ++posLeft;
            rightStr = rhs.TypeName();
            std::tie(posLeft, posRight) = std::mismatch(posLeft, leftStr.end(), rightStr.begin(), rightStr.end());

            if (posRight == rightStr.end())
            {
                return 1;
            }
            else if (posLeft == leftStr.end())
            {
                return -1;
            }
            else
            {
                return *posLeft < *posRight ? -1 : 1;
            }
        }
        else if (posRight != rightStr.end())
        {
            if (*posRight != '.')
            {
                return -1;
            }

            ++posRight;
            leftStr = lhs.TypeName();
            std::tie(posLeft, posRight) = std::mismatch(leftStr.begin(), leftStr.end(), posRight, rightStr.end());

            if (posLeft == leftStr.end())
            {
                return -1;
            }
            else if (posRight == rightStr.end())
            {
                return 1;
            }
            else
            {
                return *posLeft < *posRight ? -1 : 1;
            }
        }
        else
        {
            return lhs.TypeName().compare(rhs.TypeName());
        }
    }

    template <typename LhsT, typename RhsT>
    bool operator()(LhsT const& lhs, RhsT const& rhs) const noexcept
    {
        return compare(lhs, rhs) < 0;
    }
};

struct category_compare
{
    static int category_power(xlang::meta::reader::category value) noexcept
    {
        using namespace xlang::meta::reader;
        switch (value)
        {
        case category::interface_type: return 0;
        case category::class_type: return 1;
        case category::enum_type: return 2;
        case category::struct_type: return 3;
        case category::delegate_type: return 4;
        default: return (std::numeric_limits<int>::max)();
        }
    }

    bool operator()(xlang::meta::reader::TypeDef const& lhs, xlang::meta::reader::TypeDef const& rhs) const noexcept
    {
        using namespace xlang::meta::reader;
        auto lhsCategory = get_category(lhs);
        auto rhsCategory = get_category(rhs);
        if (lhsCategory == rhsCategory)
        {
            return fqn_compare::compare(lhs, rhs) < 0;
        }

        return category_power(lhsCategory) < category_power(rhsCategory);
    }
};

// struct generic_compare
// {
//     static type_name name_of(xlang::meta::reader::ElementType e) noexcept
//     {
//         using namespace std::literals;

//         switch (e)
//         {
//         case ElementType::Boolean: return { ""sv, "boolean"sv };
//         case ElementType::Char: return { ""sv, "WCHAR"sv };
//         case ElementType::U1: return { ""sv, "BYTE"sv };
//         case ElementType::I2: return { ""sv, "INT16"sv };
//         case ElementType::U2: return { ""sv, "UINT16"sv };
//         case ElementType::I4: return { ""sv, "INT32"sv };
//         case ElementType::U4: return { ""sv, "UINT32"sv };
//         case ElementType::I8: return { ""sv, "INT64"sv };
//         case ElementType::U8: return { ""sv, "UINT64"sv };
//         case ElementType::R4: return { ""sv, "FLOAT"sv };
//         case ElementType::R8: return { ""sv, "DOUBLE"sv };
//         case ElementType::String: return { ""sv, "HSTRING"sv };
//         case ElementType::Object: return { ""sv, "IInspectable*"sv };
//         }

//         XLANG_ASSERT(false);
//         return {};
//     }

//     static type_name name_of(xlang::meta::reader::coded_index<xlang::meta::reader::TypeDefOrRef> const& t) noexcept
//     {
//         using namespace xlang::meta::reader;



//         // return visit(t, xlang::visit_overload{
//         //     [](GenericTypeInstSig const& sig)
//         //     {
//         //         return type_name{ sig.GenericType().TypeNamespace(), sig.GenericType().TypeName() };
//         //     },
//         //     []()
//         //     {

//         //     }});
//     }

//     static type_name(xlang::meta::reader::GenericTypeIndex) noexcept
//     {
//         XLANG_ASSERT(false);
//         return {};
//     }

//     static type_name name_of(xlang::meta::reader::TypeSig::value_type const& t) noexcept
//     {
//         return std::visit([](auto const& value) { return name_of(value); }, t);
//     }

//     static int compare(
//         xlang::meta::reader::GenericTypeInstSig const& lhs,
//         xlang::meta::reader::GenericTypeInstSig const& rhs) noexcept
//     {
//         using namespace xlang::meta::reader;
//         auto generic_type_name = [](GenericTypeInstSig const& genericType)
//         {
//             auto type = genericType.GenericType();
//             switch (type.type())
//             {
//             case TypeDefOrRef::TypeDef: return type_name{ type.TypeDef().TypeNamespace(), type.TypeDef().TypeName() };
//             case TypeDefOrRef::TypeRef: return type_name{ type.TypeRef().TypeNamespace(), type.TypeRef().TypeName() };
//             default: XLANG_ASSERT(false); return type_name{}; // A generic type shouldn't have a generic type as its generic type...
//             }
//         };

//         auto typeCompare = fqn_compare::compare(generic_type_name(lhs), generic_type_name(rhs));
//         if (typeCompare != 0)
//         {
//             return typeCompare;
//         }

//         // Same generic type; compare the parameters
//         XLANG_ASSERT(lhs.GenericArgCount() == rhs.GenericArgCount());
//         auto lhsParams = lhs.GenericArgs();
//         auto rhsParams = rhs.GenericArgs();
//         while (lhsParams.first != rhsParams.first)
//         {
//             // std::variant<ElementType, coded_index<TypeDefOrRef>, GenericTypeIndex, GenericTypeInstSig>;
//             auto const& leftType = lhsParams.first->Type();
//             auto const& rightType = rhsParams.first->Type();

//             if (leftType.index() != rightType.index())
//             {
//                 // Different types; cannot be equal
//                 return fqn_compare::compare(name_of(leftType), name_of(rightType));
//             }

//             ++lhsParams.first;
//             ++rhsParams.first;
//         }

//         // Identical type
//         return 0;
//     }

//     bool operator()(
//         xlang::meta::reader::GenericTypeInstSig const& lhs,
//         xlang::meta::reader::GenericTypeInstSig const& rhs) const noexcept
//     {
//         return compare(lhs, rhs) < 0;
//     }
// };

struct dependencies
{
    std::set<std::string_view> dependent_namespaces;

    std::set<xlang::meta::reader::TypeDef, fqn_compare> external_dependencies;
    std::set<xlang::meta::reader::TypeDef, category_compare> internal_dependencies;







    std::set<std::string_view> namespace_dependencies;

    std::vector<xlang::meta::reader::TypeDef> type_dependencies;
    std::vector<xlang::meta::reader::GenericTypeInstSig> generic_dependencies;
};

namespace details
{
    using namespace std::literals;
    using namespace xlang::meta::reader;

    inline void process_dependency(dependencies& target, TypeDef const& type, std::set<type_name>& dependentNames);
    inline void process_dependency(dependencies& target, TypeSig const& type, std::set<type_name>& dependentNames);

    inline void process_dependency(dependencies& target, GenericTypeInstSig const& type, std::set<type_name>& dependentNames)
    {
        // Only take note of fully specialized generic instances; we'll walk the dependency tree later
        if (is_fully_specialized(type))
        {
            target.generic_dependencies.emplace_back(type);
        }

        // Dependencies propagate out to all generic arguments
        for (auto const& arg : type.GenericArgs())
        {
            process_dependency(target, arg, dependentNames);
        }

        // Since we need to define template specializations for all generic types, we also need to process the generic
        // type as if it were a part of this namespace
        auto def = find_required(type.GenericType().TypeRef());
        if (auto [itr, added] = dependentNames.emplace(type_name{ def.TypeNamespace(), def.TypeName() }); added)
        {
            target.namespace_dependencies.emplace(def.TypeNamespace());
            process_dependency(target, def, dependentNames);
        }
    }

    inline void process_dependency(dependencies& target, coded_index<TypeDefOrRef> const& type, std::set<type_name>& dependentNames)
    {
        visit(type, xlang::visit_overload{
            [&](GenericTypeInstSig const& t)
            {
                process_dependency(target, t, dependentNames);
            },
            [&](auto const& defOrRef)
            {
                if (defOrRef.TypeNamespace() != system_namespace)
                {
                    if (auto [itr, added] = dependentNames.emplace(type_name{ defOrRef.TypeNamespace(), defOrRef.TypeName() });
                        added)
                    {
                        target.type_dependencies.emplace_back(find_required(defOrRef));
                        target.namespace_dependencies.emplace(defOrRef.TypeNamespace());
                    }
                }
            }});
    }

    inline void process_dependency(dependencies& target, TypeSig const& type, std::set<type_name>& dependentNames)
    {
        xlang::visit(type.Type(),
            [&](ElementType const&)
            {
                // Does not impact the dependency graph
            },
            [&](coded_index<TypeDefOrRef> const& t)
            {
                process_dependency(target, t, dependentNames);
            },
            [&](GenericTypeIndex const&)
            {
                // This is referencing a generic parameter from an earlier generic argument and thus carries no new dependencies
            },
            [&](GenericTypeInstSig const& t)
            {
                process_dependency(target, t, dependentNames);
            });
    }

    inline void process_dependency(dependencies& target, TypeDef const& type, std::set<type_name>& dependentNames)
    {
        // Contract attributes count as dependencies since we need to declare contract version number. API contract
        // _definitions_ however, don't carry dependencies
        if (!get_attribute(type, metadata_namespace, "ApiContractAttribute"sv))
        {
            if (auto contractInfo = contract_attributes(type))
            {
                target.namespace_dependencies.emplace(decompose_type(contractInfo->type_name).first);
                for (auto const& prevContract : contractInfo->previous_contracts)
                {
                    target.namespace_dependencies.emplace(decompose_type(prevContract.type_name).first);
                }
            }
        }

        // Ensure that any generic required interfaces get defined
        for (auto const& impl : type.InterfaceImpl())
        {
            auto const& iface = impl.Interface();
            if (iface.type() == TypeDefOrRef::TypeSpec)
            {
                process_dependency(target, iface, dependentNames);
            }
        }

        for (auto const& method : type.MethodList())
        {
            auto sig = method.Signature();
            process_dependency(target, sig.ReturnType().Type(), dependentNames);

            for (auto const& param : sig.Params())
            {
                process_dependency(target, param.Type(), dependentNames);
            }
        }
    }
}

inline dependencies calculate_dependencies(std::initializer_list<namespace_reference> targets)
{
    dependencies result;

    // NOTE: This is mostly for book-keeping to avoid processing types multiple times unnecessarily
    std::set<type_name> dependentNames;

    for (auto const& tgt : targets)
    {
        result.namespace_dependencies.emplace(tgt.full_namespace);

        for (auto const& [name, type] : tgt.members->types)
        {
            details::process_dependency(result, type, dependentNames);
        }
    }

    return result;
}
