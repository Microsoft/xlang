#pragma once

namespace pywinrt
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        XLANG_ASSERT(name.size() > 0);

        for (std::string_view::size_type i = 0; i < name.size(); i++)
        {
            if (isupper(name[i]) && i > 0)
            {
                auto sub = name.substr(i - 1, 4);
                if (sub != "UInt" && sub[0] != '_')
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::toupper(c)); });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::tolower(c)); });
    }

    void write_license(writer& w, std::string_view comment_marker = "//")
    {
        w.write("% WARNING: Please don't edit this file. It was generated by Python/WinRT\n\n", comment_marker);
    }

    void write_include(writer& w, std::string_view const& ns)
    {
        if (w.current_namespace != ns)
        {
            auto format = R"(
#if __has_include("py.%.h")
#include "py.%.h"
#endif
)";
            w.write(format, ns, ns);
        }
        else
        {
            w.write("#include \"py.%.h\"\n", ns);
        }
    }

    void write_template_arg_name(writer& w, GenericParam const& param)
    {
        w.write(param.Name());
    }

    void write_template_arg(writer& w, GenericParam const& param)
    {
        w.write("typename %", bind<write_template_arg_name>(param));
    }

    void write_type_namespace(writer& w, TypeDef const& type)
    {
        auto segments = get_dotted_name_segments(type.TypeNamespace());
        w.write("%", bind_list("::", segments));
    }

    void write_pywrapper_type(writer& w, TypeDef const& type)
    {
        w.write("py::wrapper::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyproj_type(writer& w, TypeDef const& type)
    {
        w.write("py::proj::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyimpl_type(writer& w, TypeDef const& type)
    {
        w.write("py::impl::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_python_type_type(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            write_pyproj_type(w, type);
        }
        else
        {
            w.write("%", type);
        }

    }
    void write_get_python_type_specialization(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        auto format = R"(template<>
struct winrt_type<%>
{
    static PyTypeObject* python_type;
    static PyTypeObject* get_python_type() { return python_type; }
};

)";
        w.write(format, bind<write_python_type_type>(type));
    }

    void write_python_wrapper_type(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("winrt_wrapper");
            break;
        case category::interface_type:
            if (is_ptype(type))
                w.write("winrt_pinterface_wrapper");
            else
                w.write("winrt_wrapper");
            break;
        case category::struct_type:
            w.write("winrt_struct_wrapper");
            break;
        }
    }

    void write_python_wrapper_template_type(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            w.write("py::proj::%::@", bind<write_type_namespace>(type), type.TypeName());
        }
        else
        {
            w.write("%", type);
        }
    }

    void write_python_wrapper_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        w.write("using @ = py::%<%>;\n", type.TypeName(),
            bind<write_python_wrapper_type>(type),
            bind<write_python_wrapper_template_type>(type));
    }

    void write_type_base(writer& w, TypeDef const& type)
    {
        if (has_dealloc(type))
        {
            w.write("bases.get()");
        }
        else
        {
            w.write("nullptr");
        }
    }

    void write_ns_module_exec_init_python_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        w.write("py::winrt_type<%>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_@, &_type_spec_@, %).detach());\n",
            bind<write_python_type_type>(type),
            type.TypeName(),
            type.TypeName(),
            bind<write_type_base>(type));
    }

    void write_ns_module_exec_func(writer& w, cache::namespace_members const& members)
    {
        w.write("static int module_exec(PyObject* module)\n{\n");
        {
            writer::indent_guard g{ w };
            w.write("py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };\n\n");
            w.write("try\n{\n");

            {
                writer::indent_guard gg{ w };

                settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.classes)(w);
                settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.interfaces)(w);
                settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.structs)(w);
            }

            w.write(R"(}
catch(...)
{
    return -1;
}

return 0;
)");
        }

        w.write("}\n");
    }

    void write_ns_module_name(writer& w, std::string_view const& ns)
    {
        auto segments = get_dotted_name_segments(ns);
        w.write("_%_%", settings.module, bind_list("_", segments));
    }

    void write_namespace_initialization(writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write("\n// ----- % Initialization --------------------\n", ns);

        write_ns_module_exec_func(w, members);
        w.write(strings::ns_module_def, ns, bind<write_ns_module_name>(ns), bind<write_ns_module_name>(ns));
    }

    void write_winrt_type_specialization_storage(writer& w, TypeDef const& type)
    {
        w.write("\nPyTypeObject* py::winrt_type<%>::python_type;\n", bind<write_python_type_type>(type));
        w.write("static const char* _type_name_@ = \"@\";\n", type.TypeName(), type.TypeName());
    }

    void write_dealloc_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        if (category == category::class_type && is_static(type))
        {
            return;
        }

        auto format = R"(
static void _dealloc_@(%* self)
{
)";

        w.write(format, type.TypeName(), bind<write_pywrapper_type>(type));

        if (category == category::class_type || category == category::interface_type)
        {
            writer::indent_guard g{ w };
            w.write("// TODO: clear cached instance\n");
            w.write("self->obj = nullptr;\n");
        }
        w.write("}\n");
    }

    void write_method_name(writer& w, MethodDef const& method)
    {
        w.write(get_method_abi_name(method));
    }



    void write_method_function_name(writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (is_constructor(method) && empty(method.ParamList()))
        {
            w.write("_ctor_@", type.TypeName());
        }
        else
        {
            w.write("@_%", type.TypeName(), bind<write_method_name>(method));
        }
    }

    auto get_abi_overloads(TypeDef const& type)
    {
        std::set<std::string_view> method_names{};
        std::set<std::string_view> overloads{};

        for (auto&& method : type.MethodList())
        {
            auto name = get_method_abi_name(method);

            if (method_names.find(name) == method_names.end())
            {
                method_names.insert(name);
            }
            else
            {
                overloads.insert(name);
            }
        }

        return std::move(overloads);
    }

    void write_self_param_name(writer& w, MethodDef const& method)
    {
        if (is_static(method) || is_constructor(method))
        {
            w.write("/* unused */");
        }
        else
        {
            w.write("self");
        }
    }

    void write_args_param_name(writer& w, MethodDef const& method)
    {
        switch (get_argument_convention(method))
        {
        case argument_convention::no_args:
            w.write("/* unused */");
            break;
        case argument_convention::single_arg:
            w.write("arg");
            break;
        case argument_convention::variable_args:
            w.write("args");
            break;
        }
    }

    void write_param_name(writer& w, method_signature::param_t param)
    {
        w.register_type_namespace(param.second->Type());
        w.write("param%", param.first.Sequence() - 1);
    }

    void write_out_param_init(writer& w, method_signature::param_t const& param)
    {
        call(get_type_semantics(param.second->Type()),
            [&](TypeDef const& type)
        {
            switch (get_category(type))
            {
            case category::class_type:
            case category::interface_type:
            case category::delegate_type:
                w.write("nullptr");
                break;
            }
        },
            [&](generic_type_instance const&) { w.write("nullptr"); },
            [](auto) {});
    }

    void write_convert_to_params(writer& w, MethodDef const& method, int sequence)
    {
        switch (get_argument_convention(method))
        {
        case argument_convention::single_arg:
            w.write("arg");
            break;
        case argument_convention::variable_args:
            w.write("args, %", sequence);
            break;
        default:
            throw_invalid("write_convert_to_params");
        }
    }

    void write_method_param_definition(writer& w, MethodDef const& method, method_signature::param_t const& param)
    {
        auto sequence = param.first.Sequence() - 1;

        switch (get_param_category(param))
        {
        case param_category::in:
            w.write("auto % = py::convert_to<%>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::out:
            w.write("% % { % };\n", param.second->Type(), bind<write_param_name>(param), bind<write_out_param_init>(param));
            break;
        case param_category::pass_array:
            w.write("auto _% = py::convert_to<winrt::com_array<%>>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            w.write("auto % = winrt::array_view<const %>(_%.data(), _%.data() + _%.size());\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_param_name>(param),
                bind<write_param_name>(param));
            break;
        case param_category::fill_array:
            w.write("auto %_count = py::convert_to<winrt::com_array<%>::size_type>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            w.write("winrt::com_array<%> % ( %_count, py::empty_instance<%>::get() );\n",
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_param_name>(param),
                param.second->Type());
            break;
        case param_category::receive_array:
            w.write("winrt::com_array<%> % { };\n",
                param.second->Type(),
                bind<write_param_name>(param));
            break;
        default:
            throw_invalid("invalid param_category");
        }
    }

    void write_method_invoke_context(writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (is_ptype(type))
        {
            w.write("_obj.");
        }
        else if (is_static(method) || is_constructor(method))
        {
            w.write("%::", type);
        }
        else
        {
            w.write("self->obj.");
        }
    }

    void write_method_cpp_name(writer& w, MethodDef const& method)
    {
        auto name = method.Name();

        if (method.SpecialName())
        {
            w.write(name.substr(name.find('_') + 1));
        }
        else
        {
            w.write(name);
        }
    }

    void write_detach_param(writer& w, std::string const& paramName)
    {
        w.write("%.detach()", paramName);
    }

    void write_py_tuple_pack(writer& w, std::vector<std::string> const& params)
    {
        w.write("PyTuple_Pack(%, %)", static_cast<int>(params.size()), bind_list<write_detach_param>(", ", params));
    }

    void write_method_body_contents(writer& w, TypeDef const& type, MethodDef const& method)
    {
        writer::indent_guard g{ w };

        method_signature signature{ method };

        // convert in params from Python -> C++
        for (auto&& param : signature.params())
        {
            write_method_param_definition(w, method, param);
        }
        if (signature.params().size() > 0)
        {
            w.write("\n");
        }

        // Invoke member
        if (is_constructor(method))
        {
            w.write("% return_value{ % };\n",
                method.Parent(),
                bind_list<write_param_name>(", ", signature.params()));
        }
        else
        {
            if (signature.return_signature())
            {
                w.register_type_namespace(signature.return_signature().Type());
                w.write("auto return_value = ");
            }
            w.write("%%(%);\n",
                bind<write_method_invoke_context>(type, method),
                bind<write_method_cpp_name>(method),
                bind_list<write_param_name>(", ", signature.params()));
        }
        w.write("\n");

        // Convert return values and out parameters from C++ -> Python
        std::vector<std::string> return_values{};
        if (signature.return_signature() || is_constructor(method))
        {
            auto format = R"(py::pyobj_handle out_return_value{ py::convert(return_value) };
if (!out_return_value) 
{ 
    return nullptr;
}
)";
            w.write(format);
            return_values.push_back("out_return_value");
        }

        for (auto&& param : signature.params())
        {
            if (!is_out_param(param))
            {
                continue;
            }

            auto sequence = param.first.Sequence() - 1;
            auto out_param = w.write_temp("out%", sequence);

            auto format = R"(py::pyobj_handle %{ py::convert(param%) };
if (!%) 
{
    return nullptr;
}
)";
            w.write(format, out_param, sequence, out_param);
            return_values.push_back(out_param);
        }

        // Return Python projected return/out params
        if (return_values.size() == 0)
        {
            w.write("Py_RETURN_NONE;\n");
        }
        else if (return_values.size() == 1)
        {
            w.write("return %;\n", bind<write_detach_param>(return_values[0]));
        }
        else
        {
            w.write("return %;\n", bind<write_py_tuple_pack>(return_values));
        }
    }

    void write_method_body(writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (get_argument_convention(method) == argument_convention::variable_args)
        {
            method_signature signature{ method };
            writer::indent_guard g{ w };

            auto format = "return py::arg_count_invoker(args, %, [=](PyObject* args) -> PyObject* {\n%});\n";
            w.write(format, count_in_param(signature.params()), bind<write_method_body_contents>(type, method));
        }
        else
        {
            writer::indent_guard g{ w };

            auto format = "return py::trycatch_invoker([=]() -> PyObject* {\n%});\n";
            w.write(format, bind<write_method_body_contents>(type, method));
        }
    }

    void write_method_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        w.write("\nstatic PyObject* %(%* %, PyObject* %)\n{\n",
            bind<write_method_function_name>(type, method),
            bind<write_pywrapper_type>(type),
            bind<write_self_param_name>(method),
            bind<write_args_param_name>(method));
        write_method_body(w, type, method);
        w.write("}\n");
    }

    void write_pinterface_method_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        auto format = R"(
static PyObject* %(%* self, PyObject* args)
{
    return self->obj->%(args);
}
)";
        w.write(format,
            bind<write_method_function_name>(type, method),
            bind<write_pywrapper_type>(type),
            method.Name());
    }

    void write_class_functions(writer& w, TypeDef const& type)
    {
        for (auto&& method : type.MethodList())
        {
            write_method_function(w, type, method);
        }
    }

    void write_interface_functions(writer& w, TypeDef const& type)
    {
        //auto ptype = is_ptype(type);

        //for (auto&& ii : get_required_interfaces(type))
        //{
        //    auto guard{ w.push_generic_params(ii.type_arguments) };

        //    for (auto&& method : ii.type.MethodList())
        //    {
        //        if (ptype)
        //        {
        //            write_pinterface_method_function(w, type, method);
        //        }
        //        else
        //        {
        //            write_method_function(w, type, method);
        //        }
        //    }
        //}
    }


    void write_from_function(writer& w, TypeDef const& type)
    {
        if (is_static(type) || is_ptype(type)) return;

        w.write(strings::from_function, type.TypeName(), type);
    }

    void write_non_activatable(writer& w, TypeDef const& type)
    {
        auto format = R"(
static PyObject* _new_@(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_@ };
    msg.append(" is not directly constructable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}
)";
        w.write(format, type.TypeName(), type.TypeName());
    }










    

    void write_getter_method(writer& w, TypeDef const& type, method_info const& info)
    {
        auto&[method, semanitcs] = info;

        w.write("\nstatic PyObject* @_%(%* self, void* /*unused*/)\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_pywrapper_type>(type));

        {
            writer::indent_guard g{ w };

            if (is_ptype(type))
            {
                w.write("return self->obj->%();\n", method.Name());
            }
            else
            {
                w.write("return nullptr; // TODO real impl\n");
            }
        }

        w.write("}\n");
    }

    void write_setter_method(writer& w, TypeDef const& type, method_info const& info)
    {
        auto&[method, semanitcs] = info;

        w.write("\nstatic int @_%(%* self, PyObject* arg, void* /*unused*/)\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_pywrapper_type>(type));

        {
            writer::indent_guard g{ w };

            if (is_ptype(type))
            {
                w.write("return self->obj->%(arg);\n", method.Name());
            }
            else
            {
                w.write("return 0; // TODO real impl\n");
            }
        }

        w.write("}\n");

    }

    void write_method_overloads(writer& w, TypeDef const& type, std::vector<method_info> const& overloads)
    {
        w.write("Py_ssize_t arg_count = PyTuple_Size(args);\n\n");

        separator s{ w, "else " };
        for (auto&& [method, semantics] : overloads)
        {
            method_signature signature{ method };
            s();
            w.write("if (arg_count == %)\n{\n", count_in_param(signature.params()));
            {
                writer::indent_guard g{ w };
                w.write("return nullptr; // TODO real impl\n");
            }
            w.write("}\n");
        }

        w.write(R"(else if (arg_count != -1)
{
    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
}
return nullptr;
)");
    }

    void write_method(writer& w, TypeDef const& type, std::vector<method_info> const& overloads)
    {
        XLANG_ASSERT(overloads.size() > 0);

        //auto&[method, semanitcs] = overloads[0];

        //auto self_type = is_static(overloads) ? "void" : w.write_temp("%", bind<write_pywrapper_type>(type));

        //w.write("\nstatic PyObject* @_%(%* %, PyObject* args)\n{\n",
        //    type.TypeName(),
        //    method.Name(),
        //    self_type,
        //    bind<write_self_param_name>(method));

        //if (is_ptype(type))
        //{
        //    writer::indent_guard g{ w };
        //    w.write("return self->obj->%(args);\n", method.Name());
        //}
        //else
        //{
        //    writer::indent_guard g{ w };
        //    write_method_overloads(w, type, overloads);
        //}

        //w.write("}\n");
    }

    void write_method_functions(writer& w, TypeDef const& type)
    {
        //for (auto&&[name, overloads] : get_methods(type))
        //{
        //    if (is_get_method(overloads) && !is_static(overloads))
        //    {
        //        write_getter_method(w, type, overloads[0]);
        //    }
        //    else if (is_put_method(overloads) && !is_static(overloads))
        //    {
        //        auto[method, semantics] = overloads[0];
        //        write_setter_method(w, type, overloads[0]);
        //    }
        //    else
        //    {
        //        write_method(w, type, overloads);
        //    }
        //}

        // TODO:
        //  From
        //  str
        //  enter/exit
        //  await
        //  iterator/sequence/mapping
    }

    void write_method_table(writer& w, TypeDef const& type)
    {
        auto get_argument_convention_flag = [](MethodDef const& method)
        {
            switch (get_argument_convention(method))
            {
            case argument_convention::no_args:
                return "METH_NOARGS";
            case argument_convention::single_arg:
                return "METH_O";
            case argument_convention::variable_args:
                return "METH_VARARGS";
            }

            throw_invalid("invalid argument_convention");
        };

        auto write_row = [&](MethodDef const& method)
        {
            auto argument_convention_flag = get_argument_convention_flag(method);
            auto static_flag = is_static(method) || is_constructor(method)
                ? " | METH_STATIC" 
                : "";

            w.write("{ \"%\", (PyCFunction)@_%, %%, nullptr },\n",
                bind<write_lower_snake_case>(method.Name()),
                type.TypeName(), method.Name(),
                argument_convention_flag,
                static_flag);
        };

        w.write("\nstatic PyMethodDef _methods_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            for (auto&&[name, methods] : get_methods(type))
            {
                write_row(std::get<0>(methods.front()));
            }

            for (auto&&[prop, semantics] : get_properties(type))
            {
                auto[get_method, put_method] = get_property_methods(prop);
                if (!is_static(get_method)) continue;

                write_row(get_method);
                if (put_method) write_row(put_method);
            }

            for (auto[evt, semantics] : get_events(type))
            {
                auto [add_method, remove_method] = get_event_methods(evt);
                write_row(add_method);
                write_row(remove_method);
            }

            // TODO: From, Enter, Exit rows

            w.write("{ nullptr }\n");
        }

        w.write("};\n");
    }

    void write_getset_table(writer& w, TypeDef const& type)
    {
        auto write_row = [&](std::string_view field_name, std::string_view getter_name, std::string_view setter_name)
        {
            auto setter = setter_name.empty() ? "nullptr" : w.write_temp("(setter)@_%", type.TypeName(), setter_name);

            // TODO: remove const_cast once pywinrt is updated to target Python 3.7. 
            //       pywinrt currently targeting 3.6 because that's the version that ships with VS 2017 v15.8
            //       https://github.com/python/cpython/commit/007d7ff73f4e6e65cfafd512f9c23f7b7119b803
            w.write("{ const_cast<char*>(\"%\"), (getter)@_%, %, nullptr, nullptr },\n",
                bind<write_lower_snake_case>(field_name),
                type.TypeName(), getter_name,
                setter);
        };

        w.write("\nstatic PyGetSetDef _getset_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            auto category = get_category(type);
            if (category == category::struct_type)
            {
                for (auto&& field : type.FieldList())
                {
                    write_row(field.Name(), w.write_temp("get_%", field.Name()), w.write_temp("set_%", field.Name()));
                }
            }
            else if (category == category::class_type || category == category::interface_type)
            {
                enumerate_required_types(type, [&](type_semantics const& semantics)
                {
                    for (auto&& prop : get_typedef(semantics).PropertyList())
                    {
                        auto[getter, setter] = get_property_methods(prop);

                        if (is_static(getter)) continue;

                        write_row(prop.Name(), getter.Name(), setter ? setter.Name() : "");
                    }
                });
            }
            w.write("{ nullptr }\n");
        }
        w.write("};\n");
    }

    void write_type_slot_table(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        auto dealloc_value = ((category == category::class_type) && is_static(type)) 
            ? "nullptr"
            : w.write_temp("_dealloc_@", type.TypeName());
        auto methods_value = ((category == category::class_type) || (category == category::interface_type))
            ? w.write_temp("_methods_@", type.TypeName())
            : "nullptr";

        auto format = R"(
static PyType_Slot _type_slots_@[] = 
{
    { Py_tp_new, _new_@ },
    { Py_tp_dealloc, % },
    { Py_tp_methods, % },
    { Py_tp_getset, _getset_@ }, 
    { 0, nullptr },
};
)";

        w.write(format,
            type.TypeName(),
            type.TypeName(),
            dealloc_value,
            methods_value,
            type.TypeName());
    }

    void write_type_spec(writer& w, TypeDef const& type)
    {
        auto type_size = is_static(type) ? "0" : w.write_temp("sizeof(%)", bind<write_pywrapper_type>(type));

        auto format = R"(
static PyType_Spec _type_spec_@ =
{
    "%.@",
    %,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_@
};
)";
        auto type_name = type.TypeName();
        w.write(format,
            type_name,
            bind<write_ns_module_name>(type.TypeNamespace()),
            type_name,
            type_size,
            type_name);
    }

    void write_class(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\n// ----- % class --------------------\n", type.TypeName());
        write_winrt_type_specialization_storage(w, type);
        //write_non_activatable(w, type);
        //write_dealloc_function(w, type);
        //write_class_functions(w, type);
        //write_from_function(w, type);

        write_method_functions(w, type);
        write_method_table(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

    void write_interface(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\n// ----- @ interface --------------------\n", type.TypeName());
        write_winrt_type_specialization_storage(w, type);
        //write_non_activatable(w, type);
        //write_dealloc_function(w, type);
        //write_interface_functions(w, type);
        //write_from_function(w, type);

        write_method_functions(w, type);
        write_method_table(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma region struct functions

    void write_struct_converter_decl(writer& w, TypeDef const& type)
    {
        w.write("template<>\nstruct converter<%>\n{\n", type);
        {
            writer::indent_guard g{ w };
            w.write("static PyObject* convert(% instance) noexcept;\nstatic % convert_to(PyObject* obj);\n", type, type);
        }

        w.write("};\n\n");
    }

    void write_struct_field_var_type(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type type)
        {
            switch (type)
            {
            case fundamental_type::Boolean:
                w.write("bool");
                break;
            case fundamental_type::Char:
                w.write("char16_t");
                break;
            case fundamental_type::Int8:
                w.write("int8_t");
                break;
            case fundamental_type::UInt8:
                w.write("uint8_t");
                break;
            case fundamental_type::Int16:
                w.write("int16_t");
                break;
            case fundamental_type::UInt16:
                w.write("uint16_t");
                break;
            case fundamental_type::Int32:
                w.write("int32_t");
                break;
            case fundamental_type::UInt32:
                w.write("uint32_t");
                break;
            case fundamental_type::Int64:
                w.write("int64_t");
                break;
            case fundamental_type::UInt64:
                w.write("uint64_t");
                break;
            case fundamental_type::Float:
                w.write("float");
                break;
            case fundamental_type::Double:
                w.write("double");
                break;
            case fundamental_type::String:
                w.write("winrt::hstring");
                break;
            default:
                throw_invalid("invalid fundamental type");
            }
        },
            [&](TypeDef const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write("py::pyobj_handle");
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_keyword(writer& w, Field const& field)
    {
        w.write("\"%\", ", bind<write_lower_snake_case>(field.Name()));
    }

    void write_struct_field_format(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type type)
        {
            switch (type)
            {
            case fundamental_type::Boolean:
                w.write("p");
                break;
                // TODO: 'u' format string was deprecated in Python 3.3. Need to move to a supported construct
            case fundamental_type::Char:
                w.write("u1");
                break;
            case fundamental_type::Int8:
                w.write("y1");
                break;
            case fundamental_type::UInt8:
                w.write("y1");
                break;
            case fundamental_type::Int16:
                w.write("h");
                break;
            case fundamental_type::UInt16:
                w.write("H");
                break;
            case fundamental_type::Int32:
                w.write("i");
                break;
            case fundamental_type::UInt32:
                w.write("I");
                break;
            case fundamental_type::Int64:
                w.write("L");
                break;
            case fundamental_type::UInt64:
                w.write("K");
                break;
            case fundamental_type::Float:
                w.write("f");
                break;
            case fundamental_type::Double:
                w.write("d");
                break;
                // TODO: 'u' format string was deprecated in Python 3.3. Need to move to a supported construct
            case fundamental_type::String:
                w.write("u");
                break;
            default:
                throw_invalid("invalid fundamental type");
            }
        },
            [&](type_definition const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write("O");
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_parse_parameter(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type) { w.write(", &_%", field.Name()); },
            [&](type_definition const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write(", _%.put()", field.Name());
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_initalizer(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, false),
            [&](fundamental_type) { w.write("_%", field.Name()); },
            [&](type_definition const& type)
        {
            auto category = get_category(type);
            XLANG_ASSERT((category == category::struct_type) || (category == category::enum_type));
            switch (category)
            {
            case category::enum_type:
                w.write("static_cast<%>(_%)", type, field.Name());
                break;
            case category::struct_type:
                w.write("py::converter<%>::convert_to(_%.get())", type, field.Name());
                break;
            }
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_ref_capture(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type) { },
            [&](TypeDef const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write(", &_%", field.Name());
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_constructor(writer& w, TypeDef const& type)
    {
        w.write("\nPyObject* _new_@(PyTypeObject* type, PyObject* args, PyObject* kwds)\n{", type.TypeName());
        {
            writer::indent_guard g{ w };

            {
                auto format = R"(
auto tuple_size = PyTuple_Size(args);

if ((tuple_size == 0) && (kwds == nullptr))
{
    return py::trycatch_invoker([]() -> PyObject* {
        % return_value{};
        return py::convert(return_value);
    });
}

if ((tuple_size == 1) && (kwds == nullptr))
{
    auto arg = PyTuple_GetItem(args, 0);
    if (PyDict_Check(arg)) 
    {
        return py::trycatch_invoker([arg]() -> PyObject* {
            auto return_value = py::convert_to<%>(arg);
            return py::convert(return_value);
        });
    };
};

)";
                w.write(format, type, type);
            }

            for (auto&& field : type.FieldList())
            {
                w.write("% _%{};\n", bind<write_struct_field_var_type>(field), field.Name());
            }

            {
                auto format = R"(
static char* kwlist[] = {%nullptr};
if (!PyArg_ParseTupleAndKeywords(args, kwds, "%", kwlist%)) {
    return nullptr;
}
)";
                w.write(format,
                    bind_each<write_struct_field_keyword>(type.FieldList()),
                    bind_each<write_struct_field_format>(type.FieldList()),
                    bind_each<write_struct_field_parse_parameter>(type.FieldList()));
            }

            if (has_custom_conversion(type))
            {
                auto format = R"(
return py::trycatch_invoker([=]() -> PyObject* {
    % return_value{ };
    custom_set(return_value, %);
    return py::convert(return_value);
});
)";
                w.write(format, type, bind<write_struct_field_initalizer>(type.FieldList().first));
            }
            else
            {
                auto format = R"(
return py::trycatch_invoker([=%]() -> PyObject* {
    % return_value{ 
        % };
    return py::convert(return_value);
});
)";
                w.write(format,
                    bind_each<write_struct_field_ref_capture>(type.FieldList()),
                    type,
                    bind_list<write_struct_field_initalizer>(", \n        ", type.FieldList()));
            }
        }
        w.write("}\n");
    }

    void write_struct_field_name(writer& w, Field const& field)
    {
        static const std::set<std::string_view> custom_numerics = { "Matrix3x2", "Matrix4x4", "Plane", "Quaternion", "Vector2", "Vector3", "Vector4" };

        auto type = field.Parent();
        if ((type.TypeNamespace() == "Windows.Foundation.Numerics") &&
            (custom_numerics.find(type.TypeName()) != custom_numerics.end()))
        {
            for (char c : field.Name())
            {
                w.write(static_cast<char>(::tolower(c)));
            }
        }
        else
        {
            w.write(field.Name());
        }
    }

    void write_struct_getset_function(writer& w, TypeDef const& type, Field const& field)
    {
        w.write("\nstatic PyObject* @_get_%(%* self, void* /*unused*/)\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{ w };

            if (has_custom_conversion(type))
            {
                auto format = R"(return py::trycatch_invoker([self]() -> PyObject* {
    return py::convert(custom_get(self->obj));
});
)";
                w.write(format);
            }
            else
            {
                auto format = R"(return py::trycatch_invoker([self]() -> PyObject* {
    return py::convert(self->obj.%);
});
)";
                w.write(format, bind<write_struct_field_name>(field));
            }
        }
        w.write("}\n");

        w.write("\nstatic int @_set_%(%* self, PyObject* value, void* /*unused*/)\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{ w };

            if (has_custom_conversion(type))
            {
                auto format = R"(return py::struct_set_invoker(value, [=](PyObject* value) {
    custom_set(self->obj, py::converter<%>::convert_to(value));
});
)";
                w.write(format, field.Signature().Type());
            }
            else
            {
                auto format = R"(return py::struct_set_invoker(value, [=](PyObject* value) {
    self->obj.% = py::converter<%>::convert_to(value);
});
)";

                w.write(format, bind<write_struct_field_name>(field), field.Signature().Type());
            }
        }
        w.write("}\n");
    }

    void write_struct_getset_functions(writer& w, TypeDef const& type)
    {
        for (auto&& field : type.FieldList())
        {
            write_struct_getset_function(w, type, field);
        }
    }

    void write_struct_convert_functions(writer& w, TypeDef const& type)
    {
        w.write("\nPyObject* py::converter<%>::convert(% instance) noexcept\n{\n", type, type);
        {
            writer::indent_guard g{ w };
            w.write("return py::wrap_struct(instance, py::get_python_type<%>());\n", type);
        }
        w.write("}\n\n");

        w.write("% py::converter<%>::convert_to(PyObject* obj)\n{\n", type, type);
        {
            writer::indent_guard g{ w };

            auto format = R"(throw_if_pyobj_null(obj);
    
if (Py_TYPE(obj) == py::get_python_type<%>())
{
    return reinterpret_cast<py::winrt_struct_wrapper<%>*>(obj)->obj;
}
    
if (!PyDict_Check(obj))
{
    throw winrt::hresult_invalid_argument();
}
    
)";
            w.write(format, type, type);

            w.write("% return_value{};\n", type);

            for (auto&& field : type.FieldList())
            {
                w.write("\npy::pyobj_handle py_%{ PyDict_GetItemString(obj, \"%\") };\n", field.Name(), bind<write_lower_snake_case>(field.Name()));
                w.write("if (!py_%) { throw winrt::hresult_invalid_argument(); }\n", field.Name());

                if (has_custom_conversion(type))
                {
                    w.write("custom_set(return_value, converter<%>::convert_to(py_%.get()));\n", field.Signature().Type(), field.Name());
                }
                else
                {
                    w.write("return_value.% = converter<%>::convert_to(py_%.get());\n", bind<write_struct_field_name>(field), field.Signature().Type(), field.Name());
                }
            }

            w.write("\nreturn return_value;\n");
        }
        w.write("}\n");
    }

    void write_struct(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\n// ----- % struct --------------------\n", type.TypeName());
        write_winrt_type_specialization_storage(w, type);
        write_struct_convert_functions(w, type);
        write_struct_constructor(w, type);
        write_dealloc_function(w, type);
        write_struct_getset_functions(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma endregion

#pragma region delegate functions
    void write_delegate_template_args(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            w.write("<%>", bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
    }

    void write_delegate_type_mapper(writer& w, TypeDef const& type)
    {
        auto format = R"(template <%>
struct delegate_python_type<%%>
{
    using type = %%;
};

)";
        w.write(format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind<write_delegate_template_args>(type),
            bind<write_pyimpl_type>(type),
            bind<write_delegate_template_args>(type));
    }

    void write_delegate_param(writer& w, method_signature::param_t const& p)
    {
        w.write("auto %", bind<write_param_name>(p));
    }

    void write_delegate_callable_wrapper(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        auto invoke = get_delegate_invoke(type);
        method_signature signature{ invoke };

        if (is_ptype(type))
        {
            w.write("\ntemplate <%>", bind_list<write_template_arg>(", ", type.GenericParam()));
        }

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            w.write("static %% get(PyObject* callable)\n{\n", type, bind<write_delegate_template_args>(type));
            {
                writer::indent_guard gg{ w };

                {
                    auto format = R"(py::delegate_callable _delegate{ callable };
    
return [delegate = std::move(_delegate)](%)
{
)";
                    w.write(format, bind_list<write_delegate_param>(", ", signature.params()));
                }
                {
                    writer::indent_guard ggg{ w };

                    w.write("winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };\n\n");

                    std::vector<std::string> tuple_params{};
                    for (auto&& p : signature.params())
                    {
                        auto param_name = w.write_temp("%", bind<write_param_name>(p));
                        auto py_param_name = "py_"s + param_name;

                        w.write("py::pyobj_handle %{ py::convert(%) };\n", py_param_name, param_name);
                        tuple_params.push_back(py_param_name);
                    }

                    if (tuple_params.size() > 0)
                    {
                        w.write("\npy::pyobj_handle args{ % };\n", bind<write_py_tuple_pack>(tuple_params));
                    }
                    else
                    {
                        w.write("py::pyobj_handle args{ nullptr };\n");
                    }

                    w.write(R"(py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };

if (!return_value) 
{
    // TODO: propagate Python error
    throw winrt::hresult_invalid_argument();
}
)");

                    if (signature.return_signature())
                    {
                        w.write("\nreturn py::convert<%>(return_value.get());\n", signature.return_signature().Type());
                    }
                }

                w.write("};\n");
            }
            w.write("};\n");
        }
        w.write("};\n");
    }
#pragma endregion

#pragma region pinterface functions
    void write_pinterface_type_mapper(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto format = R"(template <%>
struct pinterface_python_type<%<%>>
{
    using abstract = %;
    using concrete = %<%>;
};

)";
        w.write(format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind_list<write_template_arg_name>(", ", type.GenericParam()),
            bind<write_pyproj_type>(type),
            bind<write_pyimpl_type>(type),
            bind_list<write_template_arg_name>(", ", type.GenericParam()));
    }

    void write_pinterface_decl(writer& w, TypeDef const& type)
    {
        //if (!is_ptype(type))
        //    return;

        //auto guard{ w.push_generic_params(type.GenericParam()) };

        //w.write("\nstruct @\n{\n", type.TypeName());
        //{
        //    writer::indent_guard g{ w };

        //    w.write("virtual ~@() {};\n", type.TypeName());
        //    w.write("virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;\n");
        //    w.write("virtual std::size_t hash() = 0;\n");

        //    for (auto&&[name, methods] : get_methods(type))
        //    {
        //        if (is_get_method(methods))
        //        {
        //            w.write("virtual PyObject* %() = 0;\n", name);
        //        }
        //        else if (is_put_method(methods))
        //        {
        //            w.write("virtual int %(PyObject*) = 0;\n", name);
        //        }
        //        else
        //        {
        //            w.write("virtual PyObject* %(PyObject*) = 0;\n", name);
        //        }
        //    }
        //}
        //w.write("};\n");
    }

    void write_pinterface_impl(writer& w, TypeDef const& type)
    {
        //if (!is_ptype(type))
        //    return;

        //auto guard{ w.push_generic_params(type.GenericParam()) };

        //w.write("\ntemplate<%>\nstruct @ : public py::proj::%::@\n{\n",
        //    bind_list<write_template_arg>(", ", type.GenericParam()),
        //    type.TypeName(),
        //    bind<write_type_namespace>(type),
        //    type.TypeName());

        //{
        //    writer::indent_guard g{ w };

        //    w.write("@(%<%> o) : _obj(o) {}\n", type.TypeName(), type, bind_list<write_template_arg_name>(", ", type.GenericParam()));
        //    w.write("winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }\n");
        //    w.write("std::size_t hash() override { return py::get_instance_hash(_obj); }\n");

        //    for (auto&&[name, methods] : get_methods(type))
        //    {
        //        // TODO: real impl
        //        // write_method_body(w, type, method);
        //        if (is_get_method(methods))
        //        {
        //            w.write("PyObject* %() override\n{\n    return nullptr;\n}\n", name);
        //        }
        //        else if (is_put_method(methods))
        //        {
        //            w.write("int %(PyObject* arg) override\n{\n    return 0;\n}\n", name);
        //        }
        //        else
        //        {
        //            w.write("PyObject* %(PyObject*) override\n{\n    return nullptr;\n}\n", name);
        //        }
        //    }

        //    w.write("\n%<%> _obj{ nullptr };\n", type, bind_list<write_template_arg_name>(", ", type.GenericParam()));
        //}
        //w.write("};\n");
    }
#pragma endregion
}