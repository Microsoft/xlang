#pragma once

namespace xlang
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        w.write(case_func(name[0]));
        for (std::string_view::size_type i = 1; i < name.size() - 1; i++)
        {
            if (name.substr(i, 4) == "UInt")
            {
                w.write('_');
            }

            if (isupper(name[i]) && islower(name[i + 1]))
            {
                if (name.substr(i - 1, 4) != "UInt")
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
        w.write(case_func(name[name.size() - 1]));
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::toupper(c)); });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::tolower(c)); });
    }

    void write_setup_filenames(writer& w, std::vector<std::string> const& namespaces)
    {
        XLANG_ASSERT(namespaces.size() > 0);

        for (auto&& ns : namespaces)
        {
            w.write("'%/src/py.%.cpp', ", settings.module, ns);
        }

        w.write("'%/src/_%.cpp'", settings.module, settings.module);
    }

    void write_license_python(writer& w)
    {
        w.write("# WARNING: Please don't edit this file. It was generated by Python/WinRT\n\n");
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {
        w.write("class %(enum.%):\n", type.TypeName(), is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{ w };

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write("% = %\n", bind<write_upper_snake_case>(field.Name()), *constant);
                }
            }
        }

        w.write("\n");
    }
    
    void write_python_method_args(writer& w, MethodDef const& method)
    {
        separator s{ w };

        if (!is_static(method) && !is_constructor(method))
        {
            s();
            w.write("self");
        }

        method_signature signature{ method };
        for (auto&& p : signature.params())
        {
            s();
            w.write("%", p.first.Name());
        }
    }

    void write_python_method_invoke_params(writer& w, MethodDef const& method)
    {
        separator s{ w };
        method_signature signature{ method };
        for (auto&& p : signature.params())
        {
            s();
            w.write("%", p.first.Name());
        }
    }

    void write_python_method_name(writer& w, MethodDef const& method)
    {
        if (!method)
        {
            w.write("None");
        }
        else if (is_constructor(method))
        {
            // TODO
            w.write(method.Name());
        }
        else if (method.SpecialName())
        {
            w.write("__%", method.Name());
        }
        else
        {
            write_lower_snake_case(w, method.Name());
        }
    }

    void write_return_statement(writer& w, MethodDef const& method)
    {
        struct return_stmt : public signature_handler_base<return_stmt>
        {
            writer& ww;

            return_stmt(writer& w) : ww(w) {}

            using signature_handler_base<return_stmt>::handle;
            void write_return(std::string_view ns, std::string_view name)
            {
                if (ns == ww.current_namespace)
                {
                    ww.write("return %(ret)\n", name);
                }
                else
                {
                    ww.write("# wrongns return %.%(ret)\n", ns, name);
                }
            }

            void handle(TypeDef const& type)
            {
                write_return(type.TypeNamespace(), type.TypeName());
            }
            void handle(TypeRef const& type)
            {
                write_return(type.TypeNamespace(), type.TypeName());
            }
            void handle(GenericTypeInstSig const& type)
            {
                ww.write("# return gtisig %\n", type.GenericType());
            }

            void handle(ElementType /*type*/)
            {
                ww.write("return ret\n");
            }

            // WinRT class, interface and delegate out params must be initialized as nullptr
            //void handle_class(TypeDef const& /*type*/) { param_init = "nullptr"; }
            //void handle_delegate(TypeDef const& /*type*/) { param_init = "nullptr"; }
            //void handle_interface(TypeDef const& /*type*/) { param_init = "nullptr"; }
            //void handle(GenericTypeInstSig const& /*type*/) { param_init = "nullptr"; }

            //// WinRT guid, struct and fundamental types don't require an initialization value
            //void handle_guid(TypeRef const& /*type*/) { /* no init needed */ }
            //void handle_struct(TypeDef const& /*type*/) { /* no init needed */ }
            //void handle(ElementType /*type*/) { /* no init needed */ }
        };

        method_signature signature{ method };
        if (signature.return_signature())
        {
            return_stmt ret{ w };
            ret.handle(signature.return_signature().Type());
        }
    }

    void write_pyparam_name(writer& w, method_signature::param_t param)
    {
        w.write(param.first.Name());
    }

    void write_in_params(writer& w, method_signature sig)
    {
        separator s{ w };
        for (auto&& p : sig.params())
        {
            if (is_in_param(p))
            {
                s();
                w.write(p.first.Name());
            }
        }
    }

    void write_out_params(writer& w, method_signature sig)
    {
        separator s{ w };
        if (sig.return_signature())
        {
            s();
            w.write(sig.return_param_name());
        }

        for (auto&& p : sig.params())
        {
            if (is_out_param(p))
            {
                s();
                w.write(p.first.Name());
            }
        }
    }

    auto get_params(MethodDef const& method)
    {
        std::vector<std::string_view> in_params{};
        std::vector<std::string_view> out_params{};

        method_signature sig{ method };

        if (sig.return_signature())
        {
            out_params.push_back(sig.return_param_name());
        }

        for (auto&& p : sig.params())
        {
            if (is_in_param(p))
            {
                in_params.push_back(p.first.Name());
            }

            if (is_out_param(p))
            {
                out_params.push_back(p.first.Name());
            }
        }

        if (is_constructor(method))
        {
            XLANG_ASSERT(out_params.size() == 0);
            out_params.push_back("_return_value");
        }

        return std::make_tuple(std::move(in_params), std::move(out_params));
    }



    void write_python_class(writer& w, TypeDef const& type)
    {
        w.write("class %:\n", type.TypeName());
        {
            writer::indent_guard g{ w };
            w.write("pass\n");

            //w.write("__native_type = __ns__.%\n\n", type.TypeName());

            //w.write("def __init__(self, instance):\n");
            //{
            //    writer::indent_guard gg{ w };
            //    w.write("self.__instance = instance\n");
            //}

            //for (auto&& method : type.MethodList())
            //{
            //    method_signature sig{ method };
            //    auto[in_params, out_params] = get_params(method);
            //    w.write("\n# %(%) -> (%)\n", 
            //        bind<write_python_method_name>(method), 
            //        bind_list(", ", in_params), 
            //        bind_list(", ", out_params));

            //    if (is_constructor(method))
            //    {
            //        w.write("# def %(%): %\n",
            //            bind<write_python_method_name>(method),
            //            bind<write_python_method_args>(method),
            //            bind<write_method_name>(method));
            //        continue;
            //    }

            //    if (is_static(method))
            //    {
            //        w.write("@staticmethod\n");
            //    }
            //    w.write("def %(%):\n", 
            //        bind<write_python_method_name>(method), 
            //        bind<write_in_params>(sig));
            //    {
            //        writer::indent_guard gg{ w };
            //        w.write("# (%) -> (%)\n", bind<write_in_params>(sig), bind<write_out_params>(sig));

            //        if (is_static(method))
            //        {
            //            w.write("% = _ns_module.%.%(%)\n",
            //                bind<write_out_params>(sig),
            //                type.TypeName(),
            //                bind<write_method_name>(method),
            //                bind<write_in_params>(sig));
            //        }
            //        else
            //        {
            //            w.write("% = self.__instance.%(%)\n",
            //                bind<write_out_params>(sig),
            //                bind<write_method_name>(method),
            //                bind<write_in_params>(sig));
            //        }

            //        //write_return_statement(w, method);
            //    }
            //}

            //for (auto&& prop : type.PropertyList())
            //{
            //    auto prop_methods = get_property_methods(prop);
            //    if (is_static(prop_methods.get))
            //    {
            //        w.write("# staticprop");
            //    }
            //    w.write("% = property(fget=%, fset=%)\n",
            //        prop.Name(),
            //        bind<write_python_method_name>(prop_methods.get),
            //        bind<write_python_method_name>(prop_methods.set));
            //}

            //for (auto&& evt : type.EventList())
            //{
            //    auto evt_methods = get_event_methods(evt);
            //    w.write("# ");
            //    if (is_static(evt_methods.add))
            //    {
            //        w.write("staticevent ");
            //    }

            //    w.write("% = winrt.event(fadd=%, fremove=%)\n",
            //        evt.Name(),
            //        bind<write_python_method_name>(evt_methods.add),
            //        bind<write_python_method_name>(evt_methods.remove));
            //}

        }
        w.write("\n");
    }
}