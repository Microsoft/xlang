#pragma once

namespace xlang
{
    void write_setup_filenames(writer& w, std::vector<std::string> const& namespaces)
    {
        XLANG_ASSERT(namespaces.size() > 0);

        for (auto&& ns : namespaces)
        {
            w.write("'%/src/py.%.cpp', ", settings.module, ns);
        }

        w.write("'%/src/_%.cpp'", settings.module, settings.module);
    }

    void write_license_python(writer& w)
    {
        w.write("# WARNING: Please don't edit this file. It was generated by Python/WinRT\n\n");
    }

    void write_import_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        w.write("@ = __ns__.@\n", type.TypeName(), type.TypeName());
    }

    void write_python_enum_name(writer& w, std::string_view const& name)
    {
        // None is a python keyword, so project it as NONE
        if (name == "None")
        {
            for (auto&& c : name)
            {
                w.write(static_cast<char>(::toupper(c)));
            }
        }
        else
        {
            w.write(name);
        }
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {

        w.write("class %(enum.%):\n", type.TypeName(), is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{ w };

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write("% = %\n", bind<write_python_enum_name>(field.Name()), *constant);
                }
            }
        }

        w.write("\n");
    }
}