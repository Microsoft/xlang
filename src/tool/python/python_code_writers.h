#pragma once

namespace xlang
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        w.write(case_func(name[0]));
        for (std::string_view::size_type i = 1; i < name.size() - 1; i++)
        {
            if (name.substr(i, 4) == "UInt")
            {
                w.write('_');
            }

            if (isupper(name[i]) && islower(name[i + 1]))
            {
                if (name.substr(i - 1, 4) != "UInt")
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
        w.write(case_func(name[name.size() - 1]));
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::toupper(c)); });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::tolower(c)); });
    }

    void write_setup_filenames(writer& w, std::vector<std::string> const& namespaces)
    {
        XLANG_ASSERT(namespaces.size() > 0);

        for (auto&& ns : namespaces)
        {
            w.write("'%/src/py.%.cpp', ", settings.module, ns);
        }

        w.write("'%/src/_%.cpp'", settings.module, settings.module);
    }

    void write_license_python(writer& w)
    {
        w.write("# WARNING: Please don't edit this file. It was generated by Python/WinRT\n\n");
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {
        w.write("class %(enum.%):\n", type.TypeName(), is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{ w };

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write("% = %\n", bind<write_upper_snake_case>(field.Name()), *constant);
                }
            }
        }

        w.write("\n");
    }

    void write_python_method_name(writer& w, MethodDef const& method)
    {
        if (!method)
        {
            w.write("None");
        }
        else if (is_constructor(method))
        {
            // TODO
            w.write(method.Name());
        }
        else if (method.SpecialName())
        {
            w.write("__%", method.Name());
        }
        else
        {
            write_lower_snake_case(w, method.Name());
        }
    }


    auto get_params(MethodDef const& method)
    {
        std::vector<std::string_view> in_params{};
        std::vector<std::string_view> out_params{};

        method_signature sig{ method };

        if (sig.return_signature())
        {
            out_params.push_back(sig.return_param_name());
        }

        for (auto&& p : sig.params())
        {
            if (is_in_param(p))
            {
                in_params.push_back(p.first.Name());
            }

            if (is_out_param(p))
            {
                out_params.push_back(p.first.Name());
            }
        }

        if (is_constructor(method))
        {
            XLANG_ASSERT(out_params.size() == 0);
            out_params.push_back("_return_value");
        }

        return std::make_tuple(std::move(in_params), std::move(out_params));
    }

    auto get_constructors(TypeDef const& type)
    {
        std::vector<MethodDef> ctors{};

        for (auto&& method : type.MethodList())
        {
            if (is_constructor(method))
            {
                ctors.push_back(method);
            }
        }

        return std::move(ctors);
    }

    auto get_methods(TypeDef const& type)
    {
        std::map<std::string_view, std::vector<MethodDef>> methods{};

        for (auto&& method : type.MethodList())
        {
            if (is_constructor(method)) continue;

            auto& v = methods[method.Name()];
            XLANG_ASSERT(std::all_of(v.begin(), v.end(), [&method](auto const& m) { return is_static(m) == is_static(method); }));
            v.push_back(method);
        }

        return std::move(methods);
    }

    template<typename T>
    bool contains(std::set<T> const& set, T const& value)
    {
        return set.find(value) != set.end();
    }

    auto get_property_methods(Property const& prop)
    {
        MethodDef get_method{}, set_method{};

        for (auto&& method_semantic : prop.MethodSemantic())
        {
            auto semantic = method_semantic.Semantic();

            if (semantic.Getter())
            {
                get_method = method_semantic.Method();
            }
            else if (semantic.Setter())
            {
                set_method = method_semantic.Method();
            }
            else
            {
                throw_invalid("Properties can only have get and set methods");
            }
        }

        XLANG_ASSERT(get_method);

        if (set_method)
        {
            XLANG_ASSERT(get_method.Flags().Static() == set_method.Flags().Static());
        }

        return std::make_tuple(get_method, set_method);
    }

    /*auto get_event_methods(Event const& evt)
    {
        MethodDef add_method{}, remove_method{};

        for (auto&& method_semantic : evt.MethodSemantic())
        {
            auto semantic = method_semantic.Semantic();

            if (semantic.AddOn())
            {
                add_method = method_semantic.Method();
            }
            else if (semantic.RemoveOn())
            {
                remove_method = method_semantic.Method();
            }
            else
            {
                throw_invalid("Events can only have add and remove methods");
            }
        }

        XLANG_ASSERT(add_method);
        XLANG_ASSERT(remove_method);
        XLANG_ASSERT(add_method.Flags().Static() == remove_method.Flags().Static());

        return std::make_tuple(add_method, remove_method);
    }

    auto get_in_params(std::vector<MethodDef> const& methods)
    {
        std::map<std::string_view, uint32_t> params{};

        for (auto&& method : methods)
        {
            auto[inparams, outparams] = get_params(method);
            for (auto&& inparam : inparams)
            {
                if (params.find(inparam) == params.end())
                {
                    params[inparam] = 1;
                }
                else
                {
                    params[inparam] = params[inparam] + 1;
                }
            }
        }

        return std::move(params);
    }
*/
    void write_python_class_init(writer& w, TypeDef const& type)
    {
        if (is_static(type))
        {
            w.write(R"(def __new__(cls):
    raise TypeError("% is a static class. It cannot be constructed")
)", type.TypeName());
        }
        else
        {
            auto is_default_constructable = false;
            for (auto&& method : type.MethodList())
            {
                if (is_constructor(method) && empty(method.ParamList()))
                {
                    is_default_constructable = true;
                    break;
                }
            }

            if (is_default_constructable)
            {
                w.write(R"(def __init__(self, *, _instance=None):
    if _instance == None:
        self.__instance = type(self).__type._default_ctor()
    else:
        if type(_instance) != type(self).__type:
            raise TypeError("_instance must be a % native type")
        self.__instance = _instance
)", type.TypeName());

            }
            else
            {
                w.write(R"(def __init__(self, *, _instance=None):
    if type(_instance) != type(self).__type:
        raise TypeError("_instance must be a % native type")
    self.__instance = _instance
)", type.TypeName());
            }

            w.write(R"(@property
def _instance(self):
    return self.__instance
)");
        }

    }

    void write_python_method_first_param(writer& w, MethodDef const& method)
    {
        if (is_static(method))
        {
            w.write("cls");
        }
        else
        {
            w.write("self");
        }
    }

    void write_python_method_params(writer& w, MethodDef const& method)
    {
        separator s{ w };
        s();
        write_python_method_first_param(w, method);

        auto[inparams, outparams] = get_params(method);
        for (auto&& inp : inparams)
        {
            s();
            w.write(inp);
            // TODO: type hint
        }
    }

    void write_python_method_body_return_values(writer& w, method_signature const& signature)
    {
        bool write_equals = false;
        separator s{ w };
     
        if (signature.return_signature())
        {
            s();
            w.write(signature.return_param_name());
            write_equals = true;
        }
        
        for (auto&& p : signature.params())
        {
            if (is_out_param(p))
            {
                s();
                w.write(p.first.Name());
                write_equals = true;
            }
        }

        if (write_equals)
        {
            w.write(" = ");
        }
    }

    void write_python_method_body_call_args(writer& w, method_signature const& signature)
    {
        separator s{ w };
        for (auto&& p : signature.params())
        {
            if (is_in_param(p))
            {
                s();
                w.write("_%", p.first.Name());
            }
        }
    }

    void write_python_method_body_calling_context(writer& w, MethodDef const& method)
    {
        if (is_static(method))
        {
            w.write("cls.__type");
        }
        else
        {
            w.write("self.__instance");
        }
    }

    void write_return_value_convert(writer& w, std::string_view name, TypeSig const& signature)
    {
        call(handle_signature(signature),
            [&](metadata_type const& type)
        {
            switch (type.category)
            {
            case category::class_type:
            //case category::interface_type:
                w.write("% = %(_instance=%)\n", name, type.type.TypeName(), name);
                break;
            case category::enum_type:
                break;
            default:
                w.write("# return_value category for % not implemented \n", name);
            }
        },
            [](fundamental_type) {},
            [&](auto)
        {
            w.write("# return_value for % not implemented \n", name);
        });
    }

    void write_in_param_convert(writer& w, std::string_view name, TypeSig const& signature)
    {
        call(handle_signature(signature),
            [&](metadata_type const& type)
        {
            switch (type.category)
            {
            case category::class_type:
            //case category::interface_type:
                w.write("_% = %._instance\n", name, name);
                break;
            default:
                w.write("# % in param category not implemented \n", name);
                w.write("_% = %\n", name, name);
            }
        },
            [&](auto) 
        {
            w.write("_% = %\n", name, name);
        });
    }

    void write_python_method_body(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };

        for (auto&& p : signature.params())
        {
            if (is_in_param(p))
            {
                write_in_param_convert(w, p.first.Name(), p.second->Type());
            }
        }

        w.write("%%.%(%)\n", 
            bind<write_python_method_body_return_values>(signature),
            bind<write_python_method_body_calling_context>(method),
            get_method_abi_name(method), 
            bind<write_python_method_body_call_args>(signature));

        std::vector<std::string_view> return_tuple{};

        if (signature.return_signature())
        {
            write_return_value_convert(w, signature.return_param_name(), signature.return_signature().Type());
            return_tuple.push_back(signature.return_param_name());
        }

        for (auto&& p : signature.params())
        {
            if (is_out_param(p))
            {
                write_return_value_convert(w, p.first.Name(), p.second->Type());
                return_tuple.push_back(p.first.Name());
            }
        }

        if (return_tuple.size() > 0)
        {
            w.write("return (%)\n", bind_list(", ", return_tuple));
        }
    }

    void write_python_method(writer& w, std::string_view name, std::vector<MethodDef> const& methods)
    {
        XLANG_ASSERT(std::all_of(methods.begin(), methods.end(), [&methods](auto const& m) { return is_static(methods[0]) == is_static(m); }));

        if (is_static(methods[0]))
        {
            w.write("@classmethod\n");
        }

        if (methods.size() == 1)
        {
            w.write("def %(%):\n", bind<write_python_method_name>(methods[0]), bind<write_python_method_params>(methods[0]));
            writer::indent_guard g{ w };
            write_python_method_body(w, methods[0]);
        }
        else
        {
            for (auto&& method : methods)
            {
                w.write("^@typing.overload\ndef %(%):\n    pass\n", name, bind<write_python_method_params>(method));
            }

            w.write("def %(%, *args):\n    pass\n", bind<write_python_method_name>(methods[0]), bind<write_python_method_first_param>(methods[0]));
        }
    }

    void write_python_class(writer& w, TypeDef const& type)
    {
        w.write("class %:\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            w.write("__type = _ns_module.%\n\n", type.TypeName());
            write_python_class_init(w, type);
            w.write("\n");

            for (auto&& [name, methods] : get_methods(type))
            {
                write_python_method(w, name, methods);
            }

            for (auto&& prop : type.PropertyList())
            {
                auto[getter, setter] = get_property_methods(prop);

                // TODO: static properties
                if (!is_static(getter))
                {
                    w.write("% = property(fget=%, fset=%)\n",
                        bind<write_lower_snake_case>(prop.Name()),
                        bind<write_python_method_name>(getter),
                        bind<write_python_method_name>(setter));
                }
            }

        }
        w.write("\n");
    }
}