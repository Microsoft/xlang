// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Media.h"

// ----- AudioBuffer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioBuffer>::python_type;

static PyObject* AudioBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "AudioBuffer is not activatable");
    return nullptr;
}

static void AudioBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* AudioBuffer_Close(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AudioBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateReference();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AudioBuffer_get_Length(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Length();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int AudioBuffer_put_Length(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.Length(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* AudioBuffer_get_Capacity(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Capacity();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AudioBuffer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::AudioBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AudioBuffer_enter(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __AudioBuffer_exit(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef AudioBuffer_methods[] = {
    { "Close", (PyCFunction)AudioBuffer_Close, METH_VARARGS, nullptr },
    { "CreateReference", (PyCFunction)AudioBuffer_CreateReference, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__AudioBuffer_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__AudioBuffer_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__AudioBuffer_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef AudioBuffer_getset[] = {
    { const_cast<char*>("Length"), (getter)AudioBuffer_get_Length, (setter)AudioBuffer_put_Length, nullptr, nullptr },
    { const_cast<char*>("Capacity"), (getter)AudioBuffer_get_Capacity, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot AudioBuffer_Type_slots[] = 
{
    { Py_tp_dealloc, AudioBuffer_dealloc },
    { Py_tp_new, AudioBuffer_new },
    { Py_tp_methods, AudioBuffer_methods },
    { Py_tp_getset, AudioBuffer_getset },
    { 0, nullptr },
};

static PyType_Spec AudioBuffer_Type_spec =
{
    "AudioBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::AudioBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    AudioBuffer_Type_slots
};

// ----- AudioFrame class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioFrame>::python_type;

static PyObject* AudioFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            winrt::Windows::Media::AudioFrame instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void AudioFrame_dealloc(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* AudioFrame_Close(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AudioFrame_LockBuffer(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioBufferAccessMode>(args, 0);
            
            auto return_value = self->obj.LockBuffer(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AudioFrame_get_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemRelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int AudioFrame_put_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.SystemRelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* AudioFrame_get_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int AudioFrame_put_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.RelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* AudioFrame_get_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsDiscontinuous();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int AudioFrame_put_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsDiscontinuous(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* AudioFrame_get_Duration(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int AudioFrame_put_Duration(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.Duration(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* AudioFrame_get_ExtendedProperties(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ExtendedProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AudioFrame_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsReadOnly();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AudioFrame_get_Type(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Type();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AudioFrame_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::AudioFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AudioFrame_enter(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __AudioFrame_exit(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef AudioFrame_methods[] = {
    { "Close", (PyCFunction)AudioFrame_Close, METH_VARARGS, nullptr },
    { "LockBuffer", (PyCFunction)AudioFrame_LockBuffer, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__AudioFrame_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__AudioFrame_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__AudioFrame_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef AudioFrame_getset[] = {
    { const_cast<char*>("SystemRelativeTime"), (getter)AudioFrame_get_SystemRelativeTime, (setter)AudioFrame_put_SystemRelativeTime, nullptr, nullptr },
    { const_cast<char*>("RelativeTime"), (getter)AudioFrame_get_RelativeTime, (setter)AudioFrame_put_RelativeTime, nullptr, nullptr },
    { const_cast<char*>("IsDiscontinuous"), (getter)AudioFrame_get_IsDiscontinuous, (setter)AudioFrame_put_IsDiscontinuous, nullptr, nullptr },
    { const_cast<char*>("Duration"), (getter)AudioFrame_get_Duration, (setter)AudioFrame_put_Duration, nullptr, nullptr },
    { const_cast<char*>("ExtendedProperties"), (getter)AudioFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsReadOnly"), (getter)AudioFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
    { const_cast<char*>("Type"), (getter)AudioFrame_get_Type, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot AudioFrame_Type_slots[] = 
{
    { Py_tp_dealloc, AudioFrame_dealloc },
    { Py_tp_new, AudioFrame_new },
    { Py_tp_methods, AudioFrame_methods },
    { Py_tp_getset, AudioFrame_getset },
    { 0, nullptr },
};

static PyType_Spec AudioFrame_Type_spec =
{
    "AudioFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::AudioFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    AudioFrame_Type_slots
};

// ----- AutoRepeatModeChangeRequestedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>::python_type;

static PyObject* AutoRepeatModeChangeRequestedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "AutoRepeatModeChangeRequestedEventArgs is not activatable");
    return nullptr;
}

static void AutoRepeatModeChangeRequestedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode(py::winrt_wrapper<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RequestedAutoRepeatMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AutoRepeatModeChangeRequestedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef AutoRepeatModeChangeRequestedEventArgs_methods[] = {
    { "_from", (PyCFunction)__AutoRepeatModeChangeRequestedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef AutoRepeatModeChangeRequestedEventArgs_getset[] = {
    { const_cast<char*>("RequestedAutoRepeatMode"), (getter)AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot AutoRepeatModeChangeRequestedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, AutoRepeatModeChangeRequestedEventArgs_dealloc },
    { Py_tp_new, AutoRepeatModeChangeRequestedEventArgs_new },
    { Py_tp_methods, AutoRepeatModeChangeRequestedEventArgs_methods },
    { Py_tp_getset, AutoRepeatModeChangeRequestedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec AutoRepeatModeChangeRequestedEventArgs_Type_spec =
{
    "AutoRepeatModeChangeRequestedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    AutoRepeatModeChangeRequestedEventArgs_Type_slots
};

// ----- ImageDisplayProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::ImageDisplayProperties>::python_type;

static PyObject* ImageDisplayProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageDisplayProperties is not activatable");
    return nullptr;
}

static void ImageDisplayProperties_dealloc(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageDisplayProperties_get_Title(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Title();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int ImageDisplayProperties_put_Title(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Title(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* ImageDisplayProperties_get_Subtitle(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Subtitle();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int ImageDisplayProperties_put_Subtitle(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Subtitle(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __ImageDisplayProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::ImageDisplayProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ImageDisplayProperties_methods[] = {
    { "_from", (PyCFunction)__ImageDisplayProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ImageDisplayProperties_getset[] = {
    { const_cast<char*>("Title"), (getter)ImageDisplayProperties_get_Title, (setter)ImageDisplayProperties_put_Title, nullptr, nullptr },
    { const_cast<char*>("Subtitle"), (getter)ImageDisplayProperties_get_Subtitle, (setter)ImageDisplayProperties_put_Subtitle, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ImageDisplayProperties_Type_slots[] = 
{
    { Py_tp_dealloc, ImageDisplayProperties_dealloc },
    { Py_tp_new, ImageDisplayProperties_new },
    { Py_tp_methods, ImageDisplayProperties_methods },
    { Py_tp_getset, ImageDisplayProperties_getset },
    { 0, nullptr },
};

static PyType_Spec ImageDisplayProperties_Type_spec =
{
    "ImageDisplayProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::ImageDisplayProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageDisplayProperties_Type_slots
};

// ----- MediaExtensionManager class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaExtensionManager>::python_type;

static PyObject* MediaExtensionManager_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Media::MediaExtensionManager instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void MediaExtensionManager_dealloc(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MediaExtensionManager_RegisterAudioDecoder(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            
            self->obj.RegisterAudioDecoder(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);
            
            self->obj.RegisterAudioDecoder(param0, param1, param2, param3);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterAudioEncoder(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            
            self->obj.RegisterAudioEncoder(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);
            
            self->obj.RegisterAudioEncoder(param0, param1, param2, param3);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterByteStreamHandler(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::hstring>(args, 2);
            
            self->obj.RegisterByteStreamHandler(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::hstring>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);
            
            self->obj.RegisterByteStreamHandler(param0, param1, param2, param3);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterMediaExtensionForAppService(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 1);
            
            self->obj.RegisterMediaExtensionForAppService(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterSchemeHandler(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            self->obj.RegisterSchemeHandler(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);
            
            self->obj.RegisterSchemeHandler(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterVideoDecoder(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            
            self->obj.RegisterVideoDecoder(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);
            
            self->obj.RegisterVideoDecoder(param0, param1, param2, param3);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaExtensionManager_RegisterVideoEncoder(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            
            self->obj.RegisterVideoEncoder(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            auto param2 = py::convert_to<winrt::guid>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);
            
            self->obj.RegisterVideoEncoder(param0, param1, param2, param3);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __MediaExtensionManager_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::MediaExtensionManager>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MediaExtensionManager_methods[] = {
    { "RegisterAudioDecoder", (PyCFunction)MediaExtensionManager_RegisterAudioDecoder, METH_VARARGS, nullptr },
    { "RegisterAudioEncoder", (PyCFunction)MediaExtensionManager_RegisterAudioEncoder, METH_VARARGS, nullptr },
    { "RegisterByteStreamHandler", (PyCFunction)MediaExtensionManager_RegisterByteStreamHandler, METH_VARARGS, nullptr },
    { "RegisterMediaExtensionForAppService", (PyCFunction)MediaExtensionManager_RegisterMediaExtensionForAppService, METH_VARARGS, nullptr },
    { "RegisterSchemeHandler", (PyCFunction)MediaExtensionManager_RegisterSchemeHandler, METH_VARARGS, nullptr },
    { "RegisterVideoDecoder", (PyCFunction)MediaExtensionManager_RegisterVideoDecoder, METH_VARARGS, nullptr },
    { "RegisterVideoEncoder", (PyCFunction)MediaExtensionManager_RegisterVideoEncoder, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__MediaExtensionManager_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MediaExtensionManager_getset[] = {
    { nullptr }
};

static PyType_Slot MediaExtensionManager_Type_slots[] = 
{
    { Py_tp_dealloc, MediaExtensionManager_dealloc },
    { Py_tp_new, MediaExtensionManager_new },
    { Py_tp_methods, MediaExtensionManager_methods },
    { Py_tp_getset, MediaExtensionManager_getset },
    { 0, nullptr },
};

static PyType_Spec MediaExtensionManager_Type_spec =
{
    "MediaExtensionManager",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::MediaExtensionManager>),
    0,
    Py_TPFLAGS_DEFAULT,
    MediaExtensionManager_Type_slots
};

// ----- MediaMarkerTypes class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaMarkerTypes>::python_type;

static PyObject* MediaMarkerTypes_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MediaMarkerTypes is not activatable");
    return nullptr;
}

static PyObject* MediaMarkerTypes_get_Bookmark(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Media::MediaMarkerTypes::Bookmark();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MediaMarkerTypes_methods[] = {
    { "get_Bookmark", (PyCFunction)MediaMarkerTypes_get_Bookmark, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MediaMarkerTypes_getset[] = {
    { nullptr }
};

static PyType_Slot MediaMarkerTypes_Type_slots[] = 
{
    { Py_tp_new, MediaMarkerTypes_new },
    { Py_tp_methods, MediaMarkerTypes_methods },
    { Py_tp_getset, MediaMarkerTypes_getset },
    { 0, nullptr },
};

static PyType_Spec MediaMarkerTypes_Type_spec =
{
    "MediaMarkerTypes",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    MediaMarkerTypes_Type_slots
};

// ----- MediaProcessingTriggerDetails class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProcessingTriggerDetails>::python_type;

static PyObject* MediaProcessingTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MediaProcessingTriggerDetails is not activatable");
    return nullptr;
}

static void MediaProcessingTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Media::MediaProcessingTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MediaProcessingTriggerDetails_get_Arguments(py::winrt_wrapper<winrt::Windows::Media::MediaProcessingTriggerDetails>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Arguments();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __MediaProcessingTriggerDetails_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::MediaProcessingTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MediaProcessingTriggerDetails_methods[] = {
    { "_from", (PyCFunction)__MediaProcessingTriggerDetails_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MediaProcessingTriggerDetails_getset[] = {
    { const_cast<char*>("Arguments"), (getter)MediaProcessingTriggerDetails_get_Arguments, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MediaProcessingTriggerDetails_Type_slots[] = 
{
    { Py_tp_dealloc, MediaProcessingTriggerDetails_dealloc },
    { Py_tp_new, MediaProcessingTriggerDetails_new },
    { Py_tp_methods, MediaProcessingTriggerDetails_methods },
    { Py_tp_getset, MediaProcessingTriggerDetails_getset },
    { 0, nullptr },
};

static PyType_Spec MediaProcessingTriggerDetails_Type_spec =
{
    "MediaProcessingTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::MediaProcessingTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    MediaProcessingTriggerDetails_Type_slots
};

// ----- MediaTimelineController class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineController>::python_type;

static PyObject* MediaTimelineController_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Media::MediaTimelineController instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void MediaTimelineController_dealloc(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MediaTimelineController_Pause(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Pause();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaTimelineController_Resume(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Resume();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaTimelineController_Start(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Start();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* MediaTimelineController_get_Position(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimelineController_put_Position(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.Position(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MediaTimelineController_get_ClockRate(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ClockRate();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimelineController_put_ClockRate(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.ClockRate(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MediaTimelineController_get_State(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.State();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_get_IsLoopingEnabled(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsLoopingEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimelineController_put_IsLoopingEnabled(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsLoopingEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MediaTimelineController_get_Duration(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimelineController_put_Duration(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.Duration(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MediaTimelineController_add_PositionChanged(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.PositionChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_remove_PositionChanged(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PositionChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_add_StateChanged(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.StateChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_remove_StateChanged(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.StateChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_add_Ended(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.Ended(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_remove_Ended(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.Ended(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_add_Failed(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>>(arg);
        
        auto return_value = self->obj.Failed(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimelineController_remove_Failed(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.Failed(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __MediaTimelineController_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::MediaTimelineController>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MediaTimelineController_methods[] = {
    { "Pause", (PyCFunction)MediaTimelineController_Pause, METH_VARARGS, nullptr },
    { "Resume", (PyCFunction)MediaTimelineController_Resume, METH_VARARGS, nullptr },
    { "Start", (PyCFunction)MediaTimelineController_Start, METH_VARARGS, nullptr },
    { "add_PositionChanged", (PyCFunction)MediaTimelineController_add_PositionChanged, METH_O, nullptr },
    { "remove_PositionChanged", (PyCFunction)MediaTimelineController_remove_PositionChanged, METH_O, nullptr },
    { "add_StateChanged", (PyCFunction)MediaTimelineController_add_StateChanged, METH_O, nullptr },
    { "remove_StateChanged", (PyCFunction)MediaTimelineController_remove_StateChanged, METH_O, nullptr },
    { "add_Ended", (PyCFunction)MediaTimelineController_add_Ended, METH_O, nullptr },
    { "remove_Ended", (PyCFunction)MediaTimelineController_remove_Ended, METH_O, nullptr },
    { "add_Failed", (PyCFunction)MediaTimelineController_add_Failed, METH_O, nullptr },
    { "remove_Failed", (PyCFunction)MediaTimelineController_remove_Failed, METH_O, nullptr },
    { "_from", (PyCFunction)__MediaTimelineController_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MediaTimelineController_getset[] = {
    { const_cast<char*>("Position"), (getter)MediaTimelineController_get_Position, (setter)MediaTimelineController_put_Position, nullptr, nullptr },
    { const_cast<char*>("ClockRate"), (getter)MediaTimelineController_get_ClockRate, (setter)MediaTimelineController_put_ClockRate, nullptr, nullptr },
    { const_cast<char*>("State"), (getter)MediaTimelineController_get_State, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsLoopingEnabled"), (getter)MediaTimelineController_get_IsLoopingEnabled, (setter)MediaTimelineController_put_IsLoopingEnabled, nullptr, nullptr },
    { const_cast<char*>("Duration"), (getter)MediaTimelineController_get_Duration, (setter)MediaTimelineController_put_Duration, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MediaTimelineController_Type_slots[] = 
{
    { Py_tp_dealloc, MediaTimelineController_dealloc },
    { Py_tp_new, MediaTimelineController_new },
    { Py_tp_methods, MediaTimelineController_methods },
    { Py_tp_getset, MediaTimelineController_getset },
    { 0, nullptr },
};

static PyType_Spec MediaTimelineController_Type_spec =
{
    "MediaTimelineController",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineController>),
    0,
    Py_TPFLAGS_DEFAULT,
    MediaTimelineController_Type_slots
};

// ----- MediaTimelineControllerFailedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>::python_type;

static PyObject* MediaTimelineControllerFailedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MediaTimelineControllerFailedEventArgs is not activatable");
    return nullptr;
}

static void MediaTimelineControllerFailedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MediaTimelineControllerFailedEventArgs_get_ExtendedError(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ExtendedError();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __MediaTimelineControllerFailedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MediaTimelineControllerFailedEventArgs_methods[] = {
    { "_from", (PyCFunction)__MediaTimelineControllerFailedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MediaTimelineControllerFailedEventArgs_getset[] = {
    { const_cast<char*>("ExtendedError"), (getter)MediaTimelineControllerFailedEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MediaTimelineControllerFailedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, MediaTimelineControllerFailedEventArgs_dealloc },
    { Py_tp_new, MediaTimelineControllerFailedEventArgs_new },
    { Py_tp_methods, MediaTimelineControllerFailedEventArgs_methods },
    { Py_tp_getset, MediaTimelineControllerFailedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec MediaTimelineControllerFailedEventArgs_Type_spec =
{
    "MediaTimelineControllerFailedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    MediaTimelineControllerFailedEventArgs_Type_slots
};

// ----- MusicDisplayProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MusicDisplayProperties>::python_type;

static PyObject* MusicDisplayProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MusicDisplayProperties is not activatable");
    return nullptr;
}

static void MusicDisplayProperties_dealloc(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MusicDisplayProperties_get_Title(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Title();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_Title(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Title(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MusicDisplayProperties_get_Artist(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Artist();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_Artist(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Artist(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MusicDisplayProperties_get_AlbumArtist(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AlbumArtist();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_AlbumArtist(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.AlbumArtist(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MusicDisplayProperties_get_TrackNumber(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TrackNumber();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_TrackNumber(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.TrackNumber(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MusicDisplayProperties_get_AlbumTitle(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AlbumTitle();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_AlbumTitle(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.AlbumTitle(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MusicDisplayProperties_get_Genres(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Genres();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MusicDisplayProperties_get_AlbumTrackCount(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AlbumTrackCount();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MusicDisplayProperties_put_AlbumTrackCount(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.AlbumTrackCount(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __MusicDisplayProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::MusicDisplayProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MusicDisplayProperties_methods[] = {
    { "_from", (PyCFunction)__MusicDisplayProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MusicDisplayProperties_getset[] = {
    { const_cast<char*>("Title"), (getter)MusicDisplayProperties_get_Title, (setter)MusicDisplayProperties_put_Title, nullptr, nullptr },
    { const_cast<char*>("Artist"), (getter)MusicDisplayProperties_get_Artist, (setter)MusicDisplayProperties_put_Artist, nullptr, nullptr },
    { const_cast<char*>("AlbumArtist"), (getter)MusicDisplayProperties_get_AlbumArtist, (setter)MusicDisplayProperties_put_AlbumArtist, nullptr, nullptr },
    { const_cast<char*>("TrackNumber"), (getter)MusicDisplayProperties_get_TrackNumber, (setter)MusicDisplayProperties_put_TrackNumber, nullptr, nullptr },
    { const_cast<char*>("AlbumTitle"), (getter)MusicDisplayProperties_get_AlbumTitle, (setter)MusicDisplayProperties_put_AlbumTitle, nullptr, nullptr },
    { const_cast<char*>("Genres"), (getter)MusicDisplayProperties_get_Genres, nullptr, nullptr, nullptr },
    { const_cast<char*>("AlbumTrackCount"), (getter)MusicDisplayProperties_get_AlbumTrackCount, (setter)MusicDisplayProperties_put_AlbumTrackCount, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MusicDisplayProperties_Type_slots[] = 
{
    { Py_tp_dealloc, MusicDisplayProperties_dealloc },
    { Py_tp_new, MusicDisplayProperties_new },
    { Py_tp_methods, MusicDisplayProperties_methods },
    { Py_tp_getset, MusicDisplayProperties_getset },
    { 0, nullptr },
};

static PyType_Spec MusicDisplayProperties_Type_spec =
{
    "MusicDisplayProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::MusicDisplayProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    MusicDisplayProperties_Type_slots
};

// ----- PlaybackPositionChangeRequestedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>::python_type;

static PyObject* PlaybackPositionChangeRequestedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PlaybackPositionChangeRequestedEventArgs is not activatable");
    return nullptr;
}

static void PlaybackPositionChangeRequestedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition(py::winrt_wrapper<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RequestedPlaybackPosition();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __PlaybackPositionChangeRequestedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef PlaybackPositionChangeRequestedEventArgs_methods[] = {
    { "_from", (PyCFunction)__PlaybackPositionChangeRequestedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef PlaybackPositionChangeRequestedEventArgs_getset[] = {
    { const_cast<char*>("RequestedPlaybackPosition"), (getter)PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot PlaybackPositionChangeRequestedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, PlaybackPositionChangeRequestedEventArgs_dealloc },
    { Py_tp_new, PlaybackPositionChangeRequestedEventArgs_new },
    { Py_tp_methods, PlaybackPositionChangeRequestedEventArgs_methods },
    { Py_tp_getset, PlaybackPositionChangeRequestedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec PlaybackPositionChangeRequestedEventArgs_Type_spec =
{
    "PlaybackPositionChangeRequestedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    PlaybackPositionChangeRequestedEventArgs_Type_slots
};

// ----- PlaybackRateChangeRequestedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>::python_type;

static PyObject* PlaybackRateChangeRequestedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PlaybackRateChangeRequestedEventArgs is not activatable");
    return nullptr;
}

static void PlaybackRateChangeRequestedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate(py::winrt_wrapper<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RequestedPlaybackRate();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __PlaybackRateChangeRequestedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef PlaybackRateChangeRequestedEventArgs_methods[] = {
    { "_from", (PyCFunction)__PlaybackRateChangeRequestedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef PlaybackRateChangeRequestedEventArgs_getset[] = {
    { const_cast<char*>("RequestedPlaybackRate"), (getter)PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot PlaybackRateChangeRequestedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, PlaybackRateChangeRequestedEventArgs_dealloc },
    { Py_tp_new, PlaybackRateChangeRequestedEventArgs_new },
    { Py_tp_methods, PlaybackRateChangeRequestedEventArgs_methods },
    { Py_tp_getset, PlaybackRateChangeRequestedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec PlaybackRateChangeRequestedEventArgs_Type_spec =
{
    "PlaybackRateChangeRequestedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    PlaybackRateChangeRequestedEventArgs_Type_slots
};

// ----- ShuffleEnabledChangeRequestedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>::python_type;

static PyObject* ShuffleEnabledChangeRequestedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ShuffleEnabledChangeRequestedEventArgs is not activatable");
    return nullptr;
}

static void ShuffleEnabledChangeRequestedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled(py::winrt_wrapper<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RequestedShuffleEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ShuffleEnabledChangeRequestedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ShuffleEnabledChangeRequestedEventArgs_methods[] = {
    { "_from", (PyCFunction)__ShuffleEnabledChangeRequestedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ShuffleEnabledChangeRequestedEventArgs_getset[] = {
    { const_cast<char*>("RequestedShuffleEnabled"), (getter)ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ShuffleEnabledChangeRequestedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, ShuffleEnabledChangeRequestedEventArgs_dealloc },
    { Py_tp_new, ShuffleEnabledChangeRequestedEventArgs_new },
    { Py_tp_methods, ShuffleEnabledChangeRequestedEventArgs_methods },
    { Py_tp_getset, ShuffleEnabledChangeRequestedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec ShuffleEnabledChangeRequestedEventArgs_Type_spec =
{
    "ShuffleEnabledChangeRequestedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    ShuffleEnabledChangeRequestedEventArgs_Type_slots
};

// ----- SystemMediaTransportControls class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControls>::python_type;

static PyObject* SystemMediaTransportControls_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaTransportControls is not activatable");
    return nullptr;
}

static void SystemMediaTransportControls_dealloc(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaTransportControls_GetForCurrentView(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Media::SystemMediaTransportControls::GetForCurrentView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemMediaTransportControls_UpdateTimelineProperties(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>(args, 0);
            
            self->obj.UpdateTimelineProperties(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemMediaTransportControls_get_IsPlayEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsPlayEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsPlayEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsPlayEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsPauseEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsPauseEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsPauseEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsPauseEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsNextEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsNextEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsNextEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsNextEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsPreviousEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsPreviousEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsPreviousEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsPreviousEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsChannelDownEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsChannelDownEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsChannelDownEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsChannelDownEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsFastForwardEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsFastForwardEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsFastForwardEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsFastForwardEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsChannelUpEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsChannelUpEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsChannelUpEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsChannelUpEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_PlaybackStatus(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PlaybackStatus();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_PlaybackStatus(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackStatus>(arg);
        
        self->obj.PlaybackStatus(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsStopEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsStopEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsStopEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsStopEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsRewindEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRewindEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsRewindEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsRewindEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_IsRecordEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRecordEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_IsRecordEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsRecordEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_DisplayUpdater(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayUpdater();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_get_SoundLevel(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SoundLevel();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_get_ShuffleEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ShuffleEnabled();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_ShuffleEnabled(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.ShuffleEnabled(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_PlaybackRate(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PlaybackRate();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_PlaybackRate(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.PlaybackRate(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_get_AutoRepeatMode(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AutoRepeatMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControls_put_AutoRepeatMode(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>(arg);
        
        self->obj.AutoRepeatMode(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControls_add_ButtonPressed(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>>(arg);
        
        auto return_value = self->obj.ButtonPressed(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_ButtonPressed(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ButtonPressed(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_add_PropertyChanged(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>>(arg);
        
        auto return_value = self->obj.PropertyChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_PropertyChanged(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PropertyChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_add_AutoRepeatModeChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>>(arg);
        
        auto return_value = self->obj.AutoRepeatModeChangeRequested(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.AutoRepeatModeChangeRequested(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_add_PlaybackPositionChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>>(arg);
        
        auto return_value = self->obj.PlaybackPositionChangeRequested(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_PlaybackPositionChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PlaybackPositionChangeRequested(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_add_PlaybackRateChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>>(arg);
        
        auto return_value = self->obj.PlaybackRateChangeRequested(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_PlaybackRateChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PlaybackRateChangeRequested(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_add_ShuffleEnabledChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>>(arg);
        
        auto return_value = self->obj.ShuffleEnabledChangeRequested(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ShuffleEnabledChangeRequested(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMediaTransportControls_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::SystemMediaTransportControls>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaTransportControls_methods[] = {
    { "GetForCurrentView", (PyCFunction)SystemMediaTransportControls_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
    { "UpdateTimelineProperties", (PyCFunction)SystemMediaTransportControls_UpdateTimelineProperties, METH_VARARGS, nullptr },
    { "add_ButtonPressed", (PyCFunction)SystemMediaTransportControls_add_ButtonPressed, METH_O, nullptr },
    { "remove_ButtonPressed", (PyCFunction)SystemMediaTransportControls_remove_ButtonPressed, METH_O, nullptr },
    { "add_PropertyChanged", (PyCFunction)SystemMediaTransportControls_add_PropertyChanged, METH_O, nullptr },
    { "remove_PropertyChanged", (PyCFunction)SystemMediaTransportControls_remove_PropertyChanged, METH_O, nullptr },
    { "add_AutoRepeatModeChangeRequested", (PyCFunction)SystemMediaTransportControls_add_AutoRepeatModeChangeRequested, METH_O, nullptr },
    { "remove_AutoRepeatModeChangeRequested", (PyCFunction)SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested, METH_O, nullptr },
    { "add_PlaybackPositionChangeRequested", (PyCFunction)SystemMediaTransportControls_add_PlaybackPositionChangeRequested, METH_O, nullptr },
    { "remove_PlaybackPositionChangeRequested", (PyCFunction)SystemMediaTransportControls_remove_PlaybackPositionChangeRequested, METH_O, nullptr },
    { "add_PlaybackRateChangeRequested", (PyCFunction)SystemMediaTransportControls_add_PlaybackRateChangeRequested, METH_O, nullptr },
    { "remove_PlaybackRateChangeRequested", (PyCFunction)SystemMediaTransportControls_remove_PlaybackRateChangeRequested, METH_O, nullptr },
    { "add_ShuffleEnabledChangeRequested", (PyCFunction)SystemMediaTransportControls_add_ShuffleEnabledChangeRequested, METH_O, nullptr },
    { "remove_ShuffleEnabledChangeRequested", (PyCFunction)SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested, METH_O, nullptr },
    { "_from", (PyCFunction)__SystemMediaTransportControls_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaTransportControls_getset[] = {
    { const_cast<char*>("IsPlayEnabled"), (getter)SystemMediaTransportControls_get_IsPlayEnabled, (setter)SystemMediaTransportControls_put_IsPlayEnabled, nullptr, nullptr },
    { const_cast<char*>("IsPauseEnabled"), (getter)SystemMediaTransportControls_get_IsPauseEnabled, (setter)SystemMediaTransportControls_put_IsPauseEnabled, nullptr, nullptr },
    { const_cast<char*>("IsNextEnabled"), (getter)SystemMediaTransportControls_get_IsNextEnabled, (setter)SystemMediaTransportControls_put_IsNextEnabled, nullptr, nullptr },
    { const_cast<char*>("IsPreviousEnabled"), (getter)SystemMediaTransportControls_get_IsPreviousEnabled, (setter)SystemMediaTransportControls_put_IsPreviousEnabled, nullptr, nullptr },
    { const_cast<char*>("IsEnabled"), (getter)SystemMediaTransportControls_get_IsEnabled, (setter)SystemMediaTransportControls_put_IsEnabled, nullptr, nullptr },
    { const_cast<char*>("IsChannelDownEnabled"), (getter)SystemMediaTransportControls_get_IsChannelDownEnabled, (setter)SystemMediaTransportControls_put_IsChannelDownEnabled, nullptr, nullptr },
    { const_cast<char*>("IsFastForwardEnabled"), (getter)SystemMediaTransportControls_get_IsFastForwardEnabled, (setter)SystemMediaTransportControls_put_IsFastForwardEnabled, nullptr, nullptr },
    { const_cast<char*>("IsChannelUpEnabled"), (getter)SystemMediaTransportControls_get_IsChannelUpEnabled, (setter)SystemMediaTransportControls_put_IsChannelUpEnabled, nullptr, nullptr },
    { const_cast<char*>("PlaybackStatus"), (getter)SystemMediaTransportControls_get_PlaybackStatus, (setter)SystemMediaTransportControls_put_PlaybackStatus, nullptr, nullptr },
    { const_cast<char*>("IsStopEnabled"), (getter)SystemMediaTransportControls_get_IsStopEnabled, (setter)SystemMediaTransportControls_put_IsStopEnabled, nullptr, nullptr },
    { const_cast<char*>("IsRewindEnabled"), (getter)SystemMediaTransportControls_get_IsRewindEnabled, (setter)SystemMediaTransportControls_put_IsRewindEnabled, nullptr, nullptr },
    { const_cast<char*>("IsRecordEnabled"), (getter)SystemMediaTransportControls_get_IsRecordEnabled, (setter)SystemMediaTransportControls_put_IsRecordEnabled, nullptr, nullptr },
    { const_cast<char*>("DisplayUpdater"), (getter)SystemMediaTransportControls_get_DisplayUpdater, nullptr, nullptr, nullptr },
    { const_cast<char*>("SoundLevel"), (getter)SystemMediaTransportControls_get_SoundLevel, nullptr, nullptr, nullptr },
    { const_cast<char*>("ShuffleEnabled"), (getter)SystemMediaTransportControls_get_ShuffleEnabled, (setter)SystemMediaTransportControls_put_ShuffleEnabled, nullptr, nullptr },
    { const_cast<char*>("PlaybackRate"), (getter)SystemMediaTransportControls_get_PlaybackRate, (setter)SystemMediaTransportControls_put_PlaybackRate, nullptr, nullptr },
    { const_cast<char*>("AutoRepeatMode"), (getter)SystemMediaTransportControls_get_AutoRepeatMode, (setter)SystemMediaTransportControls_put_AutoRepeatMode, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaTransportControls_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaTransportControls_dealloc },
    { Py_tp_new, SystemMediaTransportControls_new },
    { Py_tp_methods, SystemMediaTransportControls_methods },
    { Py_tp_getset, SystemMediaTransportControls_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaTransportControls_Type_spec =
{
    "SystemMediaTransportControls",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControls>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaTransportControls_Type_slots
};

// ----- SystemMediaTransportControlsButtonPressedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>::python_type;

static PyObject* SystemMediaTransportControlsButtonPressedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaTransportControlsButtonPressedEventArgs is not activatable");
    return nullptr;
}

static void SystemMediaTransportControlsButtonPressedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaTransportControlsButtonPressedEventArgs_get_Button(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Button();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMediaTransportControlsButtonPressedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaTransportControlsButtonPressedEventArgs_methods[] = {
    { "_from", (PyCFunction)__SystemMediaTransportControlsButtonPressedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaTransportControlsButtonPressedEventArgs_getset[] = {
    { const_cast<char*>("Button"), (getter)SystemMediaTransportControlsButtonPressedEventArgs_get_Button, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaTransportControlsButtonPressedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaTransportControlsButtonPressedEventArgs_dealloc },
    { Py_tp_new, SystemMediaTransportControlsButtonPressedEventArgs_new },
    { Py_tp_methods, SystemMediaTransportControlsButtonPressedEventArgs_methods },
    { Py_tp_getset, SystemMediaTransportControlsButtonPressedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaTransportControlsButtonPressedEventArgs_Type_spec =
{
    "SystemMediaTransportControlsButtonPressedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaTransportControlsButtonPressedEventArgs_Type_slots
};

// ----- SystemMediaTransportControlsDisplayUpdater class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>::python_type;

static PyObject* SystemMediaTransportControlsDisplayUpdater_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaTransportControlsDisplayUpdater is not activatable");
    return nullptr;
}

static void SystemMediaTransportControlsDisplayUpdater_dealloc(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_ClearAll(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.ClearAll();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 1);
            
            auto return_value = self->obj.CopyFromFileAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_Update(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Update();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Type(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Type();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsDisplayUpdater_put_Type(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(arg);
        
        self->obj.Type(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Thumbnail(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Thumbnail();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsDisplayUpdater_put_Thumbnail(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(arg);
        
        self->obj.Thumbnail(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_AppMediaId(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AppMediaId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsDisplayUpdater_put_AppMediaId(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.AppMediaId(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_ImageProperties(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ImageProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_MusicProperties(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MusicProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaTransportControlsDisplayUpdater_get_VideoProperties(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VideoProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMediaTransportControlsDisplayUpdater_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaTransportControlsDisplayUpdater_methods[] = {
    { "ClearAll", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_ClearAll, METH_VARARGS, nullptr },
    { "CopyFromFileAsync", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync, METH_VARARGS, nullptr },
    { "Update", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_Update, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__SystemMediaTransportControlsDisplayUpdater_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaTransportControlsDisplayUpdater_getset[] = {
    { const_cast<char*>("Type"), (getter)SystemMediaTransportControlsDisplayUpdater_get_Type, (setter)SystemMediaTransportControlsDisplayUpdater_put_Type, nullptr, nullptr },
    { const_cast<char*>("Thumbnail"), (getter)SystemMediaTransportControlsDisplayUpdater_get_Thumbnail, (setter)SystemMediaTransportControlsDisplayUpdater_put_Thumbnail, nullptr, nullptr },
    { const_cast<char*>("AppMediaId"), (getter)SystemMediaTransportControlsDisplayUpdater_get_AppMediaId, (setter)SystemMediaTransportControlsDisplayUpdater_put_AppMediaId, nullptr, nullptr },
    { const_cast<char*>("ImageProperties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_ImageProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("MusicProperties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_MusicProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("VideoProperties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_VideoProperties, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaTransportControlsDisplayUpdater_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaTransportControlsDisplayUpdater_dealloc },
    { Py_tp_new, SystemMediaTransportControlsDisplayUpdater_new },
    { Py_tp_methods, SystemMediaTransportControlsDisplayUpdater_methods },
    { Py_tp_getset, SystemMediaTransportControlsDisplayUpdater_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaTransportControlsDisplayUpdater_Type_spec =
{
    "SystemMediaTransportControlsDisplayUpdater",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaTransportControlsDisplayUpdater_Type_slots
};

// ----- SystemMediaTransportControlsPropertyChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>::python_type;

static PyObject* SystemMediaTransportControlsPropertyChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaTransportControlsPropertyChangedEventArgs is not activatable");
    return nullptr;
}

static void SystemMediaTransportControlsPropertyChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaTransportControlsPropertyChangedEventArgs_get_Property(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Property();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMediaTransportControlsPropertyChangedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaTransportControlsPropertyChangedEventArgs_methods[] = {
    { "_from", (PyCFunction)__SystemMediaTransportControlsPropertyChangedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaTransportControlsPropertyChangedEventArgs_getset[] = {
    { const_cast<char*>("Property"), (getter)SystemMediaTransportControlsPropertyChangedEventArgs_get_Property, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaTransportControlsPropertyChangedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaTransportControlsPropertyChangedEventArgs_dealloc },
    { Py_tp_new, SystemMediaTransportControlsPropertyChangedEventArgs_new },
    { Py_tp_methods, SystemMediaTransportControlsPropertyChangedEventArgs_methods },
    { Py_tp_getset, SystemMediaTransportControlsPropertyChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaTransportControlsPropertyChangedEventArgs_Type_spec =
{
    "SystemMediaTransportControlsPropertyChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaTransportControlsPropertyChangedEventArgs_Type_slots
};

// ----- SystemMediaTransportControlsTimelineProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>::python_type;

static PyObject* SystemMediaTransportControlsTimelineProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void SystemMediaTransportControlsTimelineProperties_dealloc(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaTransportControlsTimelineProperties_get_StartTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StartTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsTimelineProperties_put_StartTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.StartTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsTimelineProperties_get_Position(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsTimelineProperties_put_Position(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.Position(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsTimelineProperties_get_MinSeekTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MinSeekTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsTimelineProperties_put_MinSeekTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.MinSeekTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MaxSeekTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.MaxSeekTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SystemMediaTransportControlsTimelineProperties_get_EndTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.EndTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SystemMediaTransportControlsTimelineProperties_put_EndTime(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
        
        self->obj.EndTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __SystemMediaTransportControlsTimelineProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaTransportControlsTimelineProperties_methods[] = {
    { "_from", (PyCFunction)__SystemMediaTransportControlsTimelineProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaTransportControlsTimelineProperties_getset[] = {
    { const_cast<char*>("StartTime"), (getter)SystemMediaTransportControlsTimelineProperties_get_StartTime, (setter)SystemMediaTransportControlsTimelineProperties_put_StartTime, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)SystemMediaTransportControlsTimelineProperties_get_Position, (setter)SystemMediaTransportControlsTimelineProperties_put_Position, nullptr, nullptr },
    { const_cast<char*>("MinSeekTime"), (getter)SystemMediaTransportControlsTimelineProperties_get_MinSeekTime, (setter)SystemMediaTransportControlsTimelineProperties_put_MinSeekTime, nullptr, nullptr },
    { const_cast<char*>("MaxSeekTime"), (getter)SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime, (setter)SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime, nullptr, nullptr },
    { const_cast<char*>("EndTime"), (getter)SystemMediaTransportControlsTimelineProperties_get_EndTime, (setter)SystemMediaTransportControlsTimelineProperties_put_EndTime, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaTransportControlsTimelineProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaTransportControlsTimelineProperties_dealloc },
    { Py_tp_new, SystemMediaTransportControlsTimelineProperties_new },
    { Py_tp_methods, SystemMediaTransportControlsTimelineProperties_methods },
    { Py_tp_getset, SystemMediaTransportControlsTimelineProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaTransportControlsTimelineProperties_Type_spec =
{
    "SystemMediaTransportControlsTimelineProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaTransportControlsTimelineProperties_Type_slots
};

// ----- VideoDisplayProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoDisplayProperties>::python_type;

static PyObject* VideoDisplayProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "VideoDisplayProperties is not activatable");
    return nullptr;
}

static void VideoDisplayProperties_dealloc(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VideoDisplayProperties_get_Title(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Title();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoDisplayProperties_put_Title(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Title(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoDisplayProperties_get_Subtitle(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Subtitle();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoDisplayProperties_put_Subtitle(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Subtitle(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoDisplayProperties_get_Genres(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Genres();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __VideoDisplayProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::VideoDisplayProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef VideoDisplayProperties_methods[] = {
    { "_from", (PyCFunction)__VideoDisplayProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef VideoDisplayProperties_getset[] = {
    { const_cast<char*>("Title"), (getter)VideoDisplayProperties_get_Title, (setter)VideoDisplayProperties_put_Title, nullptr, nullptr },
    { const_cast<char*>("Subtitle"), (getter)VideoDisplayProperties_get_Subtitle, (setter)VideoDisplayProperties_put_Subtitle, nullptr, nullptr },
    { const_cast<char*>("Genres"), (getter)VideoDisplayProperties_get_Genres, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot VideoDisplayProperties_Type_slots[] = 
{
    { Py_tp_dealloc, VideoDisplayProperties_dealloc },
    { Py_tp_new, VideoDisplayProperties_new },
    { Py_tp_methods, VideoDisplayProperties_methods },
    { Py_tp_getset, VideoDisplayProperties_getset },
    { 0, nullptr },
};

static PyType_Spec VideoDisplayProperties_Type_spec =
{
    "VideoDisplayProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::VideoDisplayProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    VideoDisplayProperties_Type_slots
};

// ----- VideoEffects class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoEffects>::python_type;

static PyObject* VideoEffects_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "VideoEffects is not activatable");
    return nullptr;
}

static PyObject* VideoEffects_get_VideoStabilization(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Media::VideoEffects::VideoStabilization();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef VideoEffects_methods[] = {
    { "get_VideoStabilization", (PyCFunction)VideoEffects_get_VideoStabilization, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef VideoEffects_getset[] = {
    { nullptr }
};

static PyType_Slot VideoEffects_Type_slots[] = 
{
    { Py_tp_new, VideoEffects_new },
    { Py_tp_methods, VideoEffects_methods },
    { Py_tp_getset, VideoEffects_getset },
    { 0, nullptr },
};

static PyType_Spec VideoEffects_Type_spec =
{
    "VideoEffects",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    VideoEffects_Type_slots
};

// ----- VideoFrame class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoFrame>::python_type;

static PyObject* VideoFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            
            winrt::Windows::Media::VideoFrame instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);
            
            winrt::Windows::Media::VideoFrame instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void VideoFrame_dealloc(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VideoFrame_Close(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* VideoFrame_CopyToAsync(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);
            
            auto return_value = self->obj.CopyToAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 2);
            
            auto return_value = self->obj.CopyToAsync(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* VideoFrame_CreateAsDirect3D11SurfaceBacked(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            
            auto return_value = winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 3);
            
            auto return_value = winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2, param3);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* VideoFrame_CreateWithDirect3D11Surface(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
            
            auto return_value = winrt::Windows::Media::VideoFrame::CreateWithDirect3D11Surface(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* VideoFrame_CreateWithSoftwareBitmap(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            
            auto return_value = winrt::Windows::Media::VideoFrame::CreateWithSoftwareBitmap(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* VideoFrame_get_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemRelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoFrame_put_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.SystemRelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoFrame_get_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoFrame_put_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.RelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoFrame_get_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsDiscontinuous();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoFrame_put_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsDiscontinuous(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoFrame_get_Duration(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int VideoFrame_put_Duration(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.Duration(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* VideoFrame_get_ExtendedProperties(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ExtendedProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VideoFrame_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsReadOnly();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VideoFrame_get_Type(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Type();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VideoFrame_get_Direct3DSurface(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Direct3DSurface();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VideoFrame_get_SoftwareBitmap(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SoftwareBitmap();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __VideoFrame_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::VideoFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __VideoFrame_enter(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __VideoFrame_exit(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef VideoFrame_methods[] = {
    { "Close", (PyCFunction)VideoFrame_Close, METH_VARARGS, nullptr },
    { "CopyToAsync", (PyCFunction)VideoFrame_CopyToAsync, METH_VARARGS, nullptr },
    { "CreateAsDirect3D11SurfaceBacked", (PyCFunction)VideoFrame_CreateAsDirect3D11SurfaceBacked, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateWithDirect3D11Surface", (PyCFunction)VideoFrame_CreateWithDirect3D11Surface, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateWithSoftwareBitmap", (PyCFunction)VideoFrame_CreateWithSoftwareBitmap, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__VideoFrame_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__VideoFrame_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__VideoFrame_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef VideoFrame_getset[] = {
    { const_cast<char*>("SystemRelativeTime"), (getter)VideoFrame_get_SystemRelativeTime, (setter)VideoFrame_put_SystemRelativeTime, nullptr, nullptr },
    { const_cast<char*>("RelativeTime"), (getter)VideoFrame_get_RelativeTime, (setter)VideoFrame_put_RelativeTime, nullptr, nullptr },
    { const_cast<char*>("IsDiscontinuous"), (getter)VideoFrame_get_IsDiscontinuous, (setter)VideoFrame_put_IsDiscontinuous, nullptr, nullptr },
    { const_cast<char*>("Duration"), (getter)VideoFrame_get_Duration, (setter)VideoFrame_put_Duration, nullptr, nullptr },
    { const_cast<char*>("ExtendedProperties"), (getter)VideoFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsReadOnly"), (getter)VideoFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
    { const_cast<char*>("Type"), (getter)VideoFrame_get_Type, nullptr, nullptr, nullptr },
    { const_cast<char*>("Direct3DSurface"), (getter)VideoFrame_get_Direct3DSurface, nullptr, nullptr, nullptr },
    { const_cast<char*>("SoftwareBitmap"), (getter)VideoFrame_get_SoftwareBitmap, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot VideoFrame_Type_slots[] = 
{
    { Py_tp_dealloc, VideoFrame_dealloc },
    { Py_tp_new, VideoFrame_new },
    { Py_tp_methods, VideoFrame_methods },
    { Py_tp_getset, VideoFrame_getset },
    { 0, nullptr },
};

static PyType_Spec VideoFrame_Type_spec =
{
    "VideoFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::VideoFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    VideoFrame_Type_slots
};

// ----- IMediaExtension interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaExtension>::python_type;

PyObject* IMediaExtension_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMediaExtension interface is not activatable");
    return nullptr;
}

static void IMediaExtension_dealloc(py::winrt_wrapper<winrt::Windows::Media::IMediaExtension>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMediaExtension_SetProperties(py::winrt_wrapper<winrt::Windows::Media::IMediaExtension>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);
            
            self->obj.SetProperties(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IMediaExtension_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::IMediaExtension>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IMediaExtension_methods[] = {
    { "SetProperties", (PyCFunction)IMediaExtension_SetProperties, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IMediaExtension_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IMediaExtension_getset[] = {
    { nullptr }
};

static PyType_Slot IMediaExtension_Type_slots[] = 
{
    { Py_tp_dealloc, IMediaExtension_dealloc },
    { Py_tp_new, IMediaExtension_new },
    { Py_tp_methods, IMediaExtension_methods },
    { Py_tp_getset, IMediaExtension_getset },
    { 0, nullptr },
};

static PyType_Spec IMediaExtension_Type_spec =
{
    "IMediaExtension",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::IMediaExtension>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMediaExtension_Type_slots
};

// ----- IMediaFrame interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaFrame>::python_type;

PyObject* IMediaFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMediaFrame interface is not activatable");
    return nullptr;
}

static void IMediaFrame_dealloc(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMediaFrame_Close(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IMediaFrame_get_Duration(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IMediaFrame_put_Duration(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.Duration(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IMediaFrame_get_ExtendedProperties(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ExtendedProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMediaFrame_get_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsDiscontinuous();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IMediaFrame_put_IsDiscontinuous(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsDiscontinuous(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IMediaFrame_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsReadOnly();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMediaFrame_get_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IMediaFrame_put_RelativeTime(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.RelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IMediaFrame_get_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemRelativeTime();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IMediaFrame_put_SystemRelativeTime(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);
        
        self->obj.SystemRelativeTime(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IMediaFrame_get_Type(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Type();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IMediaFrame_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::IMediaFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IMediaFrame_enter(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __IMediaFrame_exit(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IMediaFrame_methods[] = {
    { "Close", (PyCFunction)IMediaFrame_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IMediaFrame_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__IMediaFrame_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__IMediaFrame_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef IMediaFrame_getset[] = {
    { const_cast<char*>("Duration"), (getter)IMediaFrame_get_Duration, (setter)IMediaFrame_put_Duration, nullptr, nullptr },
    { const_cast<char*>("ExtendedProperties"), (getter)IMediaFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsDiscontinuous"), (getter)IMediaFrame_get_IsDiscontinuous, (setter)IMediaFrame_put_IsDiscontinuous, nullptr, nullptr },
    { const_cast<char*>("IsReadOnly"), (getter)IMediaFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
    { const_cast<char*>("RelativeTime"), (getter)IMediaFrame_get_RelativeTime, (setter)IMediaFrame_put_RelativeTime, nullptr, nullptr },
    { const_cast<char*>("SystemRelativeTime"), (getter)IMediaFrame_get_SystemRelativeTime, (setter)IMediaFrame_put_SystemRelativeTime, nullptr, nullptr },
    { const_cast<char*>("Type"), (getter)IMediaFrame_get_Type, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IMediaFrame_Type_slots[] = 
{
    { Py_tp_dealloc, IMediaFrame_dealloc },
    { Py_tp_new, IMediaFrame_new },
    { Py_tp_methods, IMediaFrame_methods },
    { Py_tp_getset, IMediaFrame_getset },
    { 0, nullptr },
};

static PyType_Spec IMediaFrame_Type_spec =
{
    "IMediaFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::IMediaFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMediaFrame_Type_slots
};

// ----- IMediaMarker interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarker>::python_type;

PyObject* IMediaMarker_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMediaMarker interface is not activatable");
    return nullptr;
}

static void IMediaMarker_dealloc(py::winrt_wrapper<winrt::Windows::Media::IMediaMarker>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMediaMarker_get_MediaMarkerType(py::winrt_wrapper<winrt::Windows::Media::IMediaMarker>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MediaMarkerType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMediaMarker_get_Text(py::winrt_wrapper<winrt::Windows::Media::IMediaMarker>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Text();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMediaMarker_get_Time(py::winrt_wrapper<winrt::Windows::Media::IMediaMarker>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Time();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IMediaMarker_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::IMediaMarker>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IMediaMarker_methods[] = {
    { "_from", (PyCFunction)__IMediaMarker_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IMediaMarker_getset[] = {
    { const_cast<char*>("MediaMarkerType"), (getter)IMediaMarker_get_MediaMarkerType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Text"), (getter)IMediaMarker_get_Text, nullptr, nullptr, nullptr },
    { const_cast<char*>("Time"), (getter)IMediaMarker_get_Time, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IMediaMarker_Type_slots[] = 
{
    { Py_tp_dealloc, IMediaMarker_dealloc },
    { Py_tp_new, IMediaMarker_new },
    { Py_tp_methods, IMediaMarker_methods },
    { Py_tp_getset, IMediaMarker_getset },
    { 0, nullptr },
};

static PyType_Spec IMediaMarker_Type_spec =
{
    "IMediaMarker",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::IMediaMarker>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMediaMarker_Type_slots
};

// ----- IMediaMarkers interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarkers>::python_type;

PyObject* IMediaMarkers_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMediaMarkers interface is not activatable");
    return nullptr;
}

static void IMediaMarkers_dealloc(py::winrt_wrapper<winrt::Windows::Media::IMediaMarkers>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMediaMarkers_get_Markers(py::winrt_wrapper<winrt::Windows::Media::IMediaMarkers>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Markers();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IMediaMarkers_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Media::IMediaMarkers>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IMediaMarkers_methods[] = {
    { "_from", (PyCFunction)__IMediaMarkers_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IMediaMarkers_getset[] = {
    { const_cast<char*>("Markers"), (getter)IMediaMarkers_get_Markers, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IMediaMarkers_Type_slots[] = 
{
    { Py_tp_dealloc, IMediaMarkers_dealloc },
    { Py_tp_new, IMediaMarkers_new },
    { Py_tp_methods, IMediaMarkers_methods },
    { Py_tp_getset, IMediaMarkers_getset },
    { 0, nullptr },
};

static PyType_Spec IMediaMarkers_Type_spec =
{
    "IMediaMarkers",
    sizeof(py::winrt_wrapper<winrt::Windows::Media::IMediaMarkers>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMediaMarkers_Type_slots
};

// ----- MediaTimeRange struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimeRange>::python_type;

PyObject* py::converter<winrt::Windows::Media::MediaTimeRange>::convert(winrt::Windows::Media::MediaTimeRange instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Media::MediaTimeRange>(instance, py::get_python_type<winrt::Windows::Media::MediaTimeRange>());
}

winrt::Windows::Media::MediaTimeRange py::converter<winrt::Windows::Media::MediaTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::MediaTimeRange>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Media::MediaTimeRange new_value{};
    
    PyObject* py_Start = PyDict_GetItemString(obj, "Start");
    if (!py_Start) { throw winrt::hresult_invalid_argument(); }
    new_value.Start = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_Start);
    
    PyObject* py_End = PyDict_GetItemString(obj, "End");
    if (!py_End) { throw winrt::hresult_invalid_argument(); }
    new_value.End = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_End);
    
    return new_value;
}

PyObject* MediaTimeRange_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Media::MediaTimeRange instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Media::MediaTimeRange>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    PyObject* _Start{};
    PyObject* _End{};
    
    static char* kwlist[] = {"Start", "End", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &_Start, &_End))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Media::MediaTimeRange instance{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MediaTimeRange_get_Start(py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Start);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimeRange_set_Start(py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* MediaTimeRange_get_End(py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.End);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int MediaTimeRange_set_End(py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef MediaTimeRange_getset[] = {
    { const_cast<char*>("Start"), (getter)MediaTimeRange_get_Start, (setter)MediaTimeRange_set_Start, nullptr, nullptr },
    { const_cast<char*>("End"), (getter)MediaTimeRange_get_End, (setter)MediaTimeRange_set_End, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MediaTimeRange_Type_slots[] = 
{
    { Py_tp_new, MediaTimeRange_new },
    { Py_tp_getset, MediaTimeRange_getset },
    { 0, nullptr },
};

static PyType_Spec MediaTimeRange_Type_spec =
{
    "MediaTimeRange",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>),
    0,
    Py_TPFLAGS_DEFAULT,
    MediaTimeRange_Type_slots
};

// ----- Windows.Media Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&AudioBuffer_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "AudioBuffer", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::AudioBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&AudioFrame_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "AudioFrame", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::AudioFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&AutoRepeatModeChangeRequestedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "AutoRepeatModeChangeRequestedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ImageDisplayProperties_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageDisplayProperties", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::ImageDisplayProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MediaExtensionManager_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaExtensionManager", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaExtensionManager>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&MediaMarkerTypes_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaMarkerTypes", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaMarkerTypes>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MediaProcessingTriggerDetails_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaProcessingTriggerDetails", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaProcessingTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MediaTimelineController_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaTimelineController", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaTimelineController>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MediaTimelineControllerFailedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaTimelineControllerFailedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MusicDisplayProperties_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MusicDisplayProperties", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MusicDisplayProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&PlaybackPositionChangeRequestedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PlaybackPositionChangeRequestedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&PlaybackRateChangeRequestedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PlaybackRateChangeRequestedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ShuffleEnabledChangeRequestedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ShuffleEnabledChangeRequestedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SystemMediaTransportControls_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaTransportControls", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::SystemMediaTransportControls>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SystemMediaTransportControlsButtonPressedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaTransportControlsButtonPressedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SystemMediaTransportControlsDisplayUpdater_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaTransportControlsDisplayUpdater", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SystemMediaTransportControlsPropertyChangedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaTransportControlsPropertyChangedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SystemMediaTransportControlsTimelineProperties_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaTransportControlsTimelineProperties", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&VideoDisplayProperties_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VideoDisplayProperties", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::VideoDisplayProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&VideoEffects_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VideoEffects", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::VideoEffects>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&VideoFrame_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VideoFrame", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::VideoFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IMediaExtension_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMediaExtension", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::IMediaExtension>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IMediaFrame_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMediaFrame", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::IMediaFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IMediaMarker_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMediaMarker", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::IMediaMarker>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IMediaMarkers_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMediaMarkers", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::IMediaMarkers>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&MediaTimeRange_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MediaTimeRange", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Media::MediaTimeRange>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Media");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Media",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Media(void)
{
    return PyModuleDef_Init(&module_def);
}
