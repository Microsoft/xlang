// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.h"

// ----- AppDataPaths class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type;

static PyObject* AppDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "AppDataPaths is not activatable");
    return nullptr;
}

static void AppDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Storage::AppDataPaths::GetDefault();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            
            auto return_value = winrt::Windows::Storage::AppDataPaths::GetForUser(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* AppDataPaths_get_Cookies(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Cookies();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_Desktop(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Desktop();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_Documents(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Documents();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_Favorites(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Favorites();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_History(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.History();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_InternetCache(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InternetCache();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_LocalAppData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalAppData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_ProgramData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ProgramData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_get_RoamingAppData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RoamingAppData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __AppDataPaths_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::AppDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef AppDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)AppDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "GetForUser", (PyCFunction)AppDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__AppDataPaths_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef AppDataPaths_getset[] = {
    { const_cast<char*>("Cookies"), (getter)AppDataPaths_get_Cookies, nullptr, nullptr, nullptr },
    { const_cast<char*>("Desktop"), (getter)AppDataPaths_get_Desktop, nullptr, nullptr, nullptr },
    { const_cast<char*>("Documents"), (getter)AppDataPaths_get_Documents, nullptr, nullptr, nullptr },
    { const_cast<char*>("Favorites"), (getter)AppDataPaths_get_Favorites, nullptr, nullptr, nullptr },
    { const_cast<char*>("History"), (getter)AppDataPaths_get_History, nullptr, nullptr, nullptr },
    { const_cast<char*>("InternetCache"), (getter)AppDataPaths_get_InternetCache, nullptr, nullptr, nullptr },
    { const_cast<char*>("LocalAppData"), (getter)AppDataPaths_get_LocalAppData, nullptr, nullptr, nullptr },
    { const_cast<char*>("ProgramData"), (getter)AppDataPaths_get_ProgramData, nullptr, nullptr, nullptr },
    { const_cast<char*>("RoamingAppData"), (getter)AppDataPaths_get_RoamingAppData, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot AppDataPaths_Type_slots[] = 
{
    { Py_tp_dealloc, AppDataPaths_dealloc },
    { Py_tp_new, AppDataPaths_new },
    { Py_tp_methods, AppDataPaths_methods },
    { Py_tp_getset, AppDataPaths_getset },
    { 0, nullptr },
};

static PyType_Spec AppDataPaths_Type_spec =
{
    "_pyrt_Windows_Storage.AppDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    AppDataPaths_Type_slots
};

// ----- ApplicationData class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type;

static PyObject* ApplicationData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationData is not activatable");
    return nullptr;
}

static void ApplicationData_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationData_ClearAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ClearAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);
            
            auto return_value = self->obj.ClearAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.ClearPublisherCacheFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            
            auto return_value = winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_GetPublisherCacheFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetPublisherCacheFolder(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_SetVersionAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);
            
            auto return_value = self->obj.SetVersionAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_SignalDataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.SignalDataChanged();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationData_get_LocalFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_LocalSettings(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalSettings();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_RoamingFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RoamingFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_RoamingSettings(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RoamingSettings();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_RoamingStorageQuota(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RoamingStorageQuota();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_TemporaryFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TemporaryFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_Version(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Version();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_LocalCacheFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalCacheFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_SharedLocalFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SharedLocalFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::ApplicationData::Current();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_add_DataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.DataChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_remove_DataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.DataChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationData_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::ApplicationData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ApplicationData_methods[] = {
    { "ClearAsync", (PyCFunction)ApplicationData_ClearAsync, METH_VARARGS, nullptr },
    { "ClearPublisherCacheFolderAsync", (PyCFunction)ApplicationData_ClearPublisherCacheFolderAsync, METH_VARARGS, nullptr },
    { "GetForUserAsync", (PyCFunction)ApplicationData_GetForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetPublisherCacheFolder", (PyCFunction)ApplicationData_GetPublisherCacheFolder, METH_VARARGS, nullptr },
    { "SetVersionAsync", (PyCFunction)ApplicationData_SetVersionAsync, METH_VARARGS, nullptr },
    { "SignalDataChanged", (PyCFunction)ApplicationData_SignalDataChanged, METH_VARARGS, nullptr },
    { "get_Current", (PyCFunction)ApplicationData_get_Current, METH_NOARGS | METH_STATIC, nullptr },
    { "add_DataChanged", (PyCFunction)ApplicationData_add_DataChanged, METH_O, nullptr },
    { "remove_DataChanged", (PyCFunction)ApplicationData_remove_DataChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__ApplicationData_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ApplicationData_getset[] = {
    { const_cast<char*>("LocalFolder"), (getter)ApplicationData_get_LocalFolder, nullptr, nullptr, nullptr },
    { const_cast<char*>("LocalSettings"), (getter)ApplicationData_get_LocalSettings, nullptr, nullptr, nullptr },
    { const_cast<char*>("RoamingFolder"), (getter)ApplicationData_get_RoamingFolder, nullptr, nullptr, nullptr },
    { const_cast<char*>("RoamingSettings"), (getter)ApplicationData_get_RoamingSettings, nullptr, nullptr, nullptr },
    { const_cast<char*>("RoamingStorageQuota"), (getter)ApplicationData_get_RoamingStorageQuota, nullptr, nullptr, nullptr },
    { const_cast<char*>("TemporaryFolder"), (getter)ApplicationData_get_TemporaryFolder, nullptr, nullptr, nullptr },
    { const_cast<char*>("Version"), (getter)ApplicationData_get_Version, nullptr, nullptr, nullptr },
    { const_cast<char*>("LocalCacheFolder"), (getter)ApplicationData_get_LocalCacheFolder, nullptr, nullptr, nullptr },
    { const_cast<char*>("SharedLocalFolder"), (getter)ApplicationData_get_SharedLocalFolder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationData_Type_slots[] = 
{
    { Py_tp_dealloc, ApplicationData_dealloc },
    { Py_tp_new, ApplicationData_new },
    { Py_tp_methods, ApplicationData_methods },
    { Py_tp_getset, ApplicationData_getset },
    { 0, nullptr },
};

static PyType_Spec ApplicationData_Type_spec =
{
    "_pyrt_Windows_Storage.ApplicationData",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationData_Type_slots
};

// ----- ApplicationDataCompositeValue class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type;

static PyObject* ApplicationDataCompositeValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::ApplicationDataCompositeValue instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void ApplicationDataCompositeValue_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataCompositeValue_Clear(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_First(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_GetView(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_HasKey(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.HasKey(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Insert(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
            
            auto return_value = self->obj.Insert(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Lookup(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.Lookup(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Remove(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_get_Size(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.MapChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.MapChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationDataCompositeValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationDataCompositeValue_iter(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __ApplicationDataCompositeValue_mp_length(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __ApplicationDataCompositeValue_mp_subscript(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* key)
{
    try
    {
        return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __ApplicationDataCompositeValue_mp_ass_item(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* key, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.Remove(py::convert_to<winrt::hstring>(key)); }
        else { self->obj.Insert(py::convert_to<winrt::hstring>(key), py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
        return 0;
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef ApplicationDataCompositeValue_methods[] = {
    { "Clear", (PyCFunction)ApplicationDataCompositeValue_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)ApplicationDataCompositeValue_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)ApplicationDataCompositeValue_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)ApplicationDataCompositeValue_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)ApplicationDataCompositeValue_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)ApplicationDataCompositeValue_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)ApplicationDataCompositeValue_Remove, METH_VARARGS, nullptr },
    { "add_MapChanged", (PyCFunction)ApplicationDataCompositeValue_add_MapChanged, METH_O, nullptr },
    { "remove_MapChanged", (PyCFunction)ApplicationDataCompositeValue_remove_MapChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__ApplicationDataCompositeValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ApplicationDataCompositeValue_getset[] = {
    { const_cast<char*>("Size"), (getter)ApplicationDataCompositeValue_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataCompositeValue_Type_slots[] = 
{
    { Py_tp_dealloc, ApplicationDataCompositeValue_dealloc },
    { Py_tp_new, ApplicationDataCompositeValue_new },
    { Py_tp_methods, ApplicationDataCompositeValue_methods },
    { Py_tp_getset, ApplicationDataCompositeValue_getset },
    { Py_tp_iter, __ApplicationDataCompositeValue_iter },
    { Py_mp_length, __ApplicationDataCompositeValue_mp_length },
    { Py_mp_subscript, __ApplicationDataCompositeValue_mp_subscript },
    { Py_mp_ass_subscript, __ApplicationDataCompositeValue_mp_ass_item },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataCompositeValue_Type_spec =
{
    "_pyrt_Windows_Storage.ApplicationDataCompositeValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataCompositeValue_Type_slots
};

// ----- ApplicationDataContainer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type;

static PyObject* ApplicationDataContainer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationDataContainer is not activatable");
    return nullptr;
}

static void ApplicationDataContainer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataContainer_CreateContainer(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);
            
            auto return_value = self->obj.CreateContainer(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainer_DeleteContainer(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.DeleteContainer(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainer_get_Containers(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Containers();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainer_get_Locality(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Locality();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainer_get_Name(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainer_get_Values(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Values();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationDataContainer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::ApplicationDataContainer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ApplicationDataContainer_methods[] = {
    { "CreateContainer", (PyCFunction)ApplicationDataContainer_CreateContainer, METH_VARARGS, nullptr },
    { "DeleteContainer", (PyCFunction)ApplicationDataContainer_DeleteContainer, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__ApplicationDataContainer_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ApplicationDataContainer_getset[] = {
    { const_cast<char*>("Containers"), (getter)ApplicationDataContainer_get_Containers, nullptr, nullptr, nullptr },
    { const_cast<char*>("Locality"), (getter)ApplicationDataContainer_get_Locality, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)ApplicationDataContainer_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Values"), (getter)ApplicationDataContainer_get_Values, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataContainer_Type_slots[] = 
{
    { Py_tp_dealloc, ApplicationDataContainer_dealloc },
    { Py_tp_new, ApplicationDataContainer_new },
    { Py_tp_methods, ApplicationDataContainer_methods },
    { Py_tp_getset, ApplicationDataContainer_getset },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataContainer_Type_spec =
{
    "_pyrt_Windows_Storage.ApplicationDataContainer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataContainer_Type_slots
};

// ----- ApplicationDataContainerSettings class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type;

static PyObject* ApplicationDataContainerSettings_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationDataContainerSettings is not activatable");
    return nullptr;
}

static void ApplicationDataContainerSettings_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataContainerSettings_Clear(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_First(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_GetView(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_HasKey(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.HasKey(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Insert(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
            
            auto return_value = self->obj.Insert(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Lookup(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.Lookup(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Remove(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_get_Size(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.MapChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.MapChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationDataContainerSettings_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ApplicationDataContainerSettings_iter(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __ApplicationDataContainerSettings_mp_length(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __ApplicationDataContainerSettings_mp_subscript(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* key)
{
    try
    {
        return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __ApplicationDataContainerSettings_mp_ass_item(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* key, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.Remove(py::convert_to<winrt::hstring>(key)); }
        else { self->obj.Insert(py::convert_to<winrt::hstring>(key), py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
        return 0;
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef ApplicationDataContainerSettings_methods[] = {
    { "Clear", (PyCFunction)ApplicationDataContainerSettings_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)ApplicationDataContainerSettings_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)ApplicationDataContainerSettings_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)ApplicationDataContainerSettings_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)ApplicationDataContainerSettings_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)ApplicationDataContainerSettings_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)ApplicationDataContainerSettings_Remove, METH_VARARGS, nullptr },
    { "add_MapChanged", (PyCFunction)ApplicationDataContainerSettings_add_MapChanged, METH_O, nullptr },
    { "remove_MapChanged", (PyCFunction)ApplicationDataContainerSettings_remove_MapChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__ApplicationDataContainerSettings_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ApplicationDataContainerSettings_getset[] = {
    { const_cast<char*>("Size"), (getter)ApplicationDataContainerSettings_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataContainerSettings_Type_slots[] = 
{
    { Py_tp_dealloc, ApplicationDataContainerSettings_dealloc },
    { Py_tp_new, ApplicationDataContainerSettings_new },
    { Py_tp_methods, ApplicationDataContainerSettings_methods },
    { Py_tp_getset, ApplicationDataContainerSettings_getset },
    { Py_tp_iter, __ApplicationDataContainerSettings_iter },
    { Py_mp_length, __ApplicationDataContainerSettings_mp_length },
    { Py_mp_subscript, __ApplicationDataContainerSettings_mp_subscript },
    { Py_mp_ass_subscript, __ApplicationDataContainerSettings_mp_ass_item },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataContainerSettings_Type_spec =
{
    "_pyrt_Windows_Storage.ApplicationDataContainerSettings",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataContainerSettings_Type_slots
};

// ----- CachedFileManager class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type;

static PyObject* CachedFileManager_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "CachedFileManager is not activatable");
    return nullptr;
}

static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef CachedFileManager_methods[] = {
    { "CompleteUpdatesAsync", (PyCFunction)CachedFileManager_CompleteUpdatesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "DeferUpdates", (PyCFunction)CachedFileManager_DeferUpdates, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef CachedFileManager_getset[] = {
    { nullptr }
};

static PyType_Slot CachedFileManager_Type_slots[] = 
{
    { Py_tp_new, CachedFileManager_new },
    { Py_tp_methods, CachedFileManager_methods },
    { Py_tp_getset, CachedFileManager_getset },
    { 0, nullptr },
};

static PyType_Spec CachedFileManager_Type_spec =
{
    "_pyrt_Windows_Storage.CachedFileManager",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    CachedFileManager_Type_slots
};

// ----- DownloadsFolder class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type;

static PyObject* DownloadsFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DownloadsFolder is not activatable");
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);
            
            auto return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef DownloadsFolder_methods[] = {
    { "CreateFileAsync", (PyCFunction)DownloadsFolder_CreateFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFileForUserAsync", (PyCFunction)DownloadsFolder_CreateFileForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFolderAsync", (PyCFunction)DownloadsFolder_CreateFolderAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFolderForUserAsync", (PyCFunction)DownloadsFolder_CreateFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef DownloadsFolder_getset[] = {
    { nullptr }
};

static PyType_Slot DownloadsFolder_Type_slots[] = 
{
    { Py_tp_new, DownloadsFolder_new },
    { Py_tp_methods, DownloadsFolder_methods },
    { Py_tp_getset, DownloadsFolder_getset },
    { 0, nullptr },
};

static PyType_Spec DownloadsFolder_Type_spec =
{
    "_pyrt_Windows_Storage.DownloadsFolder",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    DownloadsFolder_Type_slots
};

// ----- FileIO class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::FileIO>::python_type;

static PyObject* FileIO_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileIO is not activatable");
    return nullptr;
}

static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::Storage::FileIO::ReadBufferAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::Storage::FileIO::ReadLinesAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::Storage::FileIO::ReadTextAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint8_t>>(args, 1);
            auto param1 = winrt::array_view<const uint8_t>(_param1.data(), _param1.data() + _param1.size());
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef FileIO_methods[] = {
    { "AppendLinesAsync", (PyCFunction)FileIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "AppendTextAsync", (PyCFunction)FileIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadBufferAsync", (PyCFunction)FileIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadLinesAsync", (PyCFunction)FileIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadTextAsync", (PyCFunction)FileIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBufferAsync", (PyCFunction)FileIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBytesAsync", (PyCFunction)FileIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteLinesAsync", (PyCFunction)FileIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteTextAsync", (PyCFunction)FileIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef FileIO_getset[] = {
    { nullptr }
};

static PyType_Slot FileIO_Type_slots[] = 
{
    { Py_tp_new, FileIO_new },
    { Py_tp_methods, FileIO_methods },
    { Py_tp_getset, FileIO_getset },
    { 0, nullptr },
};

static PyType_Spec FileIO_Type_spec =
{
    "_pyrt_Windows_Storage.FileIO",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    FileIO_Type_slots
};

// ----- KnownFolders class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type;

static PyObject* KnownFolders_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "KnownFolders is not activatable");
    return nullptr;
}

static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);
            
            auto return_value = winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::CameraRoll();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::Playlists();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::SavedPictures();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::DocumentsLibrary();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::HomeGroup();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::MediaServerDevices();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::MusicLibrary();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::PicturesLibrary();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::RemovableDevices();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::VideosLibrary();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::AppCaptures();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::Objects3D();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::KnownFolders::RecordedCalls();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef KnownFolders_methods[] = {
    { "GetFolderForUserAsync", (PyCFunction)KnownFolders_GetFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_CameraRoll", (PyCFunction)KnownFolders_get_CameraRoll, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Playlists", (PyCFunction)KnownFolders_get_Playlists, METH_NOARGS | METH_STATIC, nullptr },
    { "get_SavedPictures", (PyCFunction)KnownFolders_get_SavedPictures, METH_NOARGS | METH_STATIC, nullptr },
    { "get_DocumentsLibrary", (PyCFunction)KnownFolders_get_DocumentsLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HomeGroup", (PyCFunction)KnownFolders_get_HomeGroup, METH_NOARGS | METH_STATIC, nullptr },
    { "get_MediaServerDevices", (PyCFunction)KnownFolders_get_MediaServerDevices, METH_NOARGS | METH_STATIC, nullptr },
    { "get_MusicLibrary", (PyCFunction)KnownFolders_get_MusicLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_PicturesLibrary", (PyCFunction)KnownFolders_get_PicturesLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_RemovableDevices", (PyCFunction)KnownFolders_get_RemovableDevices, METH_NOARGS | METH_STATIC, nullptr },
    { "get_VideosLibrary", (PyCFunction)KnownFolders_get_VideosLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_AppCaptures", (PyCFunction)KnownFolders_get_AppCaptures, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Objects3D", (PyCFunction)KnownFolders_get_Objects3D, METH_NOARGS | METH_STATIC, nullptr },
    { "get_RecordedCalls", (PyCFunction)KnownFolders_get_RecordedCalls, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef KnownFolders_getset[] = {
    { nullptr }
};

static PyType_Slot KnownFolders_Type_slots[] = 
{
    { Py_tp_new, KnownFolders_new },
    { Py_tp_methods, KnownFolders_methods },
    { Py_tp_getset, KnownFolders_getset },
    { 0, nullptr },
};

static PyType_Spec KnownFolders_Type_spec =
{
    "_pyrt_Windows_Storage.KnownFolders",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    KnownFolders_Type_slots
};

// ----- PathIO class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::PathIO>::python_type;

static PyObject* PathIO_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PathIO is not activatable");
    return nullptr;
}

static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::PathIO::ReadBufferAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::PathIO::ReadLinesAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::PathIO::ReadTextAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint8_t>>(args, 1);
            auto param1 = winrt::array_view<const uint8_t>(_param1.data(), _param1.data() + _param1.size());
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);
            
            auto return_value = winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef PathIO_methods[] = {
    { "AppendLinesAsync", (PyCFunction)PathIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "AppendTextAsync", (PyCFunction)PathIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadBufferAsync", (PyCFunction)PathIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadLinesAsync", (PyCFunction)PathIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadTextAsync", (PyCFunction)PathIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBufferAsync", (PyCFunction)PathIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBytesAsync", (PyCFunction)PathIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteLinesAsync", (PyCFunction)PathIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteTextAsync", (PyCFunction)PathIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef PathIO_getset[] = {
    { nullptr }
};

static PyType_Slot PathIO_Type_slots[] = 
{
    { Py_tp_new, PathIO_new },
    { Py_tp_methods, PathIO_methods },
    { Py_tp_getset, PathIO_getset },
    { 0, nullptr },
};

static PyType_Spec PathIO_Type_spec =
{
    "_pyrt_Windows_Storage.PathIO",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    PathIO_Type_slots
};

// ----- SetVersionDeferral class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type;

static PyObject* SetVersionDeferral_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SetVersionDeferral is not activatable");
    return nullptr;
}

static void SetVersionDeferral_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SetVersionDeferral_Complete(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Complete();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __SetVersionDeferral_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SetVersionDeferral>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SetVersionDeferral_methods[] = {
    { "Complete", (PyCFunction)SetVersionDeferral_Complete, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__SetVersionDeferral_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SetVersionDeferral_getset[] = {
    { nullptr }
};

static PyType_Slot SetVersionDeferral_Type_slots[] = 
{
    { Py_tp_dealloc, SetVersionDeferral_dealloc },
    { Py_tp_new, SetVersionDeferral_new },
    { Py_tp_methods, SetVersionDeferral_methods },
    { Py_tp_getset, SetVersionDeferral_getset },
    { 0, nullptr },
};

static PyType_Spec SetVersionDeferral_Type_spec =
{
    "_pyrt_Windows_Storage.SetVersionDeferral",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>),
    0,
    Py_TPFLAGS_DEFAULT,
    SetVersionDeferral_Type_slots
};

// ----- SetVersionRequest class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type;

static PyObject* SetVersionRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SetVersionRequest is not activatable");
    return nullptr;
}

static void SetVersionRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SetVersionRequest_GetDeferral(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetDeferral();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SetVersionRequest_get_CurrentVersion(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CurrentVersion();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SetVersionRequest_get_DesiredVersion(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DesiredVersion();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SetVersionRequest_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SetVersionRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SetVersionRequest_methods[] = {
    { "GetDeferral", (PyCFunction)SetVersionRequest_GetDeferral, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__SetVersionRequest_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SetVersionRequest_getset[] = {
    { const_cast<char*>("CurrentVersion"), (getter)SetVersionRequest_get_CurrentVersion, nullptr, nullptr, nullptr },
    { const_cast<char*>("DesiredVersion"), (getter)SetVersionRequest_get_DesiredVersion, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SetVersionRequest_Type_slots[] = 
{
    { Py_tp_dealloc, SetVersionRequest_dealloc },
    { Py_tp_new, SetVersionRequest_new },
    { Py_tp_methods, SetVersionRequest_methods },
    { Py_tp_getset, SetVersionRequest_getset },
    { 0, nullptr },
};

static PyType_Spec SetVersionRequest_Type_spec =
{
    "_pyrt_Windows_Storage.SetVersionRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    SetVersionRequest_Type_slots
};

// ----- StorageFile class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type;

static PyObject* StorageFile_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFile is not activatable");
    return nullptr;
}

static void StorageFile_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFile_CopyAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = self->obj.CopyAndReplaceAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_CopyAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            
            auto return_value = self->obj.CopyAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.CopyAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);
            
            auto return_value = self->obj.CopyAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);
            
            auto return_value = winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);
            
            auto return_value = winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
            
            auto return_value = winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetParentAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
            
            auto return_value = self->obj.IsEqual(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_MoveAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = self->obj.MoveAndReplaceAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_MoveAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            
            auto return_value = self->obj.MoveAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.MoveAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);
            
            auto return_value = self->obj.MoveAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            
            auto return_value = self->obj.OpenAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
            
            auto return_value = self->obj.OpenAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenSequentialReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenTransactedWriteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);
            
            auto return_value = self->obj.OpenTransactedWriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);
            
            auto return_value = winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);
            
            auto return_value = winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFile_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ContentType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_FileType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FileType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_IsAvailable(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsAvailable();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_Name(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderRelativeId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Provider();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageFile_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageFile>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageFile_methods[] = {
    { "CopyAndReplaceAsync", (PyCFunction)StorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
    { "CopyAsync", (PyCFunction)StorageFile_CopyAsync, METH_VARARGS, nullptr },
    { "CreateStreamedFileAsync", (PyCFunction)StorageFile_CreateStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateStreamedFileFromUriAsync", (PyCFunction)StorageFile_CreateStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "DeleteAsync", (PyCFunction)StorageFile_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)StorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileFromApplicationUriAsync", (PyCFunction)StorageFile_GetFileFromApplicationUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFileFromPathAsync", (PyCFunction)StorageFile_GetFileFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetParentAsync", (PyCFunction)StorageFile_GetParentAsync, METH_VARARGS, nullptr },
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)StorageFile_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)StorageFile_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)StorageFile_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageFile_IsOfType, METH_VARARGS, nullptr },
    { "MoveAndReplaceAsync", (PyCFunction)StorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
    { "MoveAsync", (PyCFunction)StorageFile_MoveAsync, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)StorageFile_OpenAsync, METH_VARARGS, nullptr },
    { "OpenReadAsync", (PyCFunction)StorageFile_OpenReadAsync, METH_VARARGS, nullptr },
    { "OpenSequentialReadAsync", (PyCFunction)StorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)StorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)StorageFile_RenameAsync, METH_VARARGS, nullptr },
    { "ReplaceWithStreamedFileAsync", (PyCFunction)StorageFile_ReplaceWithStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReplaceWithStreamedFileFromUriAsync", (PyCFunction)StorageFile_ReplaceWithStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__StorageFile_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageFile_getset[] = {
    { const_cast<char*>("ContentType"), (getter)StorageFile_get_ContentType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FileType"), (getter)StorageFile_get_FileType, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsAvailable"), (getter)StorageFile_get_IsAvailable, nullptr, nullptr, nullptr },
    { const_cast<char*>("Attributes"), (getter)StorageFile_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)StorageFile_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)StorageFile_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)StorageFile_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayName"), (getter)StorageFile_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayType"), (getter)StorageFile_get_DisplayType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FolderRelativeId"), (getter)StorageFile_get_FolderRelativeId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)StorageFile_get_Properties, nullptr, nullptr, nullptr },
    { const_cast<char*>("Provider"), (getter)StorageFile_get_Provider, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageFile_Type_slots[] = 
{
    { Py_tp_dealloc, StorageFile_dealloc },
    { Py_tp_new, StorageFile_new },
    { Py_tp_methods, StorageFile_methods },
    { Py_tp_getset, StorageFile_getset },
    { 0, nullptr },
};

static PyType_Spec StorageFile_Type_spec =
{
    "_pyrt_Windows_Storage.StorageFile",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFile_Type_slots
};

// ----- StorageFolder class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type;

static PyObject* StorageFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFolder is not activatable");
    return nullptr;
}

static void StorageFolder_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFolder_AreQueryOptionsSupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.AreQueryOptionsSupported(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.CreateFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = self->obj.CreateFileAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFileQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateFileQuery();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.CreateFileQuery(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFileQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateFileQueryWithOptions(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.CreateFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = self->obj.CreateFolderAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateFolderQuery();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.CreateFolderQuery(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateFolderQueryWithOptions(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateItemQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateItemQuery();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_CreateItemQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateItemQueryWithOptions(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFilesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = self->obj.GetFilesAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.GetFilesAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFoldersAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = self->obj.GetFoldersAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.GetFoldersAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetIndexedStateAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetIndexedStateAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetItemAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemsAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetItemsAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetParentAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_IsCommonFileQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.IsCommonFileQuerySupported(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.IsCommonFolderQuerySupported(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
            
            auto return_value = self->obj.IsEqual(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_TryGetChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.TryGetChangeTracker();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_TryGetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.TryGetItemAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolder_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_Name(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderRelativeId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Provider();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageFolder_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageFolder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageFolder_methods[] = {
    { "AreQueryOptionsSupported", (PyCFunction)StorageFolder_AreQueryOptionsSupported, METH_VARARGS, nullptr },
    { "CreateFileAsync", (PyCFunction)StorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
    { "CreateFileQuery", (PyCFunction)StorageFolder_CreateFileQuery, METH_VARARGS, nullptr },
    { "CreateFileQueryWithOptions", (PyCFunction)StorageFolder_CreateFileQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateFolderAsync", (PyCFunction)StorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
    { "CreateFolderQuery", (PyCFunction)StorageFolder_CreateFolderQuery, METH_VARARGS, nullptr },
    { "CreateFolderQueryWithOptions", (PyCFunction)StorageFolder_CreateFolderQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateItemQuery", (PyCFunction)StorageFolder_CreateItemQuery, METH_VARARGS, nullptr },
    { "CreateItemQueryWithOptions", (PyCFunction)StorageFolder_CreateItemQueryWithOptions, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)StorageFolder_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)StorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileAsync", (PyCFunction)StorageFolder_GetFileAsync, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)StorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFolderAsync", (PyCFunction)StorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
    { "GetFolderFromPathAsync", (PyCFunction)StorageFolder_GetFolderFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFoldersAsync", (PyCFunction)StorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetIndexedStateAsync", (PyCFunction)StorageFolder_GetIndexedStateAsync, METH_VARARGS, nullptr },
    { "GetItemAsync", (PyCFunction)StorageFolder_GetItemAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)StorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
    { "GetParentAsync", (PyCFunction)StorageFolder_GetParentAsync, METH_VARARGS, nullptr },
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)StorageFolder_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)StorageFolder_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "IsCommonFileQuerySupported", (PyCFunction)StorageFolder_IsCommonFileQuerySupported, METH_VARARGS, nullptr },
    { "IsCommonFolderQuerySupported", (PyCFunction)StorageFolder_IsCommonFolderQuerySupported, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)StorageFolder_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageFolder_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)StorageFolder_RenameAsync, METH_VARARGS, nullptr },
    { "TryGetChangeTracker", (PyCFunction)StorageFolder_TryGetChangeTracker, METH_VARARGS, nullptr },
    { "TryGetItemAsync", (PyCFunction)StorageFolder_TryGetItemAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageFolder_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageFolder_getset[] = {
    { const_cast<char*>("Attributes"), (getter)StorageFolder_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)StorageFolder_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)StorageFolder_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)StorageFolder_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayName"), (getter)StorageFolder_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayType"), (getter)StorageFolder_get_DisplayType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FolderRelativeId"), (getter)StorageFolder_get_FolderRelativeId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)StorageFolder_get_Properties, nullptr, nullptr, nullptr },
    { const_cast<char*>("Provider"), (getter)StorageFolder_get_Provider, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageFolder_Type_slots[] = 
{
    { Py_tp_dealloc, StorageFolder_dealloc },
    { Py_tp_new, StorageFolder_new },
    { Py_tp_methods, StorageFolder_methods },
    { Py_tp_getset, StorageFolder_getset },
    { 0, nullptr },
};

static PyType_Spec StorageFolder_Type_spec =
{
    "_pyrt_Windows_Storage.StorageFolder",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFolder_Type_slots
};

// ----- StorageLibrary class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type;

static PyObject* StorageLibrary_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibrary is not activatable");
    return nullptr;
}

static void StorageLibrary_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.AreFolderSuggestionsAvailableAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);
            
            auto return_value = winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);
            
            auto return_value = winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibrary_RequestAddFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.RequestAddFolderAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);
            
            auto return_value = self->obj.RequestRemoveFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibrary_get_Folders(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folders();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibrary_get_SaveFolder(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SaveFolder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibrary_get_ChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ChangeTracker();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibrary_add_DefinitionChanged(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.DefinitionChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibrary_remove_DefinitionChanged(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.DefinitionChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageLibrary_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageLibrary>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibrary_methods[] = {
    { "AreFolderSuggestionsAvailableAsync", (PyCFunction)StorageLibrary_AreFolderSuggestionsAvailableAsync, METH_VARARGS, nullptr },
    { "GetLibraryAsync", (PyCFunction)StorageLibrary_GetLibraryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetLibraryForUserAsync", (PyCFunction)StorageLibrary_GetLibraryForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "RequestAddFolderAsync", (PyCFunction)StorageLibrary_RequestAddFolderAsync, METH_VARARGS, nullptr },
    { "RequestRemoveFolderAsync", (PyCFunction)StorageLibrary_RequestRemoveFolderAsync, METH_VARARGS, nullptr },
    { "add_DefinitionChanged", (PyCFunction)StorageLibrary_add_DefinitionChanged, METH_O, nullptr },
    { "remove_DefinitionChanged", (PyCFunction)StorageLibrary_remove_DefinitionChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__StorageLibrary_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibrary_getset[] = {
    { const_cast<char*>("Folders"), (getter)StorageLibrary_get_Folders, nullptr, nullptr, nullptr },
    { const_cast<char*>("SaveFolder"), (getter)StorageLibrary_get_SaveFolder, nullptr, nullptr, nullptr },
    { const_cast<char*>("ChangeTracker"), (getter)StorageLibrary_get_ChangeTracker, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibrary_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibrary_dealloc },
    { Py_tp_new, StorageLibrary_new },
    { Py_tp_methods, StorageLibrary_methods },
    { Py_tp_getset, StorageLibrary_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibrary_Type_spec =
{
    "_pyrt_Windows_Storage.StorageLibrary",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibrary_Type_slots
};

// ----- StorageLibraryChange class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type;

static PyObject* StorageLibraryChange_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChange is not activatable");
    return nullptr;
}

static void StorageLibraryChange_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChange_GetStorageItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetStorageItemAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryChange_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryChange_get_ChangeType(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ChangeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChange_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChange_get_PreviousPath(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PreviousPath();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageLibraryChange_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageLibraryChange>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibraryChange_methods[] = {
    { "GetStorageItemAsync", (PyCFunction)StorageLibraryChange_GetStorageItemAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageLibraryChange_IsOfType, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageLibraryChange_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibraryChange_getset[] = {
    { const_cast<char*>("ChangeType"), (getter)StorageLibraryChange_get_ChangeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)StorageLibraryChange_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("PreviousPath"), (getter)StorageLibraryChange_get_PreviousPath, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChange_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibraryChange_dealloc },
    { Py_tp_new, StorageLibraryChange_new },
    { Py_tp_methods, StorageLibraryChange_methods },
    { Py_tp_getset, StorageLibraryChange_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChange_Type_spec =
{
    "_pyrt_Windows_Storage.StorageLibraryChange",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChange_Type_slots
};

// ----- StorageLibraryChangeReader class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type;

static PyObject* StorageLibraryChangeReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeReader is not activatable");
    return nullptr;
}

static void StorageLibraryChangeReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.AcceptChangesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadBatchAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __StorageLibraryChangeReader_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibraryChangeReader_methods[] = {
    { "AcceptChangesAsync", (PyCFunction)StorageLibraryChangeReader_AcceptChangesAsync, METH_VARARGS, nullptr },
    { "ReadBatchAsync", (PyCFunction)StorageLibraryChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageLibraryChangeReader_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibraryChangeReader_getset[] = {
    { nullptr }
};

static PyType_Slot StorageLibraryChangeReader_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibraryChangeReader_dealloc },
    { Py_tp_new, StorageLibraryChangeReader_new },
    { Py_tp_methods, StorageLibraryChangeReader_methods },
    { Py_tp_getset, StorageLibraryChangeReader_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeReader_Type_spec =
{
    "_pyrt_Windows_Storage.StorageLibraryChangeReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeReader_Type_slots
};

// ----- StorageLibraryChangeTracker class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type;

static PyObject* StorageLibraryChangeTracker_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeTracker is not activatable");
    return nullptr;
}

static void StorageLibraryChangeTracker_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeTracker_Enable(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Enable();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetChangeReader();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryChangeTracker_Reset(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Reset();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __StorageLibraryChangeTracker_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibraryChangeTracker_methods[] = {
    { "Enable", (PyCFunction)StorageLibraryChangeTracker_Enable, METH_VARARGS, nullptr },
    { "GetChangeReader", (PyCFunction)StorageLibraryChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
    { "Reset", (PyCFunction)StorageLibraryChangeTracker_Reset, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageLibraryChangeTracker_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibraryChangeTracker_getset[] = {
    { nullptr }
};

static PyType_Slot StorageLibraryChangeTracker_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibraryChangeTracker_dealloc },
    { Py_tp_new, StorageLibraryChangeTracker_new },
    { Py_tp_methods, StorageLibraryChangeTracker_methods },
    { Py_tp_getset, StorageLibraryChangeTracker_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeTracker_Type_spec =
{
    "_pyrt_Windows_Storage.StorageLibraryChangeTracker",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeTracker_Type_slots
};

// ----- StorageProvider class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type;

static PyObject* StorageProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageProvider is not activatable");
    return nullptr;
}

static void StorageProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.IsPropertySupportedForPartialFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageProvider_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageProvider_get_Id(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageProvider_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageProvider_methods[] = {
    { "IsPropertySupportedForPartialFileAsync", (PyCFunction)StorageProvider_IsPropertySupportedForPartialFileAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageProvider_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageProvider_getset[] = {
    { const_cast<char*>("DisplayName"), (getter)StorageProvider_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)StorageProvider_get_Id, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageProvider_Type_slots[] = 
{
    { Py_tp_dealloc, StorageProvider_dealloc },
    { Py_tp_new, StorageProvider_new },
    { Py_tp_methods, StorageProvider_methods },
    { Py_tp_getset, StorageProvider_getset },
    { 0, nullptr },
};

static PyType_Spec StorageProvider_Type_spec =
{
    "_pyrt_Windows_Storage.StorageProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageProvider_Type_slots
};

// ----- StorageStreamTransaction class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type;

static PyObject* StorageStreamTransaction_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageStreamTransaction is not activatable");
    return nullptr;
}

static void StorageStreamTransaction_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageStreamTransaction_Close(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageStreamTransaction_CommitAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CommitAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageStreamTransaction_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Stream();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageStreamTransaction_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StorageStreamTransaction>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageStreamTransaction_enter(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __StorageStreamTransaction_exit(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageStreamTransaction_methods[] = {
    { "Close", (PyCFunction)StorageStreamTransaction_Close, METH_VARARGS, nullptr },
    { "CommitAsync", (PyCFunction)StorageStreamTransaction_CommitAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageStreamTransaction_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__StorageStreamTransaction_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__StorageStreamTransaction_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef StorageStreamTransaction_getset[] = {
    { const_cast<char*>("Stream"), (getter)StorageStreamTransaction_get_Stream, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageStreamTransaction_Type_slots[] = 
{
    { Py_tp_dealloc, StorageStreamTransaction_dealloc },
    { Py_tp_new, StorageStreamTransaction_new },
    { Py_tp_methods, StorageStreamTransaction_methods },
    { Py_tp_getset, StorageStreamTransaction_getset },
    { 0, nullptr },
};

static PyType_Spec StorageStreamTransaction_Type_spec =
{
    "_pyrt_Windows_Storage.StorageStreamTransaction",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageStreamTransaction_Type_slots
};

// ----- StreamedFileDataRequest class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type;

static PyObject* StreamedFileDataRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StreamedFileDataRequest is not activatable");
    return nullptr;
}

static void StreamedFileDataRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StreamedFileDataRequest_Close(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StreamedFileDataRequest_FailAndClose(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);
            
            self->obj.FailAndClose(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StreamedFileDataRequest_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StreamedFileDataRequest_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __StreamedFileDataRequest_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::StreamedFileDataRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StreamedFileDataRequest_enter(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __StreamedFileDataRequest_exit(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StreamedFileDataRequest_methods[] = {
    { "Close", (PyCFunction)StreamedFileDataRequest_Close, METH_VARARGS, nullptr },
    { "FailAndClose", (PyCFunction)StreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)StreamedFileDataRequest_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)StreamedFileDataRequest_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StreamedFileDataRequest_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__StreamedFileDataRequest_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__StreamedFileDataRequest_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef StreamedFileDataRequest_getset[] = {
    { nullptr }
};

static PyType_Slot StreamedFileDataRequest_Type_slots[] = 
{
    { Py_tp_dealloc, StreamedFileDataRequest_dealloc },
    { Py_tp_new, StreamedFileDataRequest_new },
    { Py_tp_methods, StreamedFileDataRequest_methods },
    { Py_tp_getset, StreamedFileDataRequest_getset },
    { 0, nullptr },
};

static PyType_Spec StreamedFileDataRequest_Type_spec =
{
    "_pyrt_Windows_Storage.StreamedFileDataRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    StreamedFileDataRequest_Type_slots
};

// ----- SystemAudioProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type;

static PyObject* SystemAudioProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemAudioProperties is not activatable");
    return nullptr;
}

static void SystemAudioProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemAudioProperties_get_EncodingBitrate(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.EncodingBitrate();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemAudioProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemAudioProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemAudioProperties_methods[] = {
    { "_from", (PyCFunction)__SystemAudioProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemAudioProperties_getset[] = {
    { const_cast<char*>("EncodingBitrate"), (getter)SystemAudioProperties_get_EncodingBitrate, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemAudioProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemAudioProperties_dealloc },
    { Py_tp_new, SystemAudioProperties_new },
    { Py_tp_methods, SystemAudioProperties_methods },
    { Py_tp_getset, SystemAudioProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemAudioProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemAudioProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemAudioProperties_Type_slots
};

// ----- SystemDataPaths class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type;

static PyObject* SystemDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemDataPaths is not activatable");
    return nullptr;
}

static void SystemDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Storage::SystemDataPaths::GetDefault();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SystemDataPaths_get_Fonts(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Fonts();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_ProgramData(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ProgramData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_Public(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Public();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicDesktop(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicDesktop();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicDocuments(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicDocuments();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicDownloads(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicDownloads();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicMusic(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicMusic();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicPictures(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicPictures();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_PublicVideos(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PublicVideos();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_System(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.System();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_SystemArm(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemArm();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_SystemHost(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemHost();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_SystemX64(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemX64();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_SystemX86(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SystemX86();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_UserProfiles(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UserProfiles();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_get_Windows(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Windows();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemDataPaths_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)SystemDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__SystemDataPaths_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemDataPaths_getset[] = {
    { const_cast<char*>("Fonts"), (getter)SystemDataPaths_get_Fonts, nullptr, nullptr, nullptr },
    { const_cast<char*>("ProgramData"), (getter)SystemDataPaths_get_ProgramData, nullptr, nullptr, nullptr },
    { const_cast<char*>("Public"), (getter)SystemDataPaths_get_Public, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicDesktop"), (getter)SystemDataPaths_get_PublicDesktop, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicDocuments"), (getter)SystemDataPaths_get_PublicDocuments, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicDownloads"), (getter)SystemDataPaths_get_PublicDownloads, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicMusic"), (getter)SystemDataPaths_get_PublicMusic, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicPictures"), (getter)SystemDataPaths_get_PublicPictures, nullptr, nullptr, nullptr },
    { const_cast<char*>("PublicVideos"), (getter)SystemDataPaths_get_PublicVideos, nullptr, nullptr, nullptr },
    { const_cast<char*>("System"), (getter)SystemDataPaths_get_System, nullptr, nullptr, nullptr },
    { const_cast<char*>("SystemArm"), (getter)SystemDataPaths_get_SystemArm, nullptr, nullptr, nullptr },
    { const_cast<char*>("SystemHost"), (getter)SystemDataPaths_get_SystemHost, nullptr, nullptr, nullptr },
    { const_cast<char*>("SystemX64"), (getter)SystemDataPaths_get_SystemX64, nullptr, nullptr, nullptr },
    { const_cast<char*>("SystemX86"), (getter)SystemDataPaths_get_SystemX86, nullptr, nullptr, nullptr },
    { const_cast<char*>("UserProfiles"), (getter)SystemDataPaths_get_UserProfiles, nullptr, nullptr, nullptr },
    { const_cast<char*>("Windows"), (getter)SystemDataPaths_get_Windows, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemDataPaths_Type_slots[] = 
{
    { Py_tp_dealloc, SystemDataPaths_dealloc },
    { Py_tp_new, SystemDataPaths_new },
    { Py_tp_methods, SystemDataPaths_methods },
    { Py_tp_getset, SystemDataPaths_getset },
    { 0, nullptr },
};

static PyType_Spec SystemDataPaths_Type_spec =
{
    "_pyrt_Windows_Storage.SystemDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemDataPaths_Type_slots
};

// ----- SystemGPSProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type;

static PyObject* SystemGPSProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemGPSProperties is not activatable");
    return nullptr;
}

static void SystemGPSProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LatitudeDecimal();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LongitudeDecimal();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemGPSProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemGPSProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemGPSProperties_methods[] = {
    { "_from", (PyCFunction)__SystemGPSProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemGPSProperties_getset[] = {
    { const_cast<char*>("LatitudeDecimal"), (getter)SystemGPSProperties_get_LatitudeDecimal, nullptr, nullptr, nullptr },
    { const_cast<char*>("LongitudeDecimal"), (getter)SystemGPSProperties_get_LongitudeDecimal, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemGPSProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemGPSProperties_dealloc },
    { Py_tp_new, SystemGPSProperties_new },
    { Py_tp_methods, SystemGPSProperties_methods },
    { Py_tp_getset, SystemGPSProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemGPSProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemGPSProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemGPSProperties_Type_slots
};

// ----- SystemImageProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type;

static PyObject* SystemImageProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemImageProperties is not activatable");
    return nullptr;
}

static void SystemImageProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemImageProperties_get_HorizontalSize(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.HorizontalSize();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemImageProperties_get_VerticalSize(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VerticalSize();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemImageProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemImageProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemImageProperties_methods[] = {
    { "_from", (PyCFunction)__SystemImageProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemImageProperties_getset[] = {
    { const_cast<char*>("HorizontalSize"), (getter)SystemImageProperties_get_HorizontalSize, nullptr, nullptr, nullptr },
    { const_cast<char*>("VerticalSize"), (getter)SystemImageProperties_get_VerticalSize, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemImageProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemImageProperties_dealloc },
    { Py_tp_new, SystemImageProperties_new },
    { Py_tp_methods, SystemImageProperties_methods },
    { Py_tp_getset, SystemImageProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemImageProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemImageProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemImageProperties_Type_slots
};

// ----- SystemMediaProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type;

static PyObject* SystemMediaProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaProperties is not activatable");
    return nullptr;
}

static void SystemMediaProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaProperties_get_Duration(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_Producer(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Producer();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_Publisher(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Publisher();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_SubTitle(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SubTitle();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_Writer(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Writer();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_Year(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Year();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMediaProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemMediaProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMediaProperties_methods[] = {
    { "_from", (PyCFunction)__SystemMediaProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMediaProperties_getset[] = {
    { const_cast<char*>("Duration"), (getter)SystemMediaProperties_get_Duration, nullptr, nullptr, nullptr },
    { const_cast<char*>("Producer"), (getter)SystemMediaProperties_get_Producer, nullptr, nullptr, nullptr },
    { const_cast<char*>("Publisher"), (getter)SystemMediaProperties_get_Publisher, nullptr, nullptr, nullptr },
    { const_cast<char*>("SubTitle"), (getter)SystemMediaProperties_get_SubTitle, nullptr, nullptr, nullptr },
    { const_cast<char*>("Writer"), (getter)SystemMediaProperties_get_Writer, nullptr, nullptr, nullptr },
    { const_cast<char*>("Year"), (getter)SystemMediaProperties_get_Year, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMediaProperties_dealloc },
    { Py_tp_new, SystemMediaProperties_new },
    { Py_tp_methods, SystemMediaProperties_methods },
    { Py_tp_getset, SystemMediaProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMediaProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemMediaProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaProperties_Type_slots
};

// ----- SystemMusicProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type;

static PyObject* SystemMusicProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMusicProperties is not activatable");
    return nullptr;
}

static void SystemMusicProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMusicProperties_get_AlbumArtist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AlbumArtist();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_AlbumTitle(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AlbumTitle();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_Artist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Artist();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_Composer(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Composer();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_Conductor(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Conductor();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_DisplayArtist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayArtist();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_Genre(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Genre();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_TrackNumber(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TrackNumber();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemMusicProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemMusicProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemMusicProperties_methods[] = {
    { "_from", (PyCFunction)__SystemMusicProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemMusicProperties_getset[] = {
    { const_cast<char*>("AlbumArtist"), (getter)SystemMusicProperties_get_AlbumArtist, nullptr, nullptr, nullptr },
    { const_cast<char*>("AlbumTitle"), (getter)SystemMusicProperties_get_AlbumTitle, nullptr, nullptr, nullptr },
    { const_cast<char*>("Artist"), (getter)SystemMusicProperties_get_Artist, nullptr, nullptr, nullptr },
    { const_cast<char*>("Composer"), (getter)SystemMusicProperties_get_Composer, nullptr, nullptr, nullptr },
    { const_cast<char*>("Conductor"), (getter)SystemMusicProperties_get_Conductor, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayArtist"), (getter)SystemMusicProperties_get_DisplayArtist, nullptr, nullptr, nullptr },
    { const_cast<char*>("Genre"), (getter)SystemMusicProperties_get_Genre, nullptr, nullptr, nullptr },
    { const_cast<char*>("TrackNumber"), (getter)SystemMusicProperties_get_TrackNumber, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemMusicProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemMusicProperties_dealloc },
    { Py_tp_new, SystemMusicProperties_new },
    { Py_tp_methods, SystemMusicProperties_methods },
    { Py_tp_getset, SystemMusicProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemMusicProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemMusicProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMusicProperties_Type_slots
};

// ----- SystemPhotoProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type;

static PyObject* SystemPhotoProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemPhotoProperties is not activatable");
    return nullptr;
}

static void SystemPhotoProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CameraManufacturer();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemPhotoProperties_get_CameraModel(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CameraModel();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemPhotoProperties_get_DateTaken(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateTaken();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemPhotoProperties_get_Orientation(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Orientation();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemPhotoProperties_get_PeopleNames(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PeopleNames();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemPhotoProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemPhotoProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemPhotoProperties_methods[] = {
    { "_from", (PyCFunction)__SystemPhotoProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemPhotoProperties_getset[] = {
    { const_cast<char*>("CameraManufacturer"), (getter)SystemPhotoProperties_get_CameraManufacturer, nullptr, nullptr, nullptr },
    { const_cast<char*>("CameraModel"), (getter)SystemPhotoProperties_get_CameraModel, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateTaken"), (getter)SystemPhotoProperties_get_DateTaken, nullptr, nullptr, nullptr },
    { const_cast<char*>("Orientation"), (getter)SystemPhotoProperties_get_Orientation, nullptr, nullptr, nullptr },
    { const_cast<char*>("PeopleNames"), (getter)SystemPhotoProperties_get_PeopleNames, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemPhotoProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemPhotoProperties_dealloc },
    { Py_tp_new, SystemPhotoProperties_new },
    { Py_tp_methods, SystemPhotoProperties_methods },
    { Py_tp_getset, SystemPhotoProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemPhotoProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemPhotoProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemPhotoProperties_Type_slots
};

// ----- SystemProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type;

static PyObject* SystemProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemProperties is not activatable");
    return nullptr;
}

static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Audio();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Author();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Comment();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::GPS();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Image();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::ItemNameDisplay();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Keywords();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Media();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Music();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Photo();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Rating();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Title();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Storage::SystemProperties::Video();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemProperties_methods[] = {
    { "get_Audio", (PyCFunction)SystemProperties_get_Audio, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Author", (PyCFunction)SystemProperties_get_Author, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Comment", (PyCFunction)SystemProperties_get_Comment, METH_NOARGS | METH_STATIC, nullptr },
    { "get_GPS", (PyCFunction)SystemProperties_get_GPS, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Image", (PyCFunction)SystemProperties_get_Image, METH_NOARGS | METH_STATIC, nullptr },
    { "get_ItemNameDisplay", (PyCFunction)SystemProperties_get_ItemNameDisplay, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Keywords", (PyCFunction)SystemProperties_get_Keywords, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Media", (PyCFunction)SystemProperties_get_Media, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Music", (PyCFunction)SystemProperties_get_Music, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Photo", (PyCFunction)SystemProperties_get_Photo, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Rating", (PyCFunction)SystemProperties_get_Rating, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Title", (PyCFunction)SystemProperties_get_Title, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Video", (PyCFunction)SystemProperties_get_Video, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemProperties_getset[] = {
    { nullptr }
};

static PyType_Slot SystemProperties_Type_slots[] = 
{
    { Py_tp_new, SystemProperties_new },
    { Py_tp_methods, SystemProperties_methods },
    { Py_tp_getset, SystemProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemProperties",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    SystemProperties_Type_slots
};

// ----- SystemVideoProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type;

static PyObject* SystemVideoProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemVideoProperties is not activatable");
    return nullptr;
}

static void SystemVideoProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemVideoProperties_get_Director(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Director();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemVideoProperties_get_FrameHeight(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FrameHeight();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemVideoProperties_get_FrameWidth(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FrameWidth();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemVideoProperties_get_Orientation(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Orientation();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemVideoProperties_get_TotalBitrate(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TotalBitrate();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SystemVideoProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::SystemVideoProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SystemVideoProperties_methods[] = {
    { "_from", (PyCFunction)__SystemVideoProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SystemVideoProperties_getset[] = {
    { const_cast<char*>("Director"), (getter)SystemVideoProperties_get_Director, nullptr, nullptr, nullptr },
    { const_cast<char*>("FrameHeight"), (getter)SystemVideoProperties_get_FrameHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("FrameWidth"), (getter)SystemVideoProperties_get_FrameWidth, nullptr, nullptr, nullptr },
    { const_cast<char*>("Orientation"), (getter)SystemVideoProperties_get_Orientation, nullptr, nullptr, nullptr },
    { const_cast<char*>("TotalBitrate"), (getter)SystemVideoProperties_get_TotalBitrate, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SystemVideoProperties_Type_slots[] = 
{
    { Py_tp_dealloc, SystemVideoProperties_dealloc },
    { Py_tp_new, SystemVideoProperties_new },
    { Py_tp_methods, SystemVideoProperties_methods },
    { Py_tp_getset, SystemVideoProperties_getset },
    { 0, nullptr },
};

static PyType_Spec SystemVideoProperties_Type_spec =
{
    "_pyrt_Windows_Storage.SystemVideoProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemVideoProperties_Type_slots
};

// ----- UserDataPaths class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type;

static PyObject* UserDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "UserDataPaths is not activatable");
    return nullptr;
}

static void UserDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Storage::UserDataPaths::GetDefault();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            
            auto return_value = winrt::Windows::Storage::UserDataPaths::GetForUser(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* UserDataPaths_get_CameraRoll(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CameraRoll();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Cookies(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Cookies();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Desktop(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Desktop();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Documents(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Documents();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Downloads(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Downloads();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Favorites(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Favorites();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_History(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.History();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_InternetCache(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InternetCache();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_LocalAppData(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalAppData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_LocalAppDataLow(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocalAppDataLow();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Music(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Music();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Pictures(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Pictures();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Profile(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Profile();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Recent(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Recent();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_RoamingAppData(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RoamingAppData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_SavedPictures(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SavedPictures();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Screenshots(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Screenshots();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Templates(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Templates();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_get_Videos(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Videos();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __UserDataPaths_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::UserDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef UserDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)UserDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "GetForUser", (PyCFunction)UserDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__UserDataPaths_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef UserDataPaths_getset[] = {
    { const_cast<char*>("CameraRoll"), (getter)UserDataPaths_get_CameraRoll, nullptr, nullptr, nullptr },
    { const_cast<char*>("Cookies"), (getter)UserDataPaths_get_Cookies, nullptr, nullptr, nullptr },
    { const_cast<char*>("Desktop"), (getter)UserDataPaths_get_Desktop, nullptr, nullptr, nullptr },
    { const_cast<char*>("Documents"), (getter)UserDataPaths_get_Documents, nullptr, nullptr, nullptr },
    { const_cast<char*>("Downloads"), (getter)UserDataPaths_get_Downloads, nullptr, nullptr, nullptr },
    { const_cast<char*>("Favorites"), (getter)UserDataPaths_get_Favorites, nullptr, nullptr, nullptr },
    { const_cast<char*>("History"), (getter)UserDataPaths_get_History, nullptr, nullptr, nullptr },
    { const_cast<char*>("InternetCache"), (getter)UserDataPaths_get_InternetCache, nullptr, nullptr, nullptr },
    { const_cast<char*>("LocalAppData"), (getter)UserDataPaths_get_LocalAppData, nullptr, nullptr, nullptr },
    { const_cast<char*>("LocalAppDataLow"), (getter)UserDataPaths_get_LocalAppDataLow, nullptr, nullptr, nullptr },
    { const_cast<char*>("Music"), (getter)UserDataPaths_get_Music, nullptr, nullptr, nullptr },
    { const_cast<char*>("Pictures"), (getter)UserDataPaths_get_Pictures, nullptr, nullptr, nullptr },
    { const_cast<char*>("Profile"), (getter)UserDataPaths_get_Profile, nullptr, nullptr, nullptr },
    { const_cast<char*>("Recent"), (getter)UserDataPaths_get_Recent, nullptr, nullptr, nullptr },
    { const_cast<char*>("RoamingAppData"), (getter)UserDataPaths_get_RoamingAppData, nullptr, nullptr, nullptr },
    { const_cast<char*>("SavedPictures"), (getter)UserDataPaths_get_SavedPictures, nullptr, nullptr, nullptr },
    { const_cast<char*>("Screenshots"), (getter)UserDataPaths_get_Screenshots, nullptr, nullptr, nullptr },
    { const_cast<char*>("Templates"), (getter)UserDataPaths_get_Templates, nullptr, nullptr, nullptr },
    { const_cast<char*>("Videos"), (getter)UserDataPaths_get_Videos, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot UserDataPaths_Type_slots[] = 
{
    { Py_tp_dealloc, UserDataPaths_dealloc },
    { Py_tp_new, UserDataPaths_new },
    { Py_tp_methods, UserDataPaths_methods },
    { Py_tp_getset, UserDataPaths_getset },
    { 0, nullptr },
};

static PyType_Spec UserDataPaths_Type_spec =
{
    "_pyrt_Windows_Storage.UserDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    UserDataPaths_Type_slots
};

// ----- IStorageFile interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type;

PyObject* IStorageFile_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFile interface is not activatable");
    return nullptr;
}

static void IStorageFile_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFile_CopyAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = self->obj.CopyAndReplaceAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_CopyAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            
            auto return_value = self->obj.CopyAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.CopyAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);
            
            auto return_value = self->obj.CopyAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_MoveAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = self->obj.MoveAndReplaceAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_MoveAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            
            auto return_value = self->obj.MoveAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.MoveAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);
            
            auto return_value = self->obj.MoveAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            
            auto return_value = self->obj.OpenAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenSequentialReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenTransactedWriteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ContentType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_get_FileType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FileType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageFile_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageFile>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFile_methods[] = {
    { "CopyAndReplaceAsync", (PyCFunction)IStorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
    { "CopyAsync", (PyCFunction)IStorageFile_CopyAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)IStorageFile_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageFile_IsOfType, METH_VARARGS, nullptr },
    { "MoveAndReplaceAsync", (PyCFunction)IStorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
    { "MoveAsync", (PyCFunction)IStorageFile_MoveAsync, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)IStorageFile_OpenAsync, METH_VARARGS, nullptr },
    { "OpenReadAsync", (PyCFunction)IStorageFile_OpenReadAsync, METH_VARARGS, nullptr },
    { "OpenSequentialReadAsync", (PyCFunction)IStorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)IStorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageFile_RenameAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageFile_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFile_getset[] = {
    { const_cast<char*>("ContentType"), (getter)IStorageFile_get_ContentType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FileType"), (getter)IStorageFile_get_FileType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Attributes"), (getter)IStorageFile_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)IStorageFile_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)IStorageFile_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)IStorageFile_get_Path, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFile_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFile_dealloc },
    { Py_tp_new, IStorageFile_new },
    { Py_tp_methods, IStorageFile_methods },
    { Py_tp_getset, IStorageFile_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFile_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageFile",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFile_Type_slots
};

// ----- IStorageFile2 interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type;

PyObject* IStorageFile2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFile2 interface is not activatable");
    return nullptr;
}

static void IStorageFile2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFile2_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
            
            auto return_value = self->obj.OpenAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFile2_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);
            
            auto return_value = self->obj.OpenTransactedWriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IStorageFile2_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageFile2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFile2_methods[] = {
    { "OpenAsync", (PyCFunction)IStorageFile2_OpenAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)IStorageFile2_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageFile2_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFile2_getset[] = {
    { nullptr }
};

static PyType_Slot IStorageFile2_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFile2_dealloc },
    { Py_tp_new, IStorageFile2_new },
    { Py_tp_methods, IStorageFile2_methods },
    { Py_tp_getset, IStorageFile2_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFile2_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageFile2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFile2_Type_slots
};

// ----- IStorageFilePropertiesWithAvailability interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type;

PyObject* IStorageFilePropertiesWithAvailability_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFilePropertiesWithAvailability interface is not activatable");
    return nullptr;
}

static void IStorageFilePropertiesWithAvailability_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsAvailable();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageFilePropertiesWithAvailability_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFilePropertiesWithAvailability_methods[] = {
    { "_from", (PyCFunction)__IStorageFilePropertiesWithAvailability_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFilePropertiesWithAvailability_getset[] = {
    { const_cast<char*>("IsAvailable"), (getter)IStorageFilePropertiesWithAvailability_get_IsAvailable, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFilePropertiesWithAvailability_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFilePropertiesWithAvailability_dealloc },
    { Py_tp_new, IStorageFilePropertiesWithAvailability_new },
    { Py_tp_methods, IStorageFilePropertiesWithAvailability_methods },
    { Py_tp_getset, IStorageFilePropertiesWithAvailability_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFilePropertiesWithAvailability_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageFilePropertiesWithAvailability",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFilePropertiesWithAvailability_Type_slots
};

// ----- IStorageFolder interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type;

PyObject* IStorageFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolder interface is not activatable");
    return nullptr;
}

static void IStorageFolder_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolder_CreateFileAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.CreateFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = self->obj.CreateFileAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_CreateFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.CreateFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);
            
            auto return_value = self->obj.CreateFolderAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetFileAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetFileAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFilesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetFolderAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFoldersAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetItemAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemsAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolder_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolder_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolder_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolder_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageFolder_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageFolder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFolder_methods[] = {
    { "CreateFileAsync", (PyCFunction)IStorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
    { "CreateFolderAsync", (PyCFunction)IStorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)IStorageFolder_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileAsync", (PyCFunction)IStorageFolder_GetFileAsync, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)IStorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFolderAsync", (PyCFunction)IStorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)IStorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetItemAsync", (PyCFunction)IStorageFolder_GetItemAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)IStorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageFolder_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageFolder_RenameAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageFolder_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFolder_getset[] = {
    { const_cast<char*>("Attributes"), (getter)IStorageFolder_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)IStorageFolder_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)IStorageFolder_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)IStorageFolder_get_Path, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFolder_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFolder_dealloc },
    { Py_tp_new, IStorageFolder_new },
    { Py_tp_methods, IStorageFolder_methods },
    { Py_tp_getset, IStorageFolder_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFolder_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageFolder",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolder_Type_slots
};

// ----- IStorageFolder2 interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type;

PyObject* IStorageFolder2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolder2 interface is not activatable");
    return nullptr;
}

static void IStorageFolder2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolder2_TryGetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.TryGetItemAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IStorageFolder2_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageFolder2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFolder2_methods[] = {
    { "TryGetItemAsync", (PyCFunction)IStorageFolder2_TryGetItemAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageFolder2_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFolder2_getset[] = {
    { nullptr }
};

static PyType_Slot IStorageFolder2_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFolder2_dealloc },
    { Py_tp_new, IStorageFolder2_new },
    { Py_tp_methods, IStorageFolder2_methods },
    { Py_tp_getset, IStorageFolder2_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFolder2_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageFolder2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolder2_Type_slots
};

// ----- IStorageItem interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type;

PyObject* IStorageItem_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItem interface is not activatable");
    return nullptr;
}

static void IStorageItem_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItem_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageItem_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageItem>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageItem_methods[] = {
    { "DeleteAsync", (PyCFunction)IStorageItem_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageItem_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageItem_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageItem_RenameAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageItem_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageItem_getset[] = {
    { const_cast<char*>("Attributes"), (getter)IStorageItem_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)IStorageItem_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)IStorageItem_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)IStorageItem_get_Path, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItem_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageItem_dealloc },
    { Py_tp_new, IStorageItem_new },
    { Py_tp_methods, IStorageItem_methods },
    { Py_tp_getset, IStorageItem_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageItem_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageItem",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItem_Type_slots
};

// ----- IStorageItem2 interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type;

PyObject* IStorageItem2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItem2 interface is not activatable");
    return nullptr;
}

static void IStorageItem2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItem2_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBasicPropertiesAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetParentAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
            
            auto return_value = self->obj.IsEqual(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);
            
            auto return_value = self->obj.IsOfType(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.RenameAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);
            
            auto return_value = self->obj.RenameAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItem2_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Attributes();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem2_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateCreated();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem2_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem2_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageItem2_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageItem2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageItem2_methods[] = {
    { "DeleteAsync", (PyCFunction)IStorageItem2_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageItem2_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetParentAsync", (PyCFunction)IStorageItem2_GetParentAsync, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)IStorageItem2_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageItem2_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageItem2_RenameAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageItem2_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageItem2_getset[] = {
    { const_cast<char*>("Attributes"), (getter)IStorageItem2_get_Attributes, nullptr, nullptr, nullptr },
    { const_cast<char*>("DateCreated"), (getter)IStorageItem2_get_DateCreated, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)IStorageItem2_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)IStorageItem2_get_Path, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItem2_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageItem2_dealloc },
    { Py_tp_new, IStorageItem2_new },
    { Py_tp_methods, IStorageItem2_methods },
    { Py_tp_getset, IStorageItem2_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageItem2_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageItem2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItem2_Type_slots
};

// ----- IStorageItemProperties interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type;

PyObject* IStorageItemProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemProperties interface is not activatable");
    return nullptr;
}

static void IStorageItemProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemProperties_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItemProperties_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderRelativeId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageItemProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageItemProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageItemProperties_methods[] = {
    { "GetThumbnailAsync", (PyCFunction)IStorageItemProperties_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageItemProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageItemProperties_getset[] = {
    { const_cast<char*>("DisplayName"), (getter)IStorageItemProperties_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayType"), (getter)IStorageItemProperties_get_DisplayType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FolderRelativeId"), (getter)IStorageItemProperties_get_FolderRelativeId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)IStorageItemProperties_get_Properties, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemProperties_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageItemProperties_dealloc },
    { Py_tp_new, IStorageItemProperties_new },
    { Py_tp_methods, IStorageItemProperties_methods },
    { Py_tp_getset, IStorageItemProperties_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageItemProperties_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageItemProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemProperties_Type_slots
};

// ----- IStorageItemProperties2 interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type;

PyObject* IStorageItemProperties2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemProperties2 interface is not activatable");
    return nullptr;
}

static void IStorageItemProperties2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItemProperties2_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties2_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderRelativeId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties2_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageItemProperties2_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageItemProperties2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageItemProperties2_methods[] = {
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)IStorageItemProperties2_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IStorageItemProperties2_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageItemProperties2_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageItemProperties2_getset[] = {
    { const_cast<char*>("DisplayName"), (getter)IStorageItemProperties2_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayType"), (getter)IStorageItemProperties2_get_DisplayType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FolderRelativeId"), (getter)IStorageItemProperties2_get_FolderRelativeId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)IStorageItemProperties2_get_Properties, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemProperties2_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageItemProperties2_dealloc },
    { Py_tp_new, IStorageItemProperties2_new },
    { Py_tp_methods, IStorageItemProperties2_methods },
    { Py_tp_getset, IStorageItemProperties2_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageItemProperties2_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageItemProperties2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemProperties2_Type_slots
};

// ----- IStorageItemPropertiesWithProvider interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type;

PyObject* IStorageItemPropertiesWithProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemPropertiesWithProvider interface is not activatable");
    return nullptr;
}

static void IStorageItemPropertiesWithProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            
            auto return_value = self->obj.GetThumbnailAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            auto return_value = self->obj.GetThumbnailAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Provider();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderRelativeId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageItemPropertiesWithProvider_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageItemPropertiesWithProvider_methods[] = {
    { "GetThumbnailAsync", (PyCFunction)IStorageItemPropertiesWithProvider_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageItemPropertiesWithProvider_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageItemPropertiesWithProvider_getset[] = {
    { const_cast<char*>("Provider"), (getter)IStorageItemPropertiesWithProvider_get_Provider, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayName"), (getter)IStorageItemPropertiesWithProvider_get_DisplayName, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayType"), (getter)IStorageItemPropertiesWithProvider_get_DisplayType, nullptr, nullptr, nullptr },
    { const_cast<char*>("FolderRelativeId"), (getter)IStorageItemPropertiesWithProvider_get_FolderRelativeId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)IStorageItemPropertiesWithProvider_get_Properties, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemPropertiesWithProvider_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageItemPropertiesWithProvider_dealloc },
    { Py_tp_new, IStorageItemPropertiesWithProvider_new },
    { Py_tp_methods, IStorageItemPropertiesWithProvider_methods },
    { Py_tp_getset, IStorageItemPropertiesWithProvider_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageItemPropertiesWithProvider_Type_spec =
{
    "_pyrt_Windows_Storage.IStorageItemPropertiesWithProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemPropertiesWithProvider_Type_slots
};

// ----- IStreamedFileDataRequest interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type;

PyObject* IStreamedFileDataRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStreamedFileDataRequest interface is not activatable");
    return nullptr;
}

static void IStreamedFileDataRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStreamedFileDataRequest_FailAndClose(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);
            
            self->obj.FailAndClose(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IStreamedFileDataRequest_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStreamedFileDataRequest_methods[] = {
    { "FailAndClose", (PyCFunction)IStreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStreamedFileDataRequest_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStreamedFileDataRequest_getset[] = {
    { nullptr }
};

static PyType_Slot IStreamedFileDataRequest_Type_slots[] = 
{
    { Py_tp_dealloc, IStreamedFileDataRequest_dealloc },
    { Py_tp_new, IStreamedFileDataRequest_new },
    { Py_tp_methods, IStreamedFileDataRequest_methods },
    { Py_tp_getset, IStreamedFileDataRequest_getset },
    { 0, nullptr },
};

static PyType_Spec IStreamedFileDataRequest_Type_spec =
{
    "_pyrt_Windows_Storage.IStreamedFileDataRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStreamedFileDataRequest_Type_slots
};

// ----- Windows.Storage Initialization --------------------

static int module_exec(PyObject* module)
{
    py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };
    
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&AppDataPaths_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "AppDataPaths", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&ApplicationData_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "ApplicationData", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&ApplicationDataCompositeValue_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "ApplicationDataCompositeValue", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&ApplicationDataContainer_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "ApplicationDataContainer", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&ApplicationDataContainerSettings_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "ApplicationDataContainerSettings", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&CachedFileManager_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "CachedFileManager", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&DownloadsFolder_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "DownloadsFolder", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&FileIO_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "FileIO", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::FileIO>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&KnownFolders_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "KnownFolders", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&PathIO_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "PathIO", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::PathIO>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SetVersionDeferral_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SetVersionDeferral", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SetVersionRequest_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SetVersionRequest", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageFile_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageFile", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageFolder_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageFolder", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageLibrary_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageLibrary", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageLibraryChange_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageLibraryChange", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageLibraryChangeReader_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageLibraryChangeReader", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageLibraryChangeTracker_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageLibraryChangeTracker", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageProvider_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageProvider", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StorageStreamTransaction_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StorageStreamTransaction", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&StreamedFileDataRequest_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "StreamedFileDataRequest", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemAudioProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemAudioProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemDataPaths_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemDataPaths", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemGPSProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemGPSProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemImageProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemImageProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemMediaProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemMediaProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemMusicProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemMusicProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemPhotoProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemPhotoProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&SystemProperties_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&SystemVideoProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "SystemVideoProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&UserDataPaths_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "UserDataPaths", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageFile_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageFile", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageFile2_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageFile2", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageFilePropertiesWithAvailability_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageFilePropertiesWithAvailability", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageFolder_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageFolder", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageFolder2_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageFolder2", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageItem_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageItem", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageItem2_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageItem2", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageItemProperties_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageItemProperties", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageItemProperties2_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageItemProperties2", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStorageItemPropertiesWithProvider_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStorageItemPropertiesWithProvider", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IStreamedFileDataRequest_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IStreamedFileDataRequest", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Storage");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Storage",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Storage(void)
{
    return PyModuleDef_Init(&module_def);
}
