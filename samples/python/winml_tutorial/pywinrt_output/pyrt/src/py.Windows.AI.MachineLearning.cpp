// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.AI.MachineLearning.h"

// ----- ImageFeatureDescriptor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type;

static PyObject* ImageFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageFeatureDescriptor is not activatable");
    return nullptr;
}

static void ImageFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_Height(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Height();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_Width(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Width();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRequired();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ImageFeatureDescriptor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ImageFeatureDescriptor_methods[] = {
    { "_from", (PyCFunction)__ImageFeatureDescriptor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ImageFeatureDescriptor_getset[] = {
    { const_cast<char*>("BitmapAlphaMode"), (getter)ImageFeatureDescriptor_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)ImageFeatureDescriptor_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)ImageFeatureDescriptor_get_Height, nullptr, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)ImageFeatureDescriptor_get_Width, nullptr, nullptr, nullptr },
    { const_cast<char*>("Description"), (getter)ImageFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsRequired"), (getter)ImageFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)ImageFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)ImageFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ImageFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_dealloc, ImageFeatureDescriptor_dealloc },
    { Py_tp_new, ImageFeatureDescriptor_new },
    { Py_tp_methods, ImageFeatureDescriptor_methods },
    { Py_tp_getset, ImageFeatureDescriptor_getset },
    { 0, nullptr },
};

static PyType_Spec ImageFeatureDescriptor_Type_spec =
{
    "ImageFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageFeatureDescriptor_Type_slots
};

// ----- ImageFeatureValue class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type;

static PyObject* ImageFeatureValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageFeatureValue is not activatable");
    return nullptr;
}

static void ImageFeatureValue_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageFeatureValue_get_VideoFrame(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VideoFrame();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureValue_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ImageFeatureValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ImageFeatureValue_methods[] = {
    { "CreateFromVideoFrame", (PyCFunction)ImageFeatureValue_CreateFromVideoFrame, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__ImageFeatureValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ImageFeatureValue_getset[] = {
    { const_cast<char*>("VideoFrame"), (getter)ImageFeatureValue_get_VideoFrame, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)ImageFeatureValue_get_Kind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ImageFeatureValue_Type_slots[] = 
{
    { Py_tp_dealloc, ImageFeatureValue_dealloc },
    { Py_tp_new, ImageFeatureValue_new },
    { Py_tp_methods, ImageFeatureValue_methods },
    { Py_tp_getset, ImageFeatureValue_getset },
    { 0, nullptr },
};

static PyType_Spec ImageFeatureValue_Type_spec =
{
    "ImageFeatureValue",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageFeatureValue_Type_slots
};

// ----- LearningModel class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type;

static PyObject* LearningModel_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "LearningModel is not activatable");
    return nullptr;
}

static void LearningModel_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModel_Close(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModel_get_Author(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Author();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_Domain(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Domain();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_InputFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InputFeatures();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_Metadata(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Metadata();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_OutputFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OutputFeatures();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_get_Version(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Version();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModel_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModel>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModel_enter(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __LearningModel_exit(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef LearningModel_methods[] = {
    { "Close", (PyCFunction)LearningModel_Close, METH_VARARGS, nullptr },
    { "LoadFromFilePath", (PyCFunction)LearningModel_LoadFromFilePath, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStorageFileAsync", (PyCFunction)LearningModel_LoadFromStorageFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStream", (PyCFunction)LearningModel_LoadFromStream, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStreamAsync", (PyCFunction)LearningModel_LoadFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__LearningModel_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__LearningModel_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__LearningModel_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef LearningModel_getset[] = {
    { const_cast<char*>("Author"), (getter)LearningModel_get_Author, nullptr, nullptr, nullptr },
    { const_cast<char*>("Description"), (getter)LearningModel_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("Domain"), (getter)LearningModel_get_Domain, nullptr, nullptr, nullptr },
    { const_cast<char*>("InputFeatures"), (getter)LearningModel_get_InputFeatures, nullptr, nullptr, nullptr },
    { const_cast<char*>("Metadata"), (getter)LearningModel_get_Metadata, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)LearningModel_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("OutputFeatures"), (getter)LearningModel_get_OutputFeatures, nullptr, nullptr, nullptr },
    { const_cast<char*>("Version"), (getter)LearningModel_get_Version, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot LearningModel_Type_slots[] = 
{
    { Py_tp_dealloc, LearningModel_dealloc },
    { Py_tp_new, LearningModel_new },
    { Py_tp_methods, LearningModel_methods },
    { Py_tp_getset, LearningModel_getset },
    { 0, nullptr },
};

static PyType_Spec LearningModel_Type_spec =
{
    "LearningModel",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModel_Type_slots
};

// ----- LearningModelBinding class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type;

static PyObject* LearningModelBinding_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);
            
            winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void LearningModelBinding_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelBinding_Bind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
            
            self->obj.Bind(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);
            
            self->obj.Bind(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_Clear(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_First(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_HasKey(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.HasKey(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_Lookup(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.Lookup(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_Split(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };
            
            self->obj.Split(param0, param1);
            
            PyObject* out0 = py::convert(param0);
            if (!out0) 
            {
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out0, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelBinding_get_Size(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelBinding_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelBinding_iter(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __LearningModelBinding_mp_length(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __LearningModelBinding_mp_subscript(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* key)
{
    try
    {
        return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef LearningModelBinding_methods[] = {
    { "Bind", (PyCFunction)LearningModelBinding_Bind, METH_VARARGS, nullptr },
    { "Clear", (PyCFunction)LearningModelBinding_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)LearningModelBinding_First, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)LearningModelBinding_HasKey, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)LearningModelBinding_Lookup, METH_VARARGS, nullptr },
    { "Split", (PyCFunction)LearningModelBinding_Split, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__LearningModelBinding_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef LearningModelBinding_getset[] = {
    { const_cast<char*>("Size"), (getter)LearningModelBinding_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelBinding_Type_slots[] = 
{
    { Py_tp_dealloc, LearningModelBinding_dealloc },
    { Py_tp_new, LearningModelBinding_new },
    { Py_tp_methods, LearningModelBinding_methods },
    { Py_tp_getset, LearningModelBinding_getset },
    { Py_tp_iter, __LearningModelBinding_iter },
    { Py_mp_length, __LearningModelBinding_mp_length },
    { Py_mp_subscript, __LearningModelBinding_mp_subscript },
    { 0, nullptr },
};

static PyType_Spec LearningModelBinding_Type_spec =
{
    "LearningModelBinding",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelBinding_Type_slots
};

// ----- LearningModelDevice class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type;

static PyObject* LearningModelDevice_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);
            
            winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void LearningModelDevice_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelDevice_get_AdapterId(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AdapterId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelDevice_get_Direct3D11Device(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Direct3D11Device();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelDevice_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef LearningModelDevice_methods[] = {
    { "CreateFromDirect3D11Device", (PyCFunction)LearningModelDevice_CreateFromDirect3D11Device, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__LearningModelDevice_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef LearningModelDevice_getset[] = {
    { const_cast<char*>("AdapterId"), (getter)LearningModelDevice_get_AdapterId, nullptr, nullptr, nullptr },
    { const_cast<char*>("Direct3D11Device"), (getter)LearningModelDevice_get_Direct3D11Device, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelDevice_Type_slots[] = 
{
    { Py_tp_dealloc, LearningModelDevice_dealloc },
    { Py_tp_new, LearningModelDevice_new },
    { Py_tp_methods, LearningModelDevice_methods },
    { Py_tp_getset, LearningModelDevice_getset },
    { 0, nullptr },
};

static PyType_Spec LearningModelDevice_Type_spec =
{
    "LearningModelDevice",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelDevice_Type_slots
};

// ----- LearningModelEvaluationResult class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type;

static PyObject* LearningModelEvaluationResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "LearningModelEvaluationResult is not activatable");
    return nullptr;
}

static void LearningModelEvaluationResult_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CorrelationId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ErrorStatus();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelEvaluationResult_get_Outputs(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Outputs();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelEvaluationResult_get_Succeeded(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Succeeded();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelEvaluationResult_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef LearningModelEvaluationResult_methods[] = {
    { "_from", (PyCFunction)__LearningModelEvaluationResult_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef LearningModelEvaluationResult_getset[] = {
    { const_cast<char*>("CorrelationId"), (getter)LearningModelEvaluationResult_get_CorrelationId, nullptr, nullptr, nullptr },
    { const_cast<char*>("ErrorStatus"), (getter)LearningModelEvaluationResult_get_ErrorStatus, nullptr, nullptr, nullptr },
    { const_cast<char*>("Outputs"), (getter)LearningModelEvaluationResult_get_Outputs, nullptr, nullptr, nullptr },
    { const_cast<char*>("Succeeded"), (getter)LearningModelEvaluationResult_get_Succeeded, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelEvaluationResult_Type_slots[] = 
{
    { Py_tp_dealloc, LearningModelEvaluationResult_dealloc },
    { Py_tp_new, LearningModelEvaluationResult_new },
    { Py_tp_methods, LearningModelEvaluationResult_methods },
    { Py_tp_getset, LearningModelEvaluationResult_getset },
    { 0, nullptr },
};

static PyType_Spec LearningModelEvaluationResult_Type_spec =
{
    "LearningModelEvaluationResult",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelEvaluationResult_Type_slots
};

// ----- LearningModelSession class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type;

static PyObject* LearningModelSession_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
            
            winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
            
            winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void LearningModelSession_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelSession_Close(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelSession_Evaluate(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.Evaluate(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateAsync(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.EvaluateAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.EvaluateFeatures(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.EvaluateFeaturesAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* LearningModelSession_get_Device(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Device();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelSession_get_EvaluationProperties(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.EvaluationProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelSession_get_Model(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Model();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelSession_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __LearningModelSession_enter(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __LearningModelSession_exit(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef LearningModelSession_methods[] = {
    { "Close", (PyCFunction)LearningModelSession_Close, METH_VARARGS, nullptr },
    { "Evaluate", (PyCFunction)LearningModelSession_Evaluate, METH_VARARGS, nullptr },
    { "EvaluateAsync", (PyCFunction)LearningModelSession_EvaluateAsync, METH_VARARGS, nullptr },
    { "EvaluateFeatures", (PyCFunction)LearningModelSession_EvaluateFeatures, METH_VARARGS, nullptr },
    { "EvaluateFeaturesAsync", (PyCFunction)LearningModelSession_EvaluateFeaturesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__LearningModelSession_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__LearningModelSession_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__LearningModelSession_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef LearningModelSession_getset[] = {
    { const_cast<char*>("Device"), (getter)LearningModelSession_get_Device, nullptr, nullptr, nullptr },
    { const_cast<char*>("EvaluationProperties"), (getter)LearningModelSession_get_EvaluationProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("Model"), (getter)LearningModelSession_get_Model, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelSession_Type_slots[] = 
{
    { Py_tp_dealloc, LearningModelSession_dealloc },
    { Py_tp_new, LearningModelSession_new },
    { Py_tp_methods, LearningModelSession_methods },
    { Py_tp_getset, LearningModelSession_getset },
    { 0, nullptr },
};

static PyType_Spec LearningModelSession_Type_spec =
{
    "LearningModelSession",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelSession_Type_slots
};

// ----- MapFeatureDescriptor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type;

static PyObject* MapFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MapFeatureDescriptor is not activatable");
    return nullptr;
}

static void MapFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MapFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRequired();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_KeyKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.KeyKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ValueDescriptor();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __MapFeatureDescriptor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef MapFeatureDescriptor_methods[] = {
    { "_from", (PyCFunction)__MapFeatureDescriptor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef MapFeatureDescriptor_getset[] = {
    { const_cast<char*>("Description"), (getter)MapFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsRequired"), (getter)MapFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)MapFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)MapFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("KeyKind"), (getter)MapFeatureDescriptor_get_KeyKind, nullptr, nullptr, nullptr },
    { const_cast<char*>("ValueDescriptor"), (getter)MapFeatureDescriptor_get_ValueDescriptor, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot MapFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_dealloc, MapFeatureDescriptor_dealloc },
    { Py_tp_new, MapFeatureDescriptor_new },
    { Py_tp_methods, MapFeatureDescriptor_methods },
    { Py_tp_getset, MapFeatureDescriptor_getset },
    { 0, nullptr },
};

static PyType_Spec MapFeatureDescriptor_Type_spec =
{
    "MapFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    MapFeatureDescriptor_Type_slots
};

// ----- SequenceFeatureDescriptor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type;

static PyObject* SequenceFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SequenceFeatureDescriptor is not activatable");
    return nullptr;
}

static void SequenceFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SequenceFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRequired();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SequenceFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SequenceFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ElementDescriptor();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SequenceFeatureDescriptor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SequenceFeatureDescriptor_methods[] = {
    { "_from", (PyCFunction)__SequenceFeatureDescriptor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SequenceFeatureDescriptor_getset[] = {
    { const_cast<char*>("Description"), (getter)SequenceFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsRequired"), (getter)SequenceFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)SequenceFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)SequenceFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("ElementDescriptor"), (getter)SequenceFeatureDescriptor_get_ElementDescriptor, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SequenceFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_dealloc, SequenceFeatureDescriptor_dealloc },
    { Py_tp_new, SequenceFeatureDescriptor_new },
    { Py_tp_methods, SequenceFeatureDescriptor_methods },
    { Py_tp_getset, SequenceFeatureDescriptor_getset },
    { 0, nullptr },
};

static PyType_Spec SequenceFeatureDescriptor_Type_spec =
{
    "SequenceFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    SequenceFeatureDescriptor_Type_slots
};

// ----- TensorBoolean class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type;

static PyObject* TensorBoolean_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorBoolean is not activatable");
    return nullptr;
}

static void TensorBoolean_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<bool>>(args, 1);
            auto param1 = winrt::array_view<const bool>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorBoolean_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorBoolean_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorBoolean_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorBoolean_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorBoolean_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorBoolean_methods[] = {
    { "Create", (PyCFunction)TensorBoolean_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorBoolean_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorBoolean_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorBoolean_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorBoolean_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorBoolean_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorBoolean_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorBoolean_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorBoolean_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorBoolean_Type_slots[] = 
{
    { Py_tp_dealloc, TensorBoolean_dealloc },
    { Py_tp_new, TensorBoolean_new },
    { Py_tp_methods, TensorBoolean_methods },
    { Py_tp_getset, TensorBoolean_getset },
    { 0, nullptr },
};

static PyType_Spec TensorBoolean_Type_spec =
{
    "TensorBoolean",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorBoolean_Type_slots
};

// ----- TensorDouble class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type;

static PyObject* TensorDouble_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorDouble is not activatable");
    return nullptr;
}

static void TensorDouble_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorDouble::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<double>>(args, 1);
            auto param1 = winrt::array_view<const double>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorDouble_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorDouble_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorDouble_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorDouble_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorDouble_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorDouble_methods[] = {
    { "Create", (PyCFunction)TensorDouble_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorDouble_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorDouble_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorDouble_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorDouble_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorDouble_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorDouble_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorDouble_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorDouble_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorDouble_Type_slots[] = 
{
    { Py_tp_dealloc, TensorDouble_dealloc },
    { Py_tp_new, TensorDouble_new },
    { Py_tp_methods, TensorDouble_methods },
    { Py_tp_getset, TensorDouble_getset },
    { 0, nullptr },
};

static PyType_Spec TensorDouble_Type_spec =
{
    "TensorDouble",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorDouble_Type_slots
};

// ----- TensorFeatureDescriptor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type;

static PyObject* TensorFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFeatureDescriptor is not activatable");
    return nullptr;
}

static void TensorFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRequired();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorFeatureDescriptor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorFeatureDescriptor_methods[] = {
    { "_from", (PyCFunction)__TensorFeatureDescriptor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorFeatureDescriptor_getset[] = {
    { const_cast<char*>("Description"), (getter)TensorFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsRequired"), (getter)TensorFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)TensorFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)TensorFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorFeatureDescriptor_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorFeatureDescriptor_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_dealloc, TensorFeatureDescriptor_dealloc },
    { Py_tp_new, TensorFeatureDescriptor_new },
    { Py_tp_methods, TensorFeatureDescriptor_methods },
    { Py_tp_getset, TensorFeatureDescriptor_getset },
    { 0, nullptr },
};

static PyType_Spec TensorFeatureDescriptor_Type_spec =
{
    "TensorFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFeatureDescriptor_Type_slots
};

// ----- TensorFloat class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type;

static PyObject* TensorFloat_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFloat is not activatable");
    return nullptr;
}

static void TensorFloat_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<float>>(args, 1);
            auto param1 = winrt::array_view<const float>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorFloat_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorFloat_methods[] = {
    { "Create", (PyCFunction)TensorFloat_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorFloat_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorFloat_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorFloat_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorFloat_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorFloat_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorFloat_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorFloat_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorFloat_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorFloat_Type_slots[] = 
{
    { Py_tp_dealloc, TensorFloat_dealloc },
    { Py_tp_new, TensorFloat_new },
    { Py_tp_methods, TensorFloat_methods },
    { Py_tp_getset, TensorFloat_getset },
    { 0, nullptr },
};

static PyType_Spec TensorFloat_Type_spec =
{
    "TensorFloat",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFloat_Type_slots
};

// ----- TensorFloat16Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type;

static PyObject* TensorFloat16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFloat16Bit is not activatable");
    return nullptr;
}

static void TensorFloat16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<float>>(args, 1);
            auto param1 = winrt::array_view<const float>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorFloat16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorFloat16Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorFloat16Bit_methods[] = {
    { "Create", (PyCFunction)TensorFloat16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorFloat16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorFloat16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorFloat16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorFloat16Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorFloat16Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorFloat16Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorFloat16Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorFloat16Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorFloat16Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorFloat16Bit_dealloc },
    { Py_tp_new, TensorFloat16Bit_new },
    { Py_tp_methods, TensorFloat16Bit_methods },
    { Py_tp_getset, TensorFloat16Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorFloat16Bit_Type_spec =
{
    "TensorFloat16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFloat16Bit_Type_slots
};

// ----- TensorInt16Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type;

static PyObject* TensorInt16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt16Bit is not activatable");
    return nullptr;
}

static void TensorInt16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<int16_t>>(args, 1);
            auto param1 = winrt::array_view<const int16_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorInt16Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorInt16Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorInt16Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorInt16Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorInt16Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorInt16Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorInt16Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt16Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorInt16Bit_dealloc },
    { Py_tp_new, TensorInt16Bit_new },
    { Py_tp_methods, TensorInt16Bit_methods },
    { Py_tp_getset, TensorInt16Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorInt16Bit_Type_spec =
{
    "TensorInt16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt16Bit_Type_slots
};

// ----- TensorInt32Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type;

static PyObject* TensorInt32Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt32Bit is not activatable");
    return nullptr;
}

static void TensorInt32Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<int32_t>>(args, 1);
            auto param1 = winrt::array_view<const int32_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt32Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt32Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt32Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt32Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorInt32Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorInt32Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorInt32Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorInt32Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorInt32Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorInt32Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorInt32Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt32Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorInt32Bit_dealloc },
    { Py_tp_new, TensorInt32Bit_new },
    { Py_tp_methods, TensorInt32Bit_methods },
    { Py_tp_getset, TensorInt32Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorInt32Bit_Type_spec =
{
    "TensorInt32Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt32Bit_Type_slots
};

// ----- TensorInt64Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type;

static PyObject* TensorInt64Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt64Bit is not activatable");
    return nullptr;
}

static void TensorInt64Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<int64_t>>(args, 1);
            auto param1 = winrt::array_view<const int64_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt64Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt64Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt64Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt64Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorInt64Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorInt64Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorInt64Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorInt64Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorInt64Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorInt64Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorInt64Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt64Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorInt64Bit_dealloc },
    { Py_tp_new, TensorInt64Bit_new },
    { Py_tp_methods, TensorInt64Bit_methods },
    { Py_tp_getset, TensorInt64Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorInt64Bit_Type_spec =
{
    "TensorInt64Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt64Bit_Type_slots
};

// ----- TensorInt8Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type;

static PyObject* TensorInt8Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt8Bit is not activatable");
    return nullptr;
}

static void TensorInt8Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint8_t>>(args, 1);
            auto param1 = winrt::array_view<const uint8_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt8Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorInt8Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt8Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt8Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorInt8Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorInt8Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorInt8Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorInt8Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorInt8Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorInt8Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorInt8Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt8Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorInt8Bit_dealloc },
    { Py_tp_new, TensorInt8Bit_new },
    { Py_tp_methods, TensorInt8Bit_methods },
    { Py_tp_getset, TensorInt8Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorInt8Bit_Type_spec =
{
    "TensorInt8Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt8Bit_Type_slots
};

// ----- TensorString class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type;

static PyObject* TensorString_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorString is not activatable");
    return nullptr;
}

static void TensorString_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorString::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorString::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<winrt::hstring>>(args, 1);
            auto param1 = winrt::array_view<const winrt::hstring>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorString_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorString_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorString_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorString_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorString_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorString>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorString_methods[] = {
    { "Create", (PyCFunction)TensorString_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorString_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorString_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorString_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorString_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorString_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorString_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorString_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorString_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorString_Type_slots[] = 
{
    { Py_tp_dealloc, TensorString_dealloc },
    { Py_tp_new, TensorString_new },
    { Py_tp_methods, TensorString_methods },
    { Py_tp_getset, TensorString_getset },
    { 0, nullptr },
};

static PyType_Spec TensorString_Type_spec =
{
    "TensorString",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorString_Type_slots
};

// ----- TensorUInt16Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type;

static PyObject* TensorUInt16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt16Bit is not activatable");
    return nullptr;
}

static void TensorUInt16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint16_t>>(args, 1);
            auto param1 = winrt::array_view<const uint16_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorUInt16Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorUInt16Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorUInt16Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorUInt16Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorUInt16Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorUInt16Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorUInt16Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt16Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorUInt16Bit_dealloc },
    { Py_tp_new, TensorUInt16Bit_new },
    { Py_tp_methods, TensorUInt16Bit_methods },
    { Py_tp_getset, TensorUInt16Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorUInt16Bit_Type_spec =
{
    "TensorUInt16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt16Bit_Type_slots
};

// ----- TensorUInt32Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type;

static PyObject* TensorUInt32Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt32Bit is not activatable");
    return nullptr;
}

static void TensorUInt32Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint32_t>>(args, 1);
            auto param1 = winrt::array_view<const uint32_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt32Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt32Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt32Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt32Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorUInt32Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorUInt32Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorUInt32Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorUInt32Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorUInt32Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorUInt32Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorUInt32Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt32Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorUInt32Bit_dealloc },
    { Py_tp_new, TensorUInt32Bit_new },
    { Py_tp_methods, TensorUInt32Bit_methods },
    { Py_tp_getset, TensorUInt32Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorUInt32Bit_Type_spec =
{
    "TensorUInt32Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt32Bit_Type_slots
};

// ----- TensorUInt64Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type;

static PyObject* TensorUInt64Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt64Bit is not activatable");
    return nullptr;
}

static void TensorUInt64Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint64_t>>(args, 1);
            auto param1 = winrt::array_view<const uint64_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt64Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt64Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt64Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt64Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorUInt64Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorUInt64Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorUInt64Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorUInt64Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorUInt64Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorUInt64Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorUInt64Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt64Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorUInt64Bit_dealloc },
    { Py_tp_new, TensorUInt64Bit_new },
    { Py_tp_methods, TensorUInt64Bit_methods },
    { Py_tp_getset, TensorUInt64Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorUInt64Bit_Type_spec =
{
    "TensorUInt64Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt64Bit_Type_slots
};

// ----- TensorUInt8Bit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type;

static PyObject* TensorUInt8Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt8Bit is not activatable");
    return nullptr;
}

static void TensorUInt8Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto _param1 = py::convert_to<winrt::com_array<uint8_t>>(args, 1);
            auto param1 = winrt::array_view<const uint8_t>(_param1.begin(), _param1.end());
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);
            
            auto return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt8Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsVectorView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* TensorUInt8Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt8Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt8Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __TensorUInt8Bit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef TensorUInt8Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__TensorUInt8Bit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef TensorUInt8Bit_getset[] = {
    { const_cast<char*>("Kind"), (getter)TensorUInt8Bit_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Shape"), (getter)TensorUInt8Bit_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)TensorUInt8Bit_get_TensorKind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt8Bit_Type_slots[] = 
{
    { Py_tp_dealloc, TensorUInt8Bit_dealloc },
    { Py_tp_new, TensorUInt8Bit_new },
    { Py_tp_methods, TensorUInt8Bit_methods },
    { Py_tp_getset, TensorUInt8Bit_getset },
    { 0, nullptr },
};

static PyType_Spec TensorUInt8Bit_Type_spec =
{
    "TensorUInt8Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt8Bit_Type_slots
};

// ----- ILearningModelFeatureDescriptor interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type;

PyObject* ILearningModelFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelFeatureDescriptor interface is not activatable");
    return nullptr;
}

static void ILearningModelFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ILearningModelFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Description();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsRequired();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ILearningModelFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ILearningModelFeatureDescriptor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ILearningModelFeatureDescriptor_methods[] = {
    { "_from", (PyCFunction)__ILearningModelFeatureDescriptor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ILearningModelFeatureDescriptor_getset[] = {
    { const_cast<char*>("Description"), (getter)ILearningModelFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsRequired"), (getter)ILearningModelFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)ILearningModelFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Name"), (getter)ILearningModelFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ILearningModelFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_dealloc, ILearningModelFeatureDescriptor_dealloc },
    { Py_tp_new, ILearningModelFeatureDescriptor_new },
    { Py_tp_methods, ILearningModelFeatureDescriptor_methods },
    { Py_tp_getset, ILearningModelFeatureDescriptor_getset },
    { 0, nullptr },
};

static PyType_Spec ILearningModelFeatureDescriptor_Type_spec =
{
    "ILearningModelFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelFeatureDescriptor_Type_slots
};

// ----- ILearningModelFeatureValue interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type;

PyObject* ILearningModelFeatureValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelFeatureValue interface is not activatable");
    return nullptr;
}

static void ILearningModelFeatureValue_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ILearningModelFeatureValue_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ILearningModelFeatureValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ILearningModelFeatureValue_methods[] = {
    { "_from", (PyCFunction)__ILearningModelFeatureValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ILearningModelFeatureValue_getset[] = {
    { const_cast<char*>("Kind"), (getter)ILearningModelFeatureValue_get_Kind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ILearningModelFeatureValue_Type_slots[] = 
{
    { Py_tp_dealloc, ILearningModelFeatureValue_dealloc },
    { Py_tp_new, ILearningModelFeatureValue_new },
    { Py_tp_methods, ILearningModelFeatureValue_methods },
    { Py_tp_getset, ILearningModelFeatureValue_getset },
    { 0, nullptr },
};

static PyType_Spec ILearningModelFeatureValue_Type_spec =
{
    "ILearningModelFeatureValue",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelFeatureValue_Type_slots
};

// ----- ILearningModelOperatorProvider interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type;

PyObject* ILearningModelOperatorProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelOperatorProvider interface is not activatable");
    return nullptr;
}

static void ILearningModelOperatorProvider_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* __ILearningModelOperatorProvider_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ILearningModelOperatorProvider_methods[] = {
    { "_from", (PyCFunction)__ILearningModelOperatorProvider_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ILearningModelOperatorProvider_getset[] = {
    { nullptr }
};

static PyType_Slot ILearningModelOperatorProvider_Type_slots[] = 
{
    { Py_tp_dealloc, ILearningModelOperatorProvider_dealloc },
    { Py_tp_new, ILearningModelOperatorProvider_new },
    { Py_tp_methods, ILearningModelOperatorProvider_methods },
    { Py_tp_getset, ILearningModelOperatorProvider_getset },
    { 0, nullptr },
};

static PyType_Spec ILearningModelOperatorProvider_Type_spec =
{
    "ILearningModelOperatorProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelOperatorProvider_Type_slots
};

// ----- ITensor interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type;

PyObject* ITensor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ITensor interface is not activatable");
    return nullptr;
}

static void ITensor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ITensor_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Shape();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ITensor_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.TensorKind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ITensor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Kind();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ITensor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::AI::MachineLearning::ITensor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ITensor_methods[] = {
    { "_from", (PyCFunction)__ITensor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ITensor_getset[] = {
    { const_cast<char*>("Shape"), (getter)ITensor_get_Shape, nullptr, nullptr, nullptr },
    { const_cast<char*>("TensorKind"), (getter)ITensor_get_TensorKind, nullptr, nullptr, nullptr },
    { const_cast<char*>("Kind"), (getter)ITensor_get_Kind, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ITensor_Type_slots[] = 
{
    { Py_tp_dealloc, ITensor_dealloc },
    { Py_tp_new, ITensor_new },
    { Py_tp_methods, ITensor_methods },
    { Py_tp_getset, ITensor_getset },
    { 0, nullptr },
};

static PyType_Spec ITensor_Type_spec =
{
    "ITensor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ITensor_Type_slots
};

// ----- Windows.AI.MachineLearning Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&ImageFeatureDescriptor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageFeatureDescriptor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ImageFeatureValue_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageFeatureValue", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&LearningModel_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModel", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&LearningModelBinding_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelBinding", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&LearningModelDevice_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelDevice", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&LearningModelEvaluationResult_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelEvaluationResult", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&LearningModelSession_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelSession", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&MapFeatureDescriptor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MapFeatureDescriptor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SequenceFeatureDescriptor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SequenceFeatureDescriptor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorBoolean_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorBoolean", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorDouble_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorDouble", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorFeatureDescriptor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFeatureDescriptor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorFloat_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFloat", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorFloat16Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFloat16Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorInt16Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt16Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorInt32Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt32Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorInt64Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt64Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorInt8Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt8Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorString_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorString", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorUInt16Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt16Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorUInt32Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt32Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorUInt64Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt64Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&TensorUInt8Bit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt8Bit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ILearningModelFeatureDescriptor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelFeatureDescriptor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ILearningModelFeatureValue_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelFeatureValue", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ILearningModelOperatorProvider_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelOperatorProvider", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ITensor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ITensor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.AI.MachineLearning");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_AI_MachineLearning",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_AI_MachineLearning(void)
{
    return PyModuleDef_Init(&module_def);
}
