// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.Streams.h"

// ----- Buffer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type;

static PyObject* Buffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            winrt::Windows::Storage::Streams::Buffer instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void Buffer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Buffer_CreateCopyFromMemoryBuffer(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::Buffer::CreateCopyFromMemoryBuffer(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Buffer_CreateMemoryBufferOverIBuffer(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::Buffer::CreateMemoryBufferOverIBuffer(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Buffer_get_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Length();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Buffer_put_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.Length(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Buffer_get_Capacity(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Capacity();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Buffer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::Buffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Buffer_methods[] = {
    { "CreateCopyFromMemoryBuffer", (PyCFunction)Buffer_CreateCopyFromMemoryBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateMemoryBufferOverIBuffer", (PyCFunction)Buffer_CreateMemoryBufferOverIBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__Buffer_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Buffer_getset[] = {
    { const_cast<char*>("Length"), (getter)Buffer_get_Length, (setter)Buffer_put_Length, nullptr, nullptr },
    { const_cast<char*>("Capacity"), (getter)Buffer_get_Capacity, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Buffer_Type_slots[] = 
{
    { Py_tp_dealloc, Buffer_dealloc },
    { Py_tp_new, Buffer_new },
    { Py_tp_methods, Buffer_methods },
    { Py_tp_getset, Buffer_getset },
    { 0, nullptr },
};

static PyType_Spec Buffer_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.Buffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    Buffer_Type_slots
};

// ----- DataReader class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type;

static PyObject* DataReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            
            winrt::Windows::Storage::Streams::DataReader instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void DataReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataReader_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachBuffer();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_FromBuffer(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::DataReader::FromBuffer(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_LoadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.LoadAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadBoolean();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.ReadBuffer(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadByte();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 0);
            winrt::com_array<uint8_t> param0 ( param0_count, py::empty_instance<uint8_t>::get() );
            
            self->obj.ReadBytes(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            
            return out0.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadDateTime();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadDouble();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadGuid();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadSingle();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.ReadString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadTimeSpan();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_ReadUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReader_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnicodeEncoding();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataReader_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);
        
        self->obj.UnicodeEncoding(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* DataReader_get_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InputStreamOptions();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataReader_put_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);
        
        self->obj.InputStreamOptions(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* DataReader_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ByteOrder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataReader_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);
        
        self->obj.ByteOrder(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* DataReader_get_UnconsumedBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnconsumedBufferLength();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __DataReader_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::DataReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __DataReader_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __DataReader_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef DataReader_methods[] = {
    { "Close", (PyCFunction)DataReader_Close, METH_VARARGS, nullptr },
    { "DetachBuffer", (PyCFunction)DataReader_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)DataReader_DetachStream, METH_VARARGS, nullptr },
    { "FromBuffer", (PyCFunction)DataReader_FromBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadAsync", (PyCFunction)DataReader_LoadAsync, METH_VARARGS, nullptr },
    { "ReadBoolean", (PyCFunction)DataReader_ReadBoolean, METH_VARARGS, nullptr },
    { "ReadBuffer", (PyCFunction)DataReader_ReadBuffer, METH_VARARGS, nullptr },
    { "ReadByte", (PyCFunction)DataReader_ReadByte, METH_VARARGS, nullptr },
    { "ReadBytes", (PyCFunction)DataReader_ReadBytes, METH_VARARGS, nullptr },
    { "ReadDateTime", (PyCFunction)DataReader_ReadDateTime, METH_VARARGS, nullptr },
    { "ReadDouble", (PyCFunction)DataReader_ReadDouble, METH_VARARGS, nullptr },
    { "ReadGuid", (PyCFunction)DataReader_ReadGuid, METH_VARARGS, nullptr },
    { "ReadInt16", (PyCFunction)DataReader_ReadInt16, METH_VARARGS, nullptr },
    { "ReadInt32", (PyCFunction)DataReader_ReadInt32, METH_VARARGS, nullptr },
    { "ReadInt64", (PyCFunction)DataReader_ReadInt64, METH_VARARGS, nullptr },
    { "ReadSingle", (PyCFunction)DataReader_ReadSingle, METH_VARARGS, nullptr },
    { "ReadString", (PyCFunction)DataReader_ReadString, METH_VARARGS, nullptr },
    { "ReadTimeSpan", (PyCFunction)DataReader_ReadTimeSpan, METH_VARARGS, nullptr },
    { "ReadUInt16", (PyCFunction)DataReader_ReadUInt16, METH_VARARGS, nullptr },
    { "ReadUInt32", (PyCFunction)DataReader_ReadUInt32, METH_VARARGS, nullptr },
    { "ReadUInt64", (PyCFunction)DataReader_ReadUInt64, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__DataReader_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__DataReader_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__DataReader_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef DataReader_getset[] = {
    { const_cast<char*>("UnicodeEncoding"), (getter)DataReader_get_UnicodeEncoding, (setter)DataReader_put_UnicodeEncoding, nullptr, nullptr },
    { const_cast<char*>("InputStreamOptions"), (getter)DataReader_get_InputStreamOptions, (setter)DataReader_put_InputStreamOptions, nullptr, nullptr },
    { const_cast<char*>("ByteOrder"), (getter)DataReader_get_ByteOrder, (setter)DataReader_put_ByteOrder, nullptr, nullptr },
    { const_cast<char*>("UnconsumedBufferLength"), (getter)DataReader_get_UnconsumedBufferLength, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DataReader_Type_slots[] = 
{
    { Py_tp_dealloc, DataReader_dealloc },
    { Py_tp_new, DataReader_new },
    { Py_tp_methods, DataReader_methods },
    { Py_tp_getset, DataReader_getset },
    { 0, nullptr },
};

static PyType_Spec DataReader_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.DataReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataReader_Type_slots
};

// ----- DataReaderLoadOperation class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type;

static PyObject* DataReaderLoadOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DataReaderLoadOperation is not activatable");
    return nullptr;
}

static void DataReaderLoadOperation_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataReaderLoadOperation_Cancel(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReaderLoadOperation_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReaderLoadOperation_GetResults(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetResults();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataReaderLoadOperation_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ErrorCode();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataReaderLoadOperation_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataReaderLoadOperation_get_Status(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataReaderLoadOperation_get_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Completed();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataReaderLoadOperation_put_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);
        
        self->obj.Completed(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __DataReaderLoadOperation_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::DataReaderLoadOperation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef DataReaderLoadOperation_methods[] = {
    { "Cancel", (PyCFunction)DataReaderLoadOperation_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)DataReaderLoadOperation_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)DataReaderLoadOperation_GetResults, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__DataReaderLoadOperation_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef DataReaderLoadOperation_getset[] = {
    { const_cast<char*>("ErrorCode"), (getter)DataReaderLoadOperation_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)DataReaderLoadOperation_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Status"), (getter)DataReaderLoadOperation_get_Status, nullptr, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)DataReaderLoadOperation_get_Completed, (setter)DataReaderLoadOperation_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DataReaderLoadOperation_Type_slots[] = 
{
    { Py_tp_dealloc, DataReaderLoadOperation_dealloc },
    { Py_tp_new, DataReaderLoadOperation_new },
    { Py_tp_methods, DataReaderLoadOperation_methods },
    { Py_tp_getset, DataReaderLoadOperation_getset },
    { 0, nullptr },
};

static PyType_Spec DataReaderLoadOperation_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.DataReaderLoadOperation",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataReaderLoadOperation_Type_slots
};

// ----- DataWriter class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type;

static PyObject* DataWriter_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);
            
            winrt::Windows::Storage::Streams::DataWriter instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::DataWriter instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void DataWriter_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataWriter_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachBuffer();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_MeasureString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.MeasureString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_StoreAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.StoreAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);
            
            self->obj.WriteBoolean(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            self->obj.WriteBuffer(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            self->obj.WriteBuffer(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);
            
            self->obj.WriteByte(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto _param0 = py::convert_to<winrt::com_array<uint8_t>>(args, 0);
            auto param0 = winrt::array_view<const uint8_t>(_param0.data(), _param0.data() + _param0.size());
            
            self->obj.WriteBytes(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            self->obj.WriteDateTime(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);
            
            self->obj.WriteDouble(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            
            self->obj.WriteGuid(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int16_t>(args, 0);
            
            self->obj.WriteInt16(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);
            
            self->obj.WriteInt32(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int64_t>(args, 0);
            
            self->obj.WriteInt64(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<float>(args, 0);
            
            self->obj.WriteSingle(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.WriteString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            
            self->obj.WriteTimeSpan(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);
            
            self->obj.WriteUInt16(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            self->obj.WriteUInt32(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_WriteUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.WriteUInt64(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriter_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnicodeEncoding();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataWriter_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);
        
        self->obj.UnicodeEncoding(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* DataWriter_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ByteOrder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataWriter_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);
        
        self->obj.ByteOrder(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* DataWriter_get_UnstoredBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnstoredBufferLength();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __DataWriter_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::DataWriter>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __DataWriter_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __DataWriter_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef DataWriter_methods[] = {
    { "Close", (PyCFunction)DataWriter_Close, METH_VARARGS, nullptr },
    { "DetachBuffer", (PyCFunction)DataWriter_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)DataWriter_DetachStream, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)DataWriter_FlushAsync, METH_VARARGS, nullptr },
    { "MeasureString", (PyCFunction)DataWriter_MeasureString, METH_VARARGS, nullptr },
    { "StoreAsync", (PyCFunction)DataWriter_StoreAsync, METH_VARARGS, nullptr },
    { "WriteBoolean", (PyCFunction)DataWriter_WriteBoolean, METH_VARARGS, nullptr },
    { "WriteBuffer", (PyCFunction)DataWriter_WriteBuffer, METH_VARARGS, nullptr },
    { "WriteByte", (PyCFunction)DataWriter_WriteByte, METH_VARARGS, nullptr },
    { "WriteBytes", (PyCFunction)DataWriter_WriteBytes, METH_VARARGS, nullptr },
    { "WriteDateTime", (PyCFunction)DataWriter_WriteDateTime, METH_VARARGS, nullptr },
    { "WriteDouble", (PyCFunction)DataWriter_WriteDouble, METH_VARARGS, nullptr },
    { "WriteGuid", (PyCFunction)DataWriter_WriteGuid, METH_VARARGS, nullptr },
    { "WriteInt16", (PyCFunction)DataWriter_WriteInt16, METH_VARARGS, nullptr },
    { "WriteInt32", (PyCFunction)DataWriter_WriteInt32, METH_VARARGS, nullptr },
    { "WriteInt64", (PyCFunction)DataWriter_WriteInt64, METH_VARARGS, nullptr },
    { "WriteSingle", (PyCFunction)DataWriter_WriteSingle, METH_VARARGS, nullptr },
    { "WriteString", (PyCFunction)DataWriter_WriteString, METH_VARARGS, nullptr },
    { "WriteTimeSpan", (PyCFunction)DataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
    { "WriteUInt16", (PyCFunction)DataWriter_WriteUInt16, METH_VARARGS, nullptr },
    { "WriteUInt32", (PyCFunction)DataWriter_WriteUInt32, METH_VARARGS, nullptr },
    { "WriteUInt64", (PyCFunction)DataWriter_WriteUInt64, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__DataWriter_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__DataWriter_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__DataWriter_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef DataWriter_getset[] = {
    { const_cast<char*>("UnicodeEncoding"), (getter)DataWriter_get_UnicodeEncoding, (setter)DataWriter_put_UnicodeEncoding, nullptr, nullptr },
    { const_cast<char*>("ByteOrder"), (getter)DataWriter_get_ByteOrder, (setter)DataWriter_put_ByteOrder, nullptr, nullptr },
    { const_cast<char*>("UnstoredBufferLength"), (getter)DataWriter_get_UnstoredBufferLength, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DataWriter_Type_slots[] = 
{
    { Py_tp_dealloc, DataWriter_dealloc },
    { Py_tp_new, DataWriter_new },
    { Py_tp_methods, DataWriter_methods },
    { Py_tp_getset, DataWriter_getset },
    { 0, nullptr },
};

static PyType_Spec DataWriter_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.DataWriter",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataWriter_Type_slots
};

// ----- DataWriterStoreOperation class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type;

static PyObject* DataWriterStoreOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DataWriterStoreOperation is not activatable");
    return nullptr;
}

static void DataWriterStoreOperation_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataWriterStoreOperation_Cancel(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriterStoreOperation_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriterStoreOperation_GetResults(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetResults();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* DataWriterStoreOperation_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ErrorCode();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataWriterStoreOperation_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataWriterStoreOperation_get_Status(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataWriterStoreOperation_get_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Completed();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DataWriterStoreOperation_put_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);
        
        self->obj.Completed(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __DataWriterStoreOperation_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::DataWriterStoreOperation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef DataWriterStoreOperation_methods[] = {
    { "Cancel", (PyCFunction)DataWriterStoreOperation_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)DataWriterStoreOperation_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)DataWriterStoreOperation_GetResults, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__DataWriterStoreOperation_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef DataWriterStoreOperation_getset[] = {
    { const_cast<char*>("ErrorCode"), (getter)DataWriterStoreOperation_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)DataWriterStoreOperation_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Status"), (getter)DataWriterStoreOperation_get_Status, nullptr, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)DataWriterStoreOperation_get_Completed, (setter)DataWriterStoreOperation_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DataWriterStoreOperation_Type_slots[] = 
{
    { Py_tp_dealloc, DataWriterStoreOperation_dealloc },
    { Py_tp_new, DataWriterStoreOperation_new },
    { Py_tp_methods, DataWriterStoreOperation_methods },
    { Py_tp_getset, DataWriterStoreOperation_getset },
    { 0, nullptr },
};

static PyType_Spec DataWriterStoreOperation_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.DataWriterStoreOperation",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataWriterStoreOperation_Type_slots
};

// ----- FileInputStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type;

static PyObject* FileInputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileInputStream is not activatable");
    return nullptr;
}

static void FileInputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileInputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileInputStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __FileInputStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::FileInputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __FileInputStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __FileInputStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef FileInputStream_methods[] = {
    { "Close", (PyCFunction)FileInputStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)FileInputStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__FileInputStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__FileInputStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__FileInputStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef FileInputStream_getset[] = {
    { nullptr }
};

static PyType_Slot FileInputStream_Type_slots[] = 
{
    { Py_tp_dealloc, FileInputStream_dealloc },
    { Py_tp_new, FileInputStream_new },
    { Py_tp_methods, FileInputStream_methods },
    { Py_tp_getset, FileInputStream_getset },
    { 0, nullptr },
};

static PyType_Spec FileInputStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.FileInputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileInputStream_Type_slots
};

// ----- FileOutputStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type;

static PyObject* FileOutputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileOutputStream is not activatable");
    return nullptr;
}

static void FileOutputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileOutputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileOutputStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileOutputStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __FileOutputStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::FileOutputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __FileOutputStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __FileOutputStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef FileOutputStream_methods[] = {
    { "Close", (PyCFunction)FileOutputStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)FileOutputStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)FileOutputStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__FileOutputStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__FileOutputStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__FileOutputStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef FileOutputStream_getset[] = {
    { nullptr }
};

static PyType_Slot FileOutputStream_Type_slots[] = 
{
    { Py_tp_dealloc, FileOutputStream_dealloc },
    { Py_tp_new, FileOutputStream_new },
    { Py_tp_methods, FileOutputStream_methods },
    { Py_tp_getset, FileOutputStream_getset },
    { 0, nullptr },
};

static PyType_Spec FileOutputStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.FileOutputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileOutputStream_Type_slots
};

// ----- FileRandomAccessStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type;

static PyObject* FileRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileRandomAccessStream is not activatable");
    return nullptr;
}

static void FileRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1, param2, param3);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 4);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2, param3, param4);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenTransactedWriteAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 2);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenTransactedWriteForUserAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);
            
            auto return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1, param2, param3);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* FileRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int FileRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* FileRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* FileRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* FileRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __FileRandomAccessStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::FileRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __FileRandomAccessStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __FileRandomAccessStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef FileRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)FileRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)FileRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)FileRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)FileRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)FileRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)FileRandomAccessStream_OpenAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenForUserAsync", (PyCFunction)FileRandomAccessStream_OpenForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenTransactedWriteForUserAsync", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadAsync", (PyCFunction)FileRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)FileRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)FileRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__FileRandomAccessStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__FileRandomAccessStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__FileRandomAccessStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef FileRandomAccessStream_getset[] = {
    { const_cast<char*>("Size"), (getter)FileRandomAccessStream_get_Size, (setter)FileRandomAccessStream_put_Size, nullptr, nullptr },
    { const_cast<char*>("CanRead"), (getter)FileRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)FileRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)FileRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot FileRandomAccessStream_Type_slots[] = 
{
    { Py_tp_dealloc, FileRandomAccessStream_dealloc },
    { Py_tp_new, FileRandomAccessStream_new },
    { Py_tp_methods, FileRandomAccessStream_methods },
    { Py_tp_getset, FileRandomAccessStream_getset },
    { 0, nullptr },
};

static PyType_Spec FileRandomAccessStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.FileRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileRandomAccessStream_Type_slots
};

// ----- InMemoryRandomAccessStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type;

static PyObject* InMemoryRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::InMemoryRandomAccessStream instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void InMemoryRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* InMemoryRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int InMemoryRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* InMemoryRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* InMemoryRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* InMemoryRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __InMemoryRandomAccessStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __InMemoryRandomAccessStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __InMemoryRandomAccessStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef InMemoryRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)InMemoryRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)InMemoryRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)InMemoryRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)InMemoryRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)InMemoryRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)InMemoryRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)InMemoryRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)InMemoryRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__InMemoryRandomAccessStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__InMemoryRandomAccessStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__InMemoryRandomAccessStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef InMemoryRandomAccessStream_getset[] = {
    { const_cast<char*>("Size"), (getter)InMemoryRandomAccessStream_get_Size, (setter)InMemoryRandomAccessStream_put_Size, nullptr, nullptr },
    { const_cast<char*>("CanRead"), (getter)InMemoryRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)InMemoryRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)InMemoryRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot InMemoryRandomAccessStream_Type_slots[] = 
{
    { Py_tp_dealloc, InMemoryRandomAccessStream_dealloc },
    { Py_tp_new, InMemoryRandomAccessStream_new },
    { Py_tp_methods, InMemoryRandomAccessStream_methods },
    { Py_tp_getset, InMemoryRandomAccessStream_getset },
    { 0, nullptr },
};

static PyType_Spec InMemoryRandomAccessStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.InMemoryRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    InMemoryRandomAccessStream_Type_slots
};

// ----- InputStreamOverStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type;

static PyObject* InputStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "InputStreamOverStream is not activatable");
    return nullptr;
}

static void InputStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* InputStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* InputStreamOverStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __InputStreamOverStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::InputStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __InputStreamOverStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __InputStreamOverStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef InputStreamOverStream_methods[] = {
    { "Close", (PyCFunction)InputStreamOverStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)InputStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__InputStreamOverStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__InputStreamOverStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__InputStreamOverStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef InputStreamOverStream_getset[] = {
    { nullptr }
};

static PyType_Slot InputStreamOverStream_Type_slots[] = 
{
    { Py_tp_dealloc, InputStreamOverStream_dealloc },
    { Py_tp_new, InputStreamOverStream_new },
    { Py_tp_methods, InputStreamOverStream_methods },
    { Py_tp_getset, InputStreamOverStream_getset },
    { 0, nullptr },
};

static PyType_Spec InputStreamOverStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.InputStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    InputStreamOverStream_Type_slots
};

// ----- OutputStreamOverStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type;

static PyObject* OutputStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "OutputStreamOverStream is not activatable");
    return nullptr;
}

static void OutputStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* OutputStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* OutputStreamOverStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* OutputStreamOverStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __OutputStreamOverStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::OutputStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __OutputStreamOverStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __OutputStreamOverStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef OutputStreamOverStream_methods[] = {
    { "Close", (PyCFunction)OutputStreamOverStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)OutputStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)OutputStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__OutputStreamOverStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__OutputStreamOverStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__OutputStreamOverStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef OutputStreamOverStream_getset[] = {
    { nullptr }
};

static PyType_Slot OutputStreamOverStream_Type_slots[] = 
{
    { Py_tp_dealloc, OutputStreamOverStream_dealloc },
    { Py_tp_new, OutputStreamOverStream_new },
    { Py_tp_methods, OutputStreamOverStream_methods },
    { Py_tp_getset, OutputStreamOverStream_getset },
    { 0, nullptr },
};

static PyType_Spec OutputStreamOverStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.OutputStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    OutputStreamOverStream_Type_slots
};

// ----- RandomAccessStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type;

static PyObject* RandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStream is not activatable");
    return nullptr;
}

static PyObject* RandomAccessStream_CopyAndCloseAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStream_CopyAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
            auto param2 = py::convert_to<uint64_t>(args, 2);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef RandomAccessStream_methods[] = {
    { "CopyAndCloseAsync", (PyCFunction)RandomAccessStream_CopyAndCloseAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CopyAsync", (PyCFunction)RandomAccessStream_CopyAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef RandomAccessStream_getset[] = {
    { nullptr }
};

static PyType_Slot RandomAccessStream_Type_slots[] = 
{
    { Py_tp_new, RandomAccessStream_new },
    { Py_tp_methods, RandomAccessStream_methods },
    { Py_tp_getset, RandomAccessStream_getset },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.RandomAccessStream",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStream_Type_slots
};

// ----- RandomAccessStreamOverStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type;

static PyObject* RandomAccessStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStreamOverStream is not activatable");
    return nullptr;
}

static void RandomAccessStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* RandomAccessStreamOverStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int RandomAccessStreamOverStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* RandomAccessStreamOverStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* RandomAccessStreamOverStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* RandomAccessStreamOverStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __RandomAccessStreamOverStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __RandomAccessStreamOverStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __RandomAccessStreamOverStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef RandomAccessStreamOverStream_methods[] = {
    { "CloneStream", (PyCFunction)RandomAccessStreamOverStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)RandomAccessStreamOverStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)RandomAccessStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)RandomAccessStreamOverStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)RandomAccessStreamOverStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)RandomAccessStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)RandomAccessStreamOverStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)RandomAccessStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__RandomAccessStreamOverStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__RandomAccessStreamOverStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__RandomAccessStreamOverStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef RandomAccessStreamOverStream_getset[] = {
    { const_cast<char*>("Size"), (getter)RandomAccessStreamOverStream_get_Size, (setter)RandomAccessStreamOverStream_put_Size, nullptr, nullptr },
    { const_cast<char*>("CanRead"), (getter)RandomAccessStreamOverStream_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)RandomAccessStreamOverStream_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)RandomAccessStreamOverStream_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot RandomAccessStreamOverStream_Type_slots[] = 
{
    { Py_tp_dealloc, RandomAccessStreamOverStream_dealloc },
    { Py_tp_new, RandomAccessStreamOverStream_new },
    { Py_tp_methods, RandomAccessStreamOverStream_methods },
    { Py_tp_getset, RandomAccessStreamOverStream_getset },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStreamOverStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.RandomAccessStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStreamOverStream_Type_slots
};

// ----- RandomAccessStreamReference class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type;

static PyObject* RandomAccessStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStreamReference is not activatable");
    return nullptr;
}

static void RandomAccessStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* RandomAccessStreamReference_CreateFromFile(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamReference_CreateFromStream(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamReference_CreateFromUri(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* RandomAccessStreamReference_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __RandomAccessStreamReference_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::RandomAccessStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef RandomAccessStreamReference_methods[] = {
    { "CreateFromFile", (PyCFunction)RandomAccessStreamReference_CreateFromFile, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromStream", (PyCFunction)RandomAccessStreamReference_CreateFromStream, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromUri", (PyCFunction)RandomAccessStreamReference_CreateFromUri, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenReadAsync", (PyCFunction)RandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__RandomAccessStreamReference_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef RandomAccessStreamReference_getset[] = {
    { nullptr }
};

static PyType_Slot RandomAccessStreamReference_Type_slots[] = 
{
    { Py_tp_dealloc, RandomAccessStreamReference_dealloc },
    { Py_tp_new, RandomAccessStreamReference_new },
    { Py_tp_methods, RandomAccessStreamReference_methods },
    { Py_tp_getset, RandomAccessStreamReference_getset },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStreamReference_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.RandomAccessStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStreamReference_Type_slots
};

// ----- IBuffer interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type;

PyObject* IBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBuffer interface is not activatable");
    return nullptr;
}

static void IBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBuffer_get_Capacity(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Capacity();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBuffer_get_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Length();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IBuffer_put_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.Length(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __IBuffer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IBuffer_methods[] = {
    { "_from", (PyCFunction)__IBuffer_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IBuffer_getset[] = {
    { const_cast<char*>("Capacity"), (getter)IBuffer_get_Capacity, nullptr, nullptr, nullptr },
    { const_cast<char*>("Length"), (getter)IBuffer_get_Length, (setter)IBuffer_put_Length, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IBuffer_Type_slots[] = 
{
    { Py_tp_dealloc, IBuffer_dealloc },
    { Py_tp_new, IBuffer_new },
    { Py_tp_methods, IBuffer_methods },
    { Py_tp_getset, IBuffer_getset },
    { 0, nullptr },
};

static PyType_Spec IBuffer_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBuffer_Type_slots
};

// ----- IContentTypeProvider interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type;

PyObject* IContentTypeProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IContentTypeProvider interface is not activatable");
    return nullptr;
}

static void IContentTypeProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IContentTypeProvider_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ContentType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IContentTypeProvider_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IContentTypeProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IContentTypeProvider_methods[] = {
    { "_from", (PyCFunction)__IContentTypeProvider_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IContentTypeProvider_getset[] = {
    { const_cast<char*>("ContentType"), (getter)IContentTypeProvider_get_ContentType, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IContentTypeProvider_Type_slots[] = 
{
    { Py_tp_dealloc, IContentTypeProvider_dealloc },
    { Py_tp_new, IContentTypeProvider_new },
    { Py_tp_methods, IContentTypeProvider_methods },
    { Py_tp_getset, IContentTypeProvider_getset },
    { 0, nullptr },
};

static PyType_Spec IContentTypeProvider_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IContentTypeProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    IContentTypeProvider_Type_slots
};

// ----- IDataReader interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type;

PyObject* IDataReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IDataReader interface is not activatable");
    return nullptr;
}

static void IDataReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IDataReader_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachBuffer();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_LoadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.LoadAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadBoolean();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.ReadBuffer(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadByte();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 0);
            winrt::com_array<uint8_t> param0 ( param0_count, py::empty_instance<uint8_t>::get() );
            
            self->obj.ReadBytes(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            
            return out0.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadDateTime();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadDouble();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadGuid();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadSingle();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.ReadString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadTimeSpan();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_ReadUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadUInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataReader_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ByteOrder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IDataReader_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);
        
        self->obj.ByteOrder(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IDataReader_get_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InputStreamOptions();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IDataReader_put_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);
        
        self->obj.InputStreamOptions(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IDataReader_get_UnconsumedBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnconsumedBufferLength();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IDataReader_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnicodeEncoding();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IDataReader_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);
        
        self->obj.UnicodeEncoding(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __IDataReader_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IDataReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IDataReader_methods[] = {
    { "DetachBuffer", (PyCFunction)IDataReader_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)IDataReader_DetachStream, METH_VARARGS, nullptr },
    { "LoadAsync", (PyCFunction)IDataReader_LoadAsync, METH_VARARGS, nullptr },
    { "ReadBoolean", (PyCFunction)IDataReader_ReadBoolean, METH_VARARGS, nullptr },
    { "ReadBuffer", (PyCFunction)IDataReader_ReadBuffer, METH_VARARGS, nullptr },
    { "ReadByte", (PyCFunction)IDataReader_ReadByte, METH_VARARGS, nullptr },
    { "ReadBytes", (PyCFunction)IDataReader_ReadBytes, METH_VARARGS, nullptr },
    { "ReadDateTime", (PyCFunction)IDataReader_ReadDateTime, METH_VARARGS, nullptr },
    { "ReadDouble", (PyCFunction)IDataReader_ReadDouble, METH_VARARGS, nullptr },
    { "ReadGuid", (PyCFunction)IDataReader_ReadGuid, METH_VARARGS, nullptr },
    { "ReadInt16", (PyCFunction)IDataReader_ReadInt16, METH_VARARGS, nullptr },
    { "ReadInt32", (PyCFunction)IDataReader_ReadInt32, METH_VARARGS, nullptr },
    { "ReadInt64", (PyCFunction)IDataReader_ReadInt64, METH_VARARGS, nullptr },
    { "ReadSingle", (PyCFunction)IDataReader_ReadSingle, METH_VARARGS, nullptr },
    { "ReadString", (PyCFunction)IDataReader_ReadString, METH_VARARGS, nullptr },
    { "ReadTimeSpan", (PyCFunction)IDataReader_ReadTimeSpan, METH_VARARGS, nullptr },
    { "ReadUInt16", (PyCFunction)IDataReader_ReadUInt16, METH_VARARGS, nullptr },
    { "ReadUInt32", (PyCFunction)IDataReader_ReadUInt32, METH_VARARGS, nullptr },
    { "ReadUInt64", (PyCFunction)IDataReader_ReadUInt64, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IDataReader_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IDataReader_getset[] = {
    { const_cast<char*>("ByteOrder"), (getter)IDataReader_get_ByteOrder, (setter)IDataReader_put_ByteOrder, nullptr, nullptr },
    { const_cast<char*>("InputStreamOptions"), (getter)IDataReader_get_InputStreamOptions, (setter)IDataReader_put_InputStreamOptions, nullptr, nullptr },
    { const_cast<char*>("UnconsumedBufferLength"), (getter)IDataReader_get_UnconsumedBufferLength, nullptr, nullptr, nullptr },
    { const_cast<char*>("UnicodeEncoding"), (getter)IDataReader_get_UnicodeEncoding, (setter)IDataReader_put_UnicodeEncoding, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IDataReader_Type_slots[] = 
{
    { Py_tp_dealloc, IDataReader_dealloc },
    { Py_tp_new, IDataReader_new },
    { Py_tp_methods, IDataReader_methods },
    { Py_tp_getset, IDataReader_getset },
    { 0, nullptr },
};

static PyType_Spec IDataReader_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IDataReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    IDataReader_Type_slots
};

// ----- IDataWriter interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type;

PyObject* IDataWriter_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IDataWriter interface is not activatable");
    return nullptr;
}

static void IDataWriter_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IDataWriter_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachBuffer();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_MeasureString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.MeasureString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_StoreAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.StoreAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);
            
            self->obj.WriteBoolean(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            self->obj.WriteBuffer(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            self->obj.WriteBuffer(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);
            
            self->obj.WriteByte(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto _param0 = py::convert_to<winrt::com_array<uint8_t>>(args, 0);
            auto param0 = winrt::array_view<const uint8_t>(_param0.data(), _param0.data() + _param0.size());
            
            self->obj.WriteBytes(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            self->obj.WriteDateTime(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);
            
            self->obj.WriteDouble(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            
            self->obj.WriteGuid(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int16_t>(args, 0);
            
            self->obj.WriteInt16(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);
            
            self->obj.WriteInt32(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int64_t>(args, 0);
            
            self->obj.WriteInt64(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<float>(args, 0);
            
            self->obj.WriteSingle(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.WriteString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            
            self->obj.WriteTimeSpan(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);
            
            self->obj.WriteUInt16(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            self->obj.WriteUInt32(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.WriteUInt64(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IDataWriter_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ByteOrder();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IDataWriter_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);
        
        self->obj.ByteOrder(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IDataWriter_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnicodeEncoding();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IDataWriter_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);
        
        self->obj.UnicodeEncoding(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IDataWriter_get_UnstoredBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UnstoredBufferLength();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IDataWriter_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IDataWriter>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IDataWriter_methods[] = {
    { "DetachBuffer", (PyCFunction)IDataWriter_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)IDataWriter_DetachStream, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IDataWriter_FlushAsync, METH_VARARGS, nullptr },
    { "MeasureString", (PyCFunction)IDataWriter_MeasureString, METH_VARARGS, nullptr },
    { "StoreAsync", (PyCFunction)IDataWriter_StoreAsync, METH_VARARGS, nullptr },
    { "WriteBoolean", (PyCFunction)IDataWriter_WriteBoolean, METH_VARARGS, nullptr },
    { "WriteBuffer", (PyCFunction)IDataWriter_WriteBuffer, METH_VARARGS, nullptr },
    { "WriteByte", (PyCFunction)IDataWriter_WriteByte, METH_VARARGS, nullptr },
    { "WriteBytes", (PyCFunction)IDataWriter_WriteBytes, METH_VARARGS, nullptr },
    { "WriteDateTime", (PyCFunction)IDataWriter_WriteDateTime, METH_VARARGS, nullptr },
    { "WriteDouble", (PyCFunction)IDataWriter_WriteDouble, METH_VARARGS, nullptr },
    { "WriteGuid", (PyCFunction)IDataWriter_WriteGuid, METH_VARARGS, nullptr },
    { "WriteInt16", (PyCFunction)IDataWriter_WriteInt16, METH_VARARGS, nullptr },
    { "WriteInt32", (PyCFunction)IDataWriter_WriteInt32, METH_VARARGS, nullptr },
    { "WriteInt64", (PyCFunction)IDataWriter_WriteInt64, METH_VARARGS, nullptr },
    { "WriteSingle", (PyCFunction)IDataWriter_WriteSingle, METH_VARARGS, nullptr },
    { "WriteString", (PyCFunction)IDataWriter_WriteString, METH_VARARGS, nullptr },
    { "WriteTimeSpan", (PyCFunction)IDataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
    { "WriteUInt16", (PyCFunction)IDataWriter_WriteUInt16, METH_VARARGS, nullptr },
    { "WriteUInt32", (PyCFunction)IDataWriter_WriteUInt32, METH_VARARGS, nullptr },
    { "WriteUInt64", (PyCFunction)IDataWriter_WriteUInt64, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IDataWriter_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IDataWriter_getset[] = {
    { const_cast<char*>("ByteOrder"), (getter)IDataWriter_get_ByteOrder, (setter)IDataWriter_put_ByteOrder, nullptr, nullptr },
    { const_cast<char*>("UnicodeEncoding"), (getter)IDataWriter_get_UnicodeEncoding, (setter)IDataWriter_put_UnicodeEncoding, nullptr, nullptr },
    { const_cast<char*>("UnstoredBufferLength"), (getter)IDataWriter_get_UnstoredBufferLength, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IDataWriter_Type_slots[] = 
{
    { Py_tp_dealloc, IDataWriter_dealloc },
    { Py_tp_new, IDataWriter_new },
    { Py_tp_methods, IDataWriter_methods },
    { Py_tp_getset, IDataWriter_getset },
    { 0, nullptr },
};

static PyType_Spec IDataWriter_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IDataWriter",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>),
    0,
    Py_TPFLAGS_DEFAULT,
    IDataWriter_Type_slots
};

// ----- IInputStream interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type;

PyObject* IInputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IInputStream interface is not activatable");
    return nullptr;
}

static void IInputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IInputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IInputStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IInputStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IInputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IInputStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __IInputStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IInputStream_methods[] = {
    { "Close", (PyCFunction)IInputStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IInputStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IInputStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__IInputStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__IInputStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef IInputStream_getset[] = {
    { nullptr }
};

static PyType_Slot IInputStream_Type_slots[] = 
{
    { Py_tp_dealloc, IInputStream_dealloc },
    { Py_tp_new, IInputStream_new },
    { Py_tp_methods, IInputStream_methods },
    { Py_tp_getset, IInputStream_getset },
    { 0, nullptr },
};

static PyType_Spec IInputStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IInputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IInputStream_Type_slots
};

// ----- IInputStreamReference interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type;

PyObject* IInputStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IInputStreamReference interface is not activatable");
    return nullptr;
}

static void IInputStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IInputStreamReference_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenSequentialReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IInputStreamReference_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IInputStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IInputStreamReference_methods[] = {
    { "OpenSequentialReadAsync", (PyCFunction)IInputStreamReference_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IInputStreamReference_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IInputStreamReference_getset[] = {
    { nullptr }
};

static PyType_Slot IInputStreamReference_Type_slots[] = 
{
    { Py_tp_dealloc, IInputStreamReference_dealloc },
    { Py_tp_new, IInputStreamReference_new },
    { Py_tp_methods, IInputStreamReference_methods },
    { Py_tp_getset, IInputStreamReference_getset },
    { 0, nullptr },
};

static PyType_Spec IInputStreamReference_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IInputStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IInputStreamReference_Type_slots
};

// ----- IOutputStream interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type;

PyObject* IOutputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IOutputStream interface is not activatable");
    return nullptr;
}

static void IOutputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IOutputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IOutputStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IOutputStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IOutputStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IOutputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IOutputStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __IOutputStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IOutputStream_methods[] = {
    { "Close", (PyCFunction)IOutputStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IOutputStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IOutputStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IOutputStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__IOutputStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__IOutputStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef IOutputStream_getset[] = {
    { nullptr }
};

static PyType_Slot IOutputStream_Type_slots[] = 
{
    { Py_tp_dealloc, IOutputStream_dealloc },
    { Py_tp_new, IOutputStream_new },
    { Py_tp_methods, IOutputStream_methods },
    { Py_tp_getset, IOutputStream_getset },
    { 0, nullptr },
};

static PyType_Spec IOutputStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IOutputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IOutputStream_Type_slots
};

// ----- IRandomAccessStream interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type;

PyObject* IRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStream interface is not activatable");
    return nullptr;
}

static void IRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __IRandomAccessStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IRandomAccessStream_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __IRandomAccessStream_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)IRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)IRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)IRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)IRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IRandomAccessStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__IRandomAccessStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__IRandomAccessStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef IRandomAccessStream_getset[] = {
    { const_cast<char*>("CanRead"), (getter)IRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)IRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)IRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("Size"), (getter)IRandomAccessStream_get_Size, (setter)IRandomAccessStream_put_Size, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IRandomAccessStream_Type_slots[] = 
{
    { Py_tp_dealloc, IRandomAccessStream_dealloc },
    { Py_tp_new, IRandomAccessStream_new },
    { Py_tp_methods, IRandomAccessStream_methods },
    { Py_tp_getset, IRandomAccessStream_getset },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStream_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStream_Type_slots
};

// ----- IRandomAccessStreamReference interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type;

PyObject* IRandomAccessStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStreamReference interface is not activatable");
    return nullptr;
}

static void IRandomAccessStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStreamReference_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.OpenReadAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IRandomAccessStreamReference_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IRandomAccessStreamReference_methods[] = {
    { "OpenReadAsync", (PyCFunction)IRandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IRandomAccessStreamReference_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IRandomAccessStreamReference_getset[] = {
    { nullptr }
};

static PyType_Slot IRandomAccessStreamReference_Type_slots[] = 
{
    { Py_tp_dealloc, IRandomAccessStreamReference_dealloc },
    { Py_tp_new, IRandomAccessStreamReference_new },
    { Py_tp_methods, IRandomAccessStreamReference_methods },
    { Py_tp_getset, IRandomAccessStreamReference_getset },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStreamReference_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IRandomAccessStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStreamReference_Type_slots
};

// ----- IRandomAccessStreamWithContentType interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type;

PyObject* IRandomAccessStreamWithContentType_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStreamWithContentType interface is not activatable");
    return nullptr;
}

static void IRandomAccessStreamWithContentType_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStreamWithContentType_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStreamWithContentType_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStreamWithContentType_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IRandomAccessStreamWithContentType_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IRandomAccessStreamWithContentType_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ContentType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value.detach();
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IRandomAccessStreamWithContentType_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IRandomAccessStreamWithContentType_enter(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __IRandomAccessStreamWithContentType_exit(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IRandomAccessStreamWithContentType_methods[] = {
    { "CloneStream", (PyCFunction)IRandomAccessStreamWithContentType_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IRandomAccessStreamWithContentType_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IRandomAccessStreamWithContentType_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)IRandomAccessStreamWithContentType_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)IRandomAccessStreamWithContentType_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IRandomAccessStreamWithContentType_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)IRandomAccessStreamWithContentType_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IRandomAccessStreamWithContentType_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IRandomAccessStreamWithContentType_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__IRandomAccessStreamWithContentType_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__IRandomAccessStreamWithContentType_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef IRandomAccessStreamWithContentType_getset[] = {
    { const_cast<char*>("CanRead"), (getter)IRandomAccessStreamWithContentType_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)IRandomAccessStreamWithContentType_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)IRandomAccessStreamWithContentType_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("Size"), (getter)IRandomAccessStreamWithContentType_get_Size, (setter)IRandomAccessStreamWithContentType_put_Size, nullptr, nullptr },
    { const_cast<char*>("ContentType"), (getter)IRandomAccessStreamWithContentType_get_ContentType, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IRandomAccessStreamWithContentType_Type_slots[] = 
{
    { Py_tp_dealloc, IRandomAccessStreamWithContentType_dealloc },
    { Py_tp_new, IRandomAccessStreamWithContentType_new },
    { Py_tp_methods, IRandomAccessStreamWithContentType_methods },
    { Py_tp_getset, IRandomAccessStreamWithContentType_getset },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStreamWithContentType_Type_spec =
{
    "_pyrt_Windows_Storage_Streams.IRandomAccessStreamWithContentType",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStreamWithContentType_Type_slots
};

// ----- Windows.Storage.Streams Initialization --------------------

static int module_exec(PyObject* module)
{
    py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };
    
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&Buffer_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "Buffer", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&DataReader_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "DataReader", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&DataReaderLoadOperation_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "DataReaderLoadOperation", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&DataWriter_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "DataWriter", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&DataWriterStoreOperation_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "DataWriterStoreOperation", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&FileInputStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "FileInputStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&FileOutputStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "FileOutputStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&FileRandomAccessStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "FileRandomAccessStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&InMemoryRandomAccessStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "InMemoryRandomAccessStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&InputStreamOverStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "InputStreamOverStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&OutputStreamOverStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "OutputStreamOverStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpec(&RandomAccessStream_Type_spec) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "RandomAccessStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&RandomAccessStreamOverStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "RandomAccessStreamOverStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&RandomAccessStreamReference_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "RandomAccessStreamReference", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IBuffer_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IBuffer", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IContentTypeProvider_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IContentTypeProvider", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IDataReader_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IDataReader", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IDataWriter_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IDataWriter", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IInputStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IInputStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IInputStreamReference_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IInputStreamReference", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IOutputStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IOutputStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IRandomAccessStream_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IRandomAccessStream", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IRandomAccessStreamReference_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IRandomAccessStreamReference", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    {
        py::pyobj_handle type_object { PyType_FromSpecWithBases(&IRandomAccessStreamWithContentType_Type_spec, bases.get()) };
        if (!type_object)
        {
            return -1;
        }
        if (PyModule_AddObject(module, "IRandomAccessStreamWithContentType", type_object.get()) != 0)
        {
            return -1;
        }
        py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type = reinterpret_cast<PyTypeObject*>(type_object.detach());
    }
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Storage.Streams");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Storage_Streams",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Storage_Streams(void)
{
    return PyModuleDef_Init(&module_def);
}
