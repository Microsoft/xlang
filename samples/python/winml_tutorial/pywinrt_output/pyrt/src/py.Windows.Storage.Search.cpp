// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.Search.h"

// ----- ContentIndexer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ContentIndexer>::python_type;

static PyObject* ContentIndexer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ContentIndexer is not activatable");
    return nullptr;
}

static void ContentIndexer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ContentIndexer_AddAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::IIndexableContent>(args, 0);
            
            auto return_value = self->obj.AddAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_CreateQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>(args, 2);
            auto param3 = py::convert_to<winrt::hstring>(args, 3);
            
            auto return_value = self->obj.CreateQuery(param0, param1, param2, param3);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>(args, 2);
            
            auto return_value = self->obj.CreateQuery(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = self->obj.CreateQuery(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_DeleteAllAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DeleteAllAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.DeleteAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_DeleteMultipleAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
            
            auto return_value = self->obj.DeleteMultipleAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_GetIndexer(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Storage::Search::ContentIndexer::GetIndexer(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Storage::Search::ContentIndexer::GetIndexer();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_RetrievePropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            auto return_value = self->obj.RetrievePropertiesAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_UpdateAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::IIndexableContent>(args, 0);
            
            auto return_value = self->obj.UpdateAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexer_get_Revision(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Revision();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ContentIndexer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::ContentIndexer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ContentIndexer_methods[] = {
    { "AddAsync", (PyCFunction)ContentIndexer_AddAsync, METH_VARARGS, nullptr },
    { "CreateQuery", (PyCFunction)ContentIndexer_CreateQuery, METH_VARARGS, nullptr },
    { "DeleteAllAsync", (PyCFunction)ContentIndexer_DeleteAllAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)ContentIndexer_DeleteAsync, METH_VARARGS, nullptr },
    { "DeleteMultipleAsync", (PyCFunction)ContentIndexer_DeleteMultipleAsync, METH_VARARGS, nullptr },
    { "GetIndexer", (PyCFunction)ContentIndexer_GetIndexer, METH_VARARGS | METH_STATIC, nullptr },
    { "RetrievePropertiesAsync", (PyCFunction)ContentIndexer_RetrievePropertiesAsync, METH_VARARGS, nullptr },
    { "UpdateAsync", (PyCFunction)ContentIndexer_UpdateAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__ContentIndexer_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ContentIndexer_getset[] = {
    { const_cast<char*>("Revision"), (getter)ContentIndexer_get_Revision, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ContentIndexer_Type_slots[] = 
{
    { Py_tp_dealloc, ContentIndexer_dealloc },
    { Py_tp_new, ContentIndexer_new },
    { Py_tp_methods, ContentIndexer_methods },
    { Py_tp_getset, ContentIndexer_getset },
    { 0, nullptr },
};

static PyType_Spec ContentIndexer_Type_spec =
{
    "ContentIndexer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>),
    0,
    Py_TPFLAGS_DEFAULT,
    ContentIndexer_Type_slots
};

// ----- ContentIndexerQuery class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ContentIndexerQuery>::python_type;

static PyObject* ContentIndexerQuery_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ContentIndexerQuery is not activatable");
    return nullptr;
}

static void ContentIndexerQuery_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ContentIndexerQuery_GetAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexerQuery_GetCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetCountAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexerQuery_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPropertiesAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetPropertiesAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ContentIndexerQuery_get_QueryFolder(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.QueryFolder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ContentIndexerQuery_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::ContentIndexerQuery>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ContentIndexerQuery_methods[] = {
    { "GetAsync", (PyCFunction)ContentIndexerQuery_GetAsync, METH_VARARGS, nullptr },
    { "GetCountAsync", (PyCFunction)ContentIndexerQuery_GetCountAsync, METH_VARARGS, nullptr },
    { "GetPropertiesAsync", (PyCFunction)ContentIndexerQuery_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__ContentIndexerQuery_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ContentIndexerQuery_getset[] = {
    { const_cast<char*>("QueryFolder"), (getter)ContentIndexerQuery_get_QueryFolder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ContentIndexerQuery_Type_slots[] = 
{
    { Py_tp_dealloc, ContentIndexerQuery_dealloc },
    { Py_tp_new, ContentIndexerQuery_new },
    { Py_tp_methods, ContentIndexerQuery_methods },
    { Py_tp_getset, ContentIndexerQuery_getset },
    { 0, nullptr },
};

static PyType_Spec ContentIndexerQuery_Type_spec =
{
    "ContentIndexerQuery",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>),
    0,
    Py_TPFLAGS_DEFAULT,
    ContentIndexerQuery_Type_slots
};

// ----- IndexableContent class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IndexableContent>::python_type;

static PyObject* IndexableContent_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::IndexableContent instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void IndexableContent_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IndexableContent_get_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StreamContentType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IndexableContent_put_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.StreamContentType(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IndexableContent_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Stream();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IndexableContent_put_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);
        
        self->obj.Stream(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IndexableContent_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IndexableContent_put_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Id(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IndexableContent_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IndexableContent_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::IndexableContent>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IndexableContent_methods[] = {
    { "_from", (PyCFunction)__IndexableContent_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IndexableContent_getset[] = {
    { const_cast<char*>("StreamContentType"), (getter)IndexableContent_get_StreamContentType, (setter)IndexableContent_put_StreamContentType, nullptr, nullptr },
    { const_cast<char*>("Stream"), (getter)IndexableContent_get_Stream, (setter)IndexableContent_put_Stream, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)IndexableContent_get_Id, (setter)IndexableContent_put_Id, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)IndexableContent_get_Properties, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IndexableContent_Type_slots[] = 
{
    { Py_tp_dealloc, IndexableContent_dealloc },
    { Py_tp_new, IndexableContent_new },
    { Py_tp_methods, IndexableContent_methods },
    { Py_tp_getset, IndexableContent_getset },
    { 0, nullptr },
};

static PyType_Spec IndexableContent_Type_spec =
{
    "IndexableContent",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>),
    0,
    Py_TPFLAGS_DEFAULT,
    IndexableContent_Type_slots
};

// ----- QueryOptions class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::QueryOptions>::python_type;

static PyObject* QueryOptions_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            winrt::Windows::Storage::Search::QueryOptions instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            winrt::Windows::Storage::Search::QueryOptions instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void QueryOptions_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* QueryOptions_LoadFromString(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.LoadFromString(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* QueryOptions_SaveToString(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.SaveToString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* QueryOptions_SetPropertyPrefetch(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::PropertyPrefetchOptions>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            
            self->obj.SetPropertyPrefetch(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* QueryOptions_SetThumbnailPrefetch(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);
            
            self->obj.SetThumbnailPrefetch(param0, param1, param2);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* QueryOptions_get_UserSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UserSearchFilter();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int QueryOptions_put_UserSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.UserSearchFilter(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* QueryOptions_get_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Language();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int QueryOptions_put_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Language(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* QueryOptions_get_IndexerOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IndexerOption();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int QueryOptions_put_IndexerOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Search::IndexerOption>(arg);
        
        self->obj.IndexerOption(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* QueryOptions_get_FolderDepth(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FolderDepth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int QueryOptions_put_FolderDepth(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Search::FolderDepth>(arg);
        
        self->obj.FolderDepth(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* QueryOptions_get_ApplicationSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ApplicationSearchFilter();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int QueryOptions_put_ApplicationSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.ApplicationSearchFilter(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* QueryOptions_get_DateStackOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DateStackOption();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* QueryOptions_get_FileTypeFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FileTypeFilter();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* QueryOptions_get_GroupPropertyName(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GroupPropertyName();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* QueryOptions_get_SortOrder(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SortOrder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* QueryOptions_get_StorageProviderIdFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StorageProviderIdFilter();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __QueryOptions_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::QueryOptions>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef QueryOptions_methods[] = {
    { "LoadFromString", (PyCFunction)QueryOptions_LoadFromString, METH_VARARGS, nullptr },
    { "SaveToString", (PyCFunction)QueryOptions_SaveToString, METH_VARARGS, nullptr },
    { "SetPropertyPrefetch", (PyCFunction)QueryOptions_SetPropertyPrefetch, METH_VARARGS, nullptr },
    { "SetThumbnailPrefetch", (PyCFunction)QueryOptions_SetThumbnailPrefetch, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__QueryOptions_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef QueryOptions_getset[] = {
    { const_cast<char*>("UserSearchFilter"), (getter)QueryOptions_get_UserSearchFilter, (setter)QueryOptions_put_UserSearchFilter, nullptr, nullptr },
    { const_cast<char*>("Language"), (getter)QueryOptions_get_Language, (setter)QueryOptions_put_Language, nullptr, nullptr },
    { const_cast<char*>("IndexerOption"), (getter)QueryOptions_get_IndexerOption, (setter)QueryOptions_put_IndexerOption, nullptr, nullptr },
    { const_cast<char*>("FolderDepth"), (getter)QueryOptions_get_FolderDepth, (setter)QueryOptions_put_FolderDepth, nullptr, nullptr },
    { const_cast<char*>("ApplicationSearchFilter"), (getter)QueryOptions_get_ApplicationSearchFilter, (setter)QueryOptions_put_ApplicationSearchFilter, nullptr, nullptr },
    { const_cast<char*>("DateStackOption"), (getter)QueryOptions_get_DateStackOption, nullptr, nullptr, nullptr },
    { const_cast<char*>("FileTypeFilter"), (getter)QueryOptions_get_FileTypeFilter, nullptr, nullptr, nullptr },
    { const_cast<char*>("GroupPropertyName"), (getter)QueryOptions_get_GroupPropertyName, nullptr, nullptr, nullptr },
    { const_cast<char*>("SortOrder"), (getter)QueryOptions_get_SortOrder, nullptr, nullptr, nullptr },
    { const_cast<char*>("StorageProviderIdFilter"), (getter)QueryOptions_get_StorageProviderIdFilter, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot QueryOptions_Type_slots[] = 
{
    { Py_tp_dealloc, QueryOptions_dealloc },
    { Py_tp_new, QueryOptions_new },
    { Py_tp_methods, QueryOptions_methods },
    { Py_tp_getset, QueryOptions_getset },
    { 0, nullptr },
};

static PyType_Spec QueryOptions_Type_spec =
{
    "QueryOptions",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>),
    0,
    Py_TPFLAGS_DEFAULT,
    QueryOptions_Type_slots
};

// ----- SortEntryVector class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::SortEntryVector>::python_type;

static PyObject* SortEntryVector_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SortEntryVector is not activatable");
    return nullptr;
}

static void SortEntryVector_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SortEntryVector_Append(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 0);
            
            self->obj.Append(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_Clear(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_First(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_GetAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_GetMany(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Storage::Search::SortEntry>::size_type>(args, 1);
            winrt::com_array<winrt::Windows::Storage::Search::SortEntry> param1 ( param1_count, py::empty_instance<winrt::Windows::Storage::Search::SortEntry>::get() );
            
            auto return_value = self->obj.GetMany(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_GetView(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_IndexOf(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 0);
            uint32_t param1 {  };
            
            auto return_value = self->obj.IndexOf(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_InsertAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 1);
            
            self->obj.InsertAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_RemoveAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            self->obj.RemoveAt(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_RemoveAtEnd(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.RemoveAtEnd();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_ReplaceAll(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Storage::Search::SortEntry>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Storage::Search::SortEntry>(_param0.begin(), _param0.end());
            
            self->obj.ReplaceAll(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_SetAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 1);
            
            self->obj.SetAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SortEntryVector_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SortEntryVector_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::SortEntryVector>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SortEntryVector_iter(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __SortEntryVector_sq_length(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __SortEntryVector_sq_item(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, Py_ssize_t i)
{
    try
    {
        return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __SortEntryVector_sq_ass_item(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, Py_ssize_t i, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
         else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Storage::Search::SortEntry>(value)); }
         return 0;
         }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef SortEntryVector_methods[] = {
    { "Append", (PyCFunction)SortEntryVector_Append, METH_VARARGS, nullptr },
    { "Clear", (PyCFunction)SortEntryVector_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)SortEntryVector_First, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)SortEntryVector_GetAt, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)SortEntryVector_GetMany, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)SortEntryVector_GetView, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)SortEntryVector_IndexOf, METH_VARARGS, nullptr },
    { "InsertAt", (PyCFunction)SortEntryVector_InsertAt, METH_VARARGS, nullptr },
    { "RemoveAt", (PyCFunction)SortEntryVector_RemoveAt, METH_VARARGS, nullptr },
    { "RemoveAtEnd", (PyCFunction)SortEntryVector_RemoveAtEnd, METH_VARARGS, nullptr },
    { "ReplaceAll", (PyCFunction)SortEntryVector_ReplaceAll, METH_VARARGS, nullptr },
    { "SetAt", (PyCFunction)SortEntryVector_SetAt, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__SortEntryVector_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef SortEntryVector_getset[] = {
    { const_cast<char*>("Size"), (getter)SortEntryVector_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SortEntryVector_Type_slots[] = 
{
    { Py_tp_dealloc, SortEntryVector_dealloc },
    { Py_tp_new, SortEntryVector_new },
    { Py_tp_methods, SortEntryVector_methods },
    { Py_tp_getset, SortEntryVector_getset },
    { Py_tp_iter, __SortEntryVector_iter },
    { Py_sq_length, __SortEntryVector_sq_length },
    { Py_sq_item, __SortEntryVector_sq_item },
    { Py_sq_ass_item, __SortEntryVector_sq_ass_item },
    { 0, nullptr },
};

static PyType_Spec SortEntryVector_Type_spec =
{
    "SortEntryVector",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>),
    0,
    Py_TPFLAGS_DEFAULT,
    SortEntryVector_Type_slots
};

// ----- StorageFileQueryResult class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageFileQueryResult>::python_type;

static PyObject* StorageFileQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFileQueryResult is not activatable");
    return nullptr;
}

static void StorageFileQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFileQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            self->obj.ApplyNewQueryOptions(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            
            auto return_value = self->obj.FindStartIndexAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetCurrentQueryOptions();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetFilesAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFilesAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemCountAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetMatchingPropertiesWithRanges(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
            
            auto return_value = self->obj.GetMatchingPropertiesWithRanges(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFileQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFileQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.ContentsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFileQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ContentsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFileQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.OptionsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFileQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.OptionsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageFileQueryResult_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::StorageFileQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageFileQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageFileQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageFileQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageFileQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)StorageFileQueryResult_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageFileQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "GetMatchingPropertiesWithRanges", (PyCFunction)StorageFileQueryResult_GetMatchingPropertiesWithRanges, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageFileQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageFileQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageFileQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageFileQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__StorageFileQueryResult_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageFileQueryResult_getset[] = {
    { const_cast<char*>("Folder"), (getter)StorageFileQueryResult_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageFileQueryResult_Type_slots[] = 
{
    { Py_tp_dealloc, StorageFileQueryResult_dealloc },
    { Py_tp_new, StorageFileQueryResult_new },
    { Py_tp_methods, StorageFileQueryResult_methods },
    { Py_tp_getset, StorageFileQueryResult_getset },
    { 0, nullptr },
};

static PyType_Spec StorageFileQueryResult_Type_spec =
{
    "StorageFileQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFileQueryResult_Type_slots
};

// ----- StorageFolderQueryResult class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageFolderQueryResult>::python_type;

static PyObject* StorageFolderQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFolderQueryResult is not activatable");
    return nullptr;
}

static void StorageFolderQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFolderQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            self->obj.ApplyNewQueryOptions(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolderQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            
            auto return_value = self->obj.FindStartIndexAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetCurrentQueryOptions();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetFoldersAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetFoldersAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemCountAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageFolderQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolderQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.ContentsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolderQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ContentsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolderQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.OptionsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolderQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.OptionsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageFolderQueryResult_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::StorageFolderQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageFolderQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageFolderQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageFolderQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageFolderQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)StorageFolderQueryResult_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageFolderQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageFolderQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageFolderQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageFolderQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageFolderQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__StorageFolderQueryResult_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageFolderQueryResult_getset[] = {
    { const_cast<char*>("Folder"), (getter)StorageFolderQueryResult_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageFolderQueryResult_Type_slots[] = 
{
    { Py_tp_dealloc, StorageFolderQueryResult_dealloc },
    { Py_tp_new, StorageFolderQueryResult_new },
    { Py_tp_methods, StorageFolderQueryResult_methods },
    { Py_tp_getset, StorageFolderQueryResult_getset },
    { 0, nullptr },
};

static PyType_Spec StorageFolderQueryResult_Type_spec =
{
    "StorageFolderQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFolderQueryResult_Type_slots
};

// ----- StorageItemQueryResult class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageItemQueryResult>::python_type;

static PyObject* StorageItemQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageItemQueryResult is not activatable");
    return nullptr;
}

static void StorageItemQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageItemQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            self->obj.ApplyNewQueryOptions(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageItemQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            
            auto return_value = self->obj.FindStartIndexAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetCurrentQueryOptions();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemCountAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetItemsAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemsAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageItemQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageItemQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.ContentsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageItemQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ContentsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageItemQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.OptionsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageItemQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.OptionsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageItemQueryResult_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::StorageItemQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageItemQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageItemQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageItemQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageItemQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageItemQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)StorageItemQueryResult_GetItemsAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageItemQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageItemQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageItemQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageItemQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__StorageItemQueryResult_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageItemQueryResult_getset[] = {
    { const_cast<char*>("Folder"), (getter)StorageItemQueryResult_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageItemQueryResult_Type_slots[] = 
{
    { Py_tp_dealloc, StorageItemQueryResult_dealloc },
    { Py_tp_new, StorageItemQueryResult_new },
    { Py_tp_methods, StorageItemQueryResult_methods },
    { Py_tp_getset, StorageItemQueryResult_getset },
    { 0, nullptr },
};

static PyType_Spec StorageItemQueryResult_Type_spec =
{
    "StorageItemQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageItemQueryResult_Type_slots
};

// ----- StorageLibraryChangeTrackerTriggerDetails class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>::python_type;

static PyObject* StorageLibraryChangeTrackerTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeTrackerTriggerDetails is not activatable");
    return nullptr;
}

static void StorageLibraryChangeTrackerTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeTrackerTriggerDetails_get_ChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ChangeTracker();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChangeTrackerTriggerDetails_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageLibraryChangeTrackerTriggerDetails_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibraryChangeTrackerTriggerDetails_methods[] = {
    { "_from", (PyCFunction)__StorageLibraryChangeTrackerTriggerDetails_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibraryChangeTrackerTriggerDetails_getset[] = {
    { const_cast<char*>("ChangeTracker"), (getter)StorageLibraryChangeTrackerTriggerDetails_get_ChangeTracker, nullptr, nullptr, nullptr },
    { const_cast<char*>("Folder"), (getter)StorageLibraryChangeTrackerTriggerDetails_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChangeTrackerTriggerDetails_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibraryChangeTrackerTriggerDetails_dealloc },
    { Py_tp_new, StorageLibraryChangeTrackerTriggerDetails_new },
    { Py_tp_methods, StorageLibraryChangeTrackerTriggerDetails_methods },
    { Py_tp_getset, StorageLibraryChangeTrackerTriggerDetails_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeTrackerTriggerDetails_Type_spec =
{
    "StorageLibraryChangeTrackerTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeTrackerTriggerDetails_Type_slots
};

// ----- StorageLibraryContentChangedTriggerDetails class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>::python_type;

static PyObject* StorageLibraryContentChangedTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryContentChangedTriggerDetails is not activatable");
    return nullptr;
}

static void StorageLibraryContentChangedTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryContentChangedTriggerDetails_CreateModifiedSinceQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            auto return_value = self->obj.CreateModifiedSinceQuery(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* StorageLibraryContentChangedTriggerDetails_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StorageLibraryContentChangedTriggerDetails_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StorageLibraryContentChangedTriggerDetails_methods[] = {
    { "CreateModifiedSinceQuery", (PyCFunction)StorageLibraryContentChangedTriggerDetails_CreateModifiedSinceQuery, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__StorageLibraryContentChangedTriggerDetails_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StorageLibraryContentChangedTriggerDetails_getset[] = {
    { const_cast<char*>("Folder"), (getter)StorageLibraryContentChangedTriggerDetails_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryContentChangedTriggerDetails_Type_slots[] = 
{
    { Py_tp_dealloc, StorageLibraryContentChangedTriggerDetails_dealloc },
    { Py_tp_new, StorageLibraryContentChangedTriggerDetails_new },
    { Py_tp_methods, StorageLibraryContentChangedTriggerDetails_methods },
    { Py_tp_getset, StorageLibraryContentChangedTriggerDetails_getset },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryContentChangedTriggerDetails_Type_spec =
{
    "StorageLibraryContentChangedTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryContentChangedTriggerDetails_Type_slots
};

// ----- ValueAndLanguage class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ValueAndLanguage>::python_type;

static PyObject* ValueAndLanguage_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::ValueAndLanguage instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void ValueAndLanguage_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ValueAndLanguage_get_Value(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int ValueAndLanguage_put_Value(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        
        self->obj.Value(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* ValueAndLanguage_get_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Language();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int ValueAndLanguage_put_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Language(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __ValueAndLanguage_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::ValueAndLanguage>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ValueAndLanguage_methods[] = {
    { "_from", (PyCFunction)__ValueAndLanguage_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef ValueAndLanguage_getset[] = {
    { const_cast<char*>("Value"), (getter)ValueAndLanguage_get_Value, (setter)ValueAndLanguage_put_Value, nullptr, nullptr },
    { const_cast<char*>("Language"), (getter)ValueAndLanguage_get_Language, (setter)ValueAndLanguage_put_Language, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ValueAndLanguage_Type_slots[] = 
{
    { Py_tp_dealloc, ValueAndLanguage_dealloc },
    { Py_tp_new, ValueAndLanguage_new },
    { Py_tp_methods, ValueAndLanguage_methods },
    { Py_tp_getset, ValueAndLanguage_getset },
    { 0, nullptr },
};

static PyType_Spec ValueAndLanguage_Type_spec =
{
    "ValueAndLanguage",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>),
    0,
    Py_TPFLAGS_DEFAULT,
    ValueAndLanguage_Type_slots
};

// ----- IIndexableContent interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IIndexableContent>::python_type;

PyObject* IIndexableContent_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IIndexableContent interface is not activatable");
    return nullptr;
}

static void IIndexableContent_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IIndexableContent_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IIndexableContent_put_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.Id(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IIndexableContent_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Properties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IIndexableContent_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Stream();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IIndexableContent_put_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);
        
        self->obj.Stream(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* IIndexableContent_get_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StreamContentType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IIndexableContent_put_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::hstring>(arg);
        
        self->obj.StreamContentType(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __IIndexableContent_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::IIndexableContent>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IIndexableContent_methods[] = {
    { "_from", (PyCFunction)__IIndexableContent_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IIndexableContent_getset[] = {
    { const_cast<char*>("Id"), (getter)IIndexableContent_get_Id, (setter)IIndexableContent_put_Id, nullptr, nullptr },
    { const_cast<char*>("Properties"), (getter)IIndexableContent_get_Properties, nullptr, nullptr, nullptr },
    { const_cast<char*>("Stream"), (getter)IIndexableContent_get_Stream, (setter)IIndexableContent_put_Stream, nullptr, nullptr },
    { const_cast<char*>("StreamContentType"), (getter)IIndexableContent_get_StreamContentType, (setter)IIndexableContent_put_StreamContentType, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IIndexableContent_Type_slots[] = 
{
    { Py_tp_dealloc, IIndexableContent_dealloc },
    { Py_tp_new, IIndexableContent_new },
    { Py_tp_methods, IIndexableContent_methods },
    { Py_tp_getset, IIndexableContent_getset },
    { 0, nullptr },
};

static PyType_Spec IIndexableContent_Type_spec =
{
    "IIndexableContent",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>),
    0,
    Py_TPFLAGS_DEFAULT,
    IIndexableContent_Type_slots
};

// ----- IStorageFolderQueryOperations interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>::python_type;

PyObject* IStorageFolderQueryOperations_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolderQueryOperations interface is not activatable");
    return nullptr;
}

static void IStorageFolderQueryOperations_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolderQueryOperations_AreQueryOptionsSupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.AreQueryOptionsSupported(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFileQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateFileQuery();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.CreateFileQuery(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFileQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateFileQueryWithOptions(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFolderQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateFolderQuery();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.CreateFolderQuery(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFolderQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateFolderQueryWithOptions(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateItemQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateItemQuery();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateItemQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            auto return_value = self->obj.CreateItemQueryWithOptions(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = self->obj.GetFilesAsync(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.GetFilesAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = self->obj.GetFoldersAsync(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.GetFoldersAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetIndexedStateAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetIndexedStateAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            
            auto return_value = self->obj.GetItemsAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_IsCommonFileQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            
            auto return_value = self->obj.IsCommonFileQuerySupported(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_IsCommonFolderQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            
            auto return_value = self->obj.IsCommonFolderQuerySupported(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IStorageFolderQueryOperations_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageFolderQueryOperations_methods[] = {
    { "AreQueryOptionsSupported", (PyCFunction)IStorageFolderQueryOperations_AreQueryOptionsSupported, METH_VARARGS, nullptr },
    { "CreateFileQuery", (PyCFunction)IStorageFolderQueryOperations_CreateFileQuery, METH_VARARGS, nullptr },
    { "CreateFileQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateFileQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateFolderQuery", (PyCFunction)IStorageFolderQueryOperations_CreateFolderQuery, METH_VARARGS, nullptr },
    { "CreateFolderQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateFolderQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateItemQuery", (PyCFunction)IStorageFolderQueryOperations_CreateItemQuery, METH_VARARGS, nullptr },
    { "CreateItemQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateItemQueryWithOptions, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)IStorageFolderQueryOperations_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)IStorageFolderQueryOperations_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetIndexedStateAsync", (PyCFunction)IStorageFolderQueryOperations_GetIndexedStateAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)IStorageFolderQueryOperations_GetItemsAsync, METH_VARARGS, nullptr },
    { "IsCommonFileQuerySupported", (PyCFunction)IStorageFolderQueryOperations_IsCommonFileQuerySupported, METH_VARARGS, nullptr },
    { "IsCommonFolderQuerySupported", (PyCFunction)IStorageFolderQueryOperations_IsCommonFolderQuerySupported, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IStorageFolderQueryOperations_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageFolderQueryOperations_getset[] = {
    { nullptr }
};

static PyType_Slot IStorageFolderQueryOperations_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageFolderQueryOperations_dealloc },
    { Py_tp_new, IStorageFolderQueryOperations_new },
    { Py_tp_methods, IStorageFolderQueryOperations_methods },
    { Py_tp_getset, IStorageFolderQueryOperations_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageFolderQueryOperations_Type_spec =
{
    "IStorageFolderQueryOperations",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolderQueryOperations_Type_slots
};

// ----- IStorageQueryResultBase interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IStorageQueryResultBase>::python_type;

PyObject* IStorageQueryResultBase_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageQueryResultBase interface is not activatable");
    return nullptr;
}

static void IStorageQueryResultBase_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageQueryResultBase_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);
            
            self->obj.ApplyNewQueryOptions(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageQueryResultBase_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            
            auto return_value = self->obj.FindStartIndexAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageQueryResultBase_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetCurrentQueryOptions();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageQueryResultBase_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetItemCountAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IStorageQueryResultBase_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Folder();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageQueryResultBase_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.ContentsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageQueryResultBase_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.ContentsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageQueryResultBase_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.OptionsChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageQueryResultBase_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.OptionsChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IStorageQueryResultBase_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Storage::Search::IStorageQueryResultBase>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IStorageQueryResultBase_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)IStorageQueryResultBase_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)IStorageQueryResultBase_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)IStorageQueryResultBase_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)IStorageQueryResultBase_GetItemCountAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)IStorageQueryResultBase_add_ContentsChanged, METH_O, nullptr },
    { "remove_ContentsChanged", (PyCFunction)IStorageQueryResultBase_remove_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)IStorageQueryResultBase_add_OptionsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)IStorageQueryResultBase_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__IStorageQueryResultBase_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IStorageQueryResultBase_getset[] = {
    { const_cast<char*>("Folder"), (getter)IStorageQueryResultBase_get_Folder, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IStorageQueryResultBase_Type_slots[] = 
{
    { Py_tp_dealloc, IStorageQueryResultBase_dealloc },
    { Py_tp_new, IStorageQueryResultBase_new },
    { Py_tp_methods, IStorageQueryResultBase_methods },
    { Py_tp_getset, IStorageQueryResultBase_getset },
    { 0, nullptr },
};

static PyType_Spec IStorageQueryResultBase_Type_spec =
{
    "IStorageQueryResultBase",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageQueryResultBase_Type_slots
};

// ----- SortEntry struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::SortEntry>::python_type;

PyObject* py::converter<winrt::Windows::Storage::Search::SortEntry>::convert(winrt::Windows::Storage::Search::SortEntry instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Storage::Search::SortEntry>(instance, py::get_python_type<winrt::Windows::Storage::Search::SortEntry>());
}

winrt::Windows::Storage::Search::SortEntry py::converter<winrt::Windows::Storage::Search::SortEntry>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Storage::Search::SortEntry>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Storage::Search::SortEntry new_value{};
    
    PyObject* py_PropertyName = PyDict_GetItemString(obj, "PropertyName");
    if (!py_PropertyName) { throw winrt::hresult_invalid_argument(); }
    new_value.PropertyName = converter<winrt::hstring>::convert_to(py_PropertyName);
    
    PyObject* py_AscendingOrder = PyDict_GetItemString(obj, "AscendingOrder");
    if (!py_AscendingOrder) { throw winrt::hresult_invalid_argument(); }
    new_value.AscendingOrder = converter<bool>::convert_to(py_AscendingOrder);
    
    return new_value;
}

PyObject* SortEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Storage::Search::SortEntry instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Storage::Search::SortEntry>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    winrt::hstring _PropertyName{};
    bool _AscendingOrder{};
    
    static char* kwlist[] = {"PropertyName", "AscendingOrder", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "up", kwlist, &_PropertyName, &_AscendingOrder))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Storage::Search::SortEntry instance{ _PropertyName, _AscendingOrder };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SortEntry_get_PropertyName(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.PropertyName);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SortEntry_set_PropertyName(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.PropertyName = py::converter<winrt::hstring>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SortEntry_get_AscendingOrder(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.AscendingOrder);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SortEntry_set_AscendingOrder(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.AscendingOrder = py::converter<bool>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef SortEntry_getset[] = {
    { const_cast<char*>("PropertyName"), (getter)SortEntry_get_PropertyName, (setter)SortEntry_set_PropertyName, nullptr, nullptr },
    { const_cast<char*>("AscendingOrder"), (getter)SortEntry_get_AscendingOrder, (setter)SortEntry_set_AscendingOrder, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SortEntry_Type_slots[] = 
{
    { Py_tp_new, SortEntry_new },
    { Py_tp_getset, SortEntry_getset },
    { 0, nullptr },
};

static PyType_Spec SortEntry_Type_spec =
{
    "SortEntry",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    SortEntry_Type_slots
};

// ----- Windows.Storage.Search Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&ContentIndexer_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ContentIndexer", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ContentIndexer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ContentIndexerQuery_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ContentIndexerQuery", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ContentIndexerQuery>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IndexableContent_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IndexableContent", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IndexableContent>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&QueryOptions_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "QueryOptions", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::QueryOptions>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SortEntryVector_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SortEntryVector", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::SortEntryVector>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StorageFileQueryResult_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFileQueryResult", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageFileQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StorageFolderQueryResult_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFolderQueryResult", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageFolderQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StorageItemQueryResult_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageItemQueryResult", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageItemQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StorageLibraryChangeTrackerTriggerDetails_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryChangeTrackerTriggerDetails", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StorageLibraryContentChangedTriggerDetails_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryContentChangedTriggerDetails", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ValueAndLanguage_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ValueAndLanguage", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ValueAndLanguage>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IIndexableContent_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IIndexableContent", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IIndexableContent>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IStorageFolderQueryOperations_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFolderQueryOperations", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IStorageQueryResultBase_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageQueryResultBase", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IStorageQueryResultBase>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&SortEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SortEntry", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::SortEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Storage.Search");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Storage_Search",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Storage_Search(void)
{
    return PyModuleDef_Init(&module_def);
}
