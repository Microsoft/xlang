// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Graphics.Imaging.h"

// ----- BitmapBuffer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type;

static PyObject* BitmapBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapBuffer is not activatable");
    return nullptr;
}

static void BitmapBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapBuffer_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CreateReference();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapBuffer_GetPlaneCount(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPlaneCount();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapBuffer_GetPlaneDescription(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);
            
            auto return_value = self->obj.GetPlaneDescription(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __BitmapBuffer_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapBuffer_enter(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __BitmapBuffer_exit(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapBuffer_methods[] = {
    { "Close", (PyCFunction)BitmapBuffer_Close, METH_VARARGS, nullptr },
    { "CreateReference", (PyCFunction)BitmapBuffer_CreateReference, METH_VARARGS, nullptr },
    { "GetPlaneCount", (PyCFunction)BitmapBuffer_GetPlaneCount, METH_VARARGS, nullptr },
    { "GetPlaneDescription", (PyCFunction)BitmapBuffer_GetPlaneDescription, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__BitmapBuffer_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__BitmapBuffer_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__BitmapBuffer_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapBuffer_getset[] = {
    { nullptr }
};

static PyType_Slot BitmapBuffer_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapBuffer_dealloc },
    { Py_tp_new, BitmapBuffer_new },
    { Py_tp_methods, BitmapBuffer_methods },
    { Py_tp_getset, BitmapBuffer_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapBuffer_Type_spec =
{
    "BitmapBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapBuffer_Type_slots
};

// ----- BitmapCodecInformation class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type;

static PyObject* BitmapCodecInformation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapCodecInformation is not activatable");
    return nullptr;
}

static void BitmapCodecInformation_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapCodecInformation_get_CodecId(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CodecId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapCodecInformation_get_FileExtensions(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FileExtensions();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapCodecInformation_get_FriendlyName(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FriendlyName();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapCodecInformation_get_MimeTypes(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MimeTypes();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapCodecInformation_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapCodecInformation_methods[] = {
    { "_from", (PyCFunction)__BitmapCodecInformation_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapCodecInformation_getset[] = {
    { const_cast<char*>("CodecId"), (getter)BitmapCodecInformation_get_CodecId, nullptr, nullptr, nullptr },
    { const_cast<char*>("FileExtensions"), (getter)BitmapCodecInformation_get_FileExtensions, nullptr, nullptr, nullptr },
    { const_cast<char*>("FriendlyName"), (getter)BitmapCodecInformation_get_FriendlyName, nullptr, nullptr, nullptr },
    { const_cast<char*>("MimeTypes"), (getter)BitmapCodecInformation_get_MimeTypes, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapCodecInformation_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapCodecInformation_dealloc },
    { Py_tp_new, BitmapCodecInformation_new },
    { Py_tp_methods, BitmapCodecInformation_methods },
    { Py_tp_getset, BitmapCodecInformation_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapCodecInformation_Type_spec =
{
    "BitmapCodecInformation",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapCodecInformation_Type_slots
};

// ----- BitmapDecoder class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type;

static PyObject* BitmapDecoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapDecoder is not activatable");
    return nullptr;
}

static void BitmapDecoder_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapDecoder_CreateAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetDecoderInformationEnumerator(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::GetDecoderInformationEnumerator();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetFrameAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetFrameAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPixelDataAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetPreviewAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPreviewAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetSoftwareBitmapAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetThumbnailAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapDecoder_get_BitmapContainerProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapContainerProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_DecoderInformation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DecoderInformation();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_FrameCount(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.FrameCount();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiX();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiY();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_BmpDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::BmpDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_GifDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::GifDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_IcoDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::IcoDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_JpegDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_JpegXRDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegXRDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_PngDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::PngDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_TiffDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::TiffDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_HeifDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::HeifDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_get_WebpDecoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::WebpDecoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapDecoder_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapDecoder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapDecoder_methods[] = {
    { "CreateAsync", (PyCFunction)BitmapDecoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetDecoderInformationEnumerator", (PyCFunction)BitmapDecoder_GetDecoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFrameAsync", (PyCFunction)BitmapDecoder_GetFrameAsync, METH_VARARGS, nullptr },
    { "GetPixelDataAsync", (PyCFunction)BitmapDecoder_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetPreviewAsync", (PyCFunction)BitmapDecoder_GetPreviewAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)BitmapDecoder_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)BitmapDecoder_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_BmpDecoderId", (PyCFunction)BitmapDecoder_get_BmpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_GifDecoderId", (PyCFunction)BitmapDecoder_get_GifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_IcoDecoderId", (PyCFunction)BitmapDecoder_get_IcoDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegDecoderId", (PyCFunction)BitmapDecoder_get_JpegDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegXRDecoderId", (PyCFunction)BitmapDecoder_get_JpegXRDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_PngDecoderId", (PyCFunction)BitmapDecoder_get_PngDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_TiffDecoderId", (PyCFunction)BitmapDecoder_get_TiffDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HeifDecoderId", (PyCFunction)BitmapDecoder_get_HeifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_WebpDecoderId", (PyCFunction)BitmapDecoder_get_WebpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__BitmapDecoder_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapDecoder_getset[] = {
    { const_cast<char*>("BitmapContainerProperties"), (getter)BitmapDecoder_get_BitmapContainerProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("DecoderInformation"), (getter)BitmapDecoder_get_DecoderInformation, nullptr, nullptr, nullptr },
    { const_cast<char*>("FrameCount"), (getter)BitmapDecoder_get_FrameCount, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapAlphaMode"), (getter)BitmapDecoder_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)BitmapDecoder_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapProperties"), (getter)BitmapDecoder_get_BitmapProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiX"), (getter)BitmapDecoder_get_DpiX, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiY"), (getter)BitmapDecoder_get_DpiY, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelHeight"), (getter)BitmapDecoder_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelWidth"), (getter)BitmapDecoder_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelHeight"), (getter)BitmapDecoder_get_PixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelWidth"), (getter)BitmapDecoder_get_PixelWidth, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapDecoder_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapDecoder_dealloc },
    { Py_tp_new, BitmapDecoder_new },
    { Py_tp_methods, BitmapDecoder_methods },
    { Py_tp_getset, BitmapDecoder_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapDecoder_Type_spec =
{
    "BitmapDecoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapDecoder_Type_slots
};

// ----- BitmapEncoder class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type;

static PyObject* BitmapEncoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapEncoder is not activatable");
    return nullptr;
}

static void BitmapEncoder_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapEncoder_CreateAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 2);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_CreateForInPlacePropertyEncodingAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 0);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForInPlacePropertyEncodingAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_CreateForTranscodingAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 1);
            
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForTranscodingAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_FlushAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_GetEncoderInformationEnumerator(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::GetEncoderInformationEnumerator();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_GoToNextFrameAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GoToNextFrameAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);
            
            auto return_value = self->obj.GoToNextFrameAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_SetPixelData(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 7)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            auto param4 = py::convert_to<double>(args, 4);
            auto param5 = py::convert_to<double>(args, 5);
            auto _param6 = py::convert_to<winrt::com_array<uint8_t>>(args, 6);
            auto param6 = winrt::array_view<const uint8_t>(_param6.begin(), _param6.end());
            
            self->obj.SetPixelData(param0, param1, param2, param3, param4, param5, param6);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_SetSoftwareBitmap(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            
            self->obj.SetSoftwareBitmap(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapEncoder_get_IsThumbnailGenerated(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsThumbnailGenerated();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapEncoder_put_IsThumbnailGenerated(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<bool>(arg);
        
        self->obj.IsThumbnailGenerated(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapEncoder_get_GeneratedThumbnailWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeneratedThumbnailWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapEncoder_put_GeneratedThumbnailWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.GeneratedThumbnailWidth(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapEncoder_get_GeneratedThumbnailHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeneratedThumbnailHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapEncoder_put_GeneratedThumbnailHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.GeneratedThumbnailHeight(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapEncoder_get_BitmapContainerProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapContainerProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_BitmapTransform(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapTransform();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_EncoderInformation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.EncoderInformation();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_BmpEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::BmpEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_GifEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::GifEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_JpegEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_JpegXREncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegXREncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_PngEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::PngEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_TiffEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::TiffEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_get_HeifEncoderId(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::HeifEncoderId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapEncoder_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapEncoder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapEncoder_methods[] = {
    { "CreateAsync", (PyCFunction)BitmapEncoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateForInPlacePropertyEncodingAsync", (PyCFunction)BitmapEncoder_CreateForInPlacePropertyEncodingAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateForTranscodingAsync", (PyCFunction)BitmapEncoder_CreateForTranscodingAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "FlushAsync", (PyCFunction)BitmapEncoder_FlushAsync, METH_VARARGS, nullptr },
    { "GetEncoderInformationEnumerator", (PyCFunction)BitmapEncoder_GetEncoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
    { "GoToNextFrameAsync", (PyCFunction)BitmapEncoder_GoToNextFrameAsync, METH_VARARGS, nullptr },
    { "SetPixelData", (PyCFunction)BitmapEncoder_SetPixelData, METH_VARARGS, nullptr },
    { "SetSoftwareBitmap", (PyCFunction)BitmapEncoder_SetSoftwareBitmap, METH_VARARGS, nullptr },
    { "get_BmpEncoderId", (PyCFunction)BitmapEncoder_get_BmpEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_GifEncoderId", (PyCFunction)BitmapEncoder_get_GifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegEncoderId", (PyCFunction)BitmapEncoder_get_JpegEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegXREncoderId", (PyCFunction)BitmapEncoder_get_JpegXREncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_PngEncoderId", (PyCFunction)BitmapEncoder_get_PngEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_TiffEncoderId", (PyCFunction)BitmapEncoder_get_TiffEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HeifEncoderId", (PyCFunction)BitmapEncoder_get_HeifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__BitmapEncoder_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapEncoder_getset[] = {
    { const_cast<char*>("IsThumbnailGenerated"), (getter)BitmapEncoder_get_IsThumbnailGenerated, (setter)BitmapEncoder_put_IsThumbnailGenerated, nullptr, nullptr },
    { const_cast<char*>("GeneratedThumbnailWidth"), (getter)BitmapEncoder_get_GeneratedThumbnailWidth, (setter)BitmapEncoder_put_GeneratedThumbnailWidth, nullptr, nullptr },
    { const_cast<char*>("GeneratedThumbnailHeight"), (getter)BitmapEncoder_get_GeneratedThumbnailHeight, (setter)BitmapEncoder_put_GeneratedThumbnailHeight, nullptr, nullptr },
    { const_cast<char*>("BitmapContainerProperties"), (getter)BitmapEncoder_get_BitmapContainerProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapProperties"), (getter)BitmapEncoder_get_BitmapProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapTransform"), (getter)BitmapEncoder_get_BitmapTransform, nullptr, nullptr, nullptr },
    { const_cast<char*>("EncoderInformation"), (getter)BitmapEncoder_get_EncoderInformation, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapEncoder_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapEncoder_dealloc },
    { Py_tp_new, BitmapEncoder_new },
    { Py_tp_methods, BitmapEncoder_methods },
    { Py_tp_getset, BitmapEncoder_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapEncoder_Type_spec =
{
    "BitmapEncoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapEncoder_Type_slots
};

// ----- BitmapFrame class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type;

static PyObject* BitmapFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapFrame is not activatable");
    return nullptr;
}

static void BitmapFrame_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapFrame_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPixelDataAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapFrame_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetSoftwareBitmapAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapFrame_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetThumbnailAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapFrame_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiX();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiY();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapFrame_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapFrame_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)BitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)BitmapFrame_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)BitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__BitmapFrame_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapFrame_getset[] = {
    { const_cast<char*>("BitmapAlphaMode"), (getter)BitmapFrame_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)BitmapFrame_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapProperties"), (getter)BitmapFrame_get_BitmapProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiX"), (getter)BitmapFrame_get_DpiX, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiY"), (getter)BitmapFrame_get_DpiY, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelHeight"), (getter)BitmapFrame_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelWidth"), (getter)BitmapFrame_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelHeight"), (getter)BitmapFrame_get_PixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelWidth"), (getter)BitmapFrame_get_PixelWidth, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapFrame_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapFrame_dealloc },
    { Py_tp_new, BitmapFrame_new },
    { Py_tp_methods, BitmapFrame_methods },
    { Py_tp_getset, BitmapFrame_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapFrame_Type_spec =
{
    "BitmapFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapFrame_Type_slots
};

// ----- BitmapProperties class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type;

static PyObject* BitmapProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapProperties is not activatable");
    return nullptr;
}

static void BitmapProperties_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapProperties_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
            
            auto return_value = self->obj.GetPropertiesAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapProperties_SetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);
            
            auto return_value = self->obj.SetPropertiesAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __BitmapProperties_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapProperties_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)BitmapProperties_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "SetPropertiesAsync", (PyCFunction)BitmapProperties_SetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__BitmapProperties_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapProperties_getset[] = {
    { nullptr }
};

static PyType_Slot BitmapProperties_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapProperties_dealloc },
    { Py_tp_new, BitmapProperties_new },
    { Py_tp_methods, BitmapProperties_methods },
    { Py_tp_getset, BitmapProperties_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapProperties_Type_spec =
{
    "BitmapProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapProperties_Type_slots
};

// ----- BitmapPropertiesView class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type;

static PyObject* BitmapPropertiesView_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapPropertiesView is not activatable");
    return nullptr;
}

static void BitmapPropertiesView_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapPropertiesView_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
            
            auto return_value = self->obj.GetPropertiesAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __BitmapPropertiesView_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapPropertiesView_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)BitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__BitmapPropertiesView_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapPropertiesView_getset[] = {
    { nullptr }
};

static PyType_Slot BitmapPropertiesView_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapPropertiesView_dealloc },
    { Py_tp_new, BitmapPropertiesView_new },
    { Py_tp_methods, BitmapPropertiesView_methods },
    { Py_tp_getset, BitmapPropertiesView_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapPropertiesView_Type_spec =
{
    "BitmapPropertiesView",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPropertiesView_Type_slots
};

// ----- BitmapPropertySet class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type;

static PyObject* BitmapPropertySet_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertySet instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void BitmapPropertySet_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapPropertySet_Clear(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_First(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_GetView(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_HasKey(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.HasKey(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_Insert(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(args, 1);
            
            auto return_value = self->obj.Insert(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_Lookup(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.Lookup(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_Remove(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* BitmapPropertySet_get_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapPropertySet_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapPropertySet>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapPropertySet_iter(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __BitmapPropertySet_mp_length(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __BitmapPropertySet_mp_subscript(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* key)
{
    try
    {
        return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __BitmapPropertySet_mp_ass_item(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* key, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.Remove(py::convert_to<winrt::hstring>(key)); }
        else { self->obj.Insert(py::convert_to<winrt::hstring>(key), py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(value)); }
        return 0;
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef BitmapPropertySet_methods[] = {
    { "Clear", (PyCFunction)BitmapPropertySet_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)BitmapPropertySet_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)BitmapPropertySet_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)BitmapPropertySet_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)BitmapPropertySet_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)BitmapPropertySet_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)BitmapPropertySet_Remove, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__BitmapPropertySet_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapPropertySet_getset[] = {
    { const_cast<char*>("Size"), (getter)BitmapPropertySet_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapPropertySet_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapPropertySet_dealloc },
    { Py_tp_new, BitmapPropertySet_new },
    { Py_tp_methods, BitmapPropertySet_methods },
    { Py_tp_getset, BitmapPropertySet_getset },
    { Py_tp_iter, __BitmapPropertySet_iter },
    { Py_mp_length, __BitmapPropertySet_mp_length },
    { Py_mp_subscript, __BitmapPropertySet_mp_subscript },
    { Py_mp_ass_subscript, __BitmapPropertySet_mp_ass_item },
    { 0, nullptr },
};

static PyType_Spec BitmapPropertySet_Type_spec =
{
    "BitmapPropertySet",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPropertySet_Type_slots
};

// ----- BitmapTransform class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type;

static PyObject* BitmapTransform_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapTransform instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void BitmapTransform_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapTransform_get_ScaledWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ScaledWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_ScaledWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.ScaledWidth(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapTransform_get_ScaledHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ScaledHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_ScaledHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.ScaledHeight(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapTransform_get_Rotation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Rotation();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_Rotation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapRotation>(arg);
        
        self->obj.Rotation(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapTransform_get_InterpolationMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.InterpolationMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_InterpolationMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>(arg);
        
        self->obj.InterpolationMode(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapTransform_get_Flip(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Flip();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_Flip(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFlip>(arg);
        
        self->obj.Flip(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapTransform_get_Bounds(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Bounds();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapTransform_put_Bounds(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBounds>(arg);
        
        self->obj.Bounds(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* __BitmapTransform_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapTransform>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapTransform_methods[] = {
    { "_from", (PyCFunction)__BitmapTransform_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapTransform_getset[] = {
    { const_cast<char*>("ScaledWidth"), (getter)BitmapTransform_get_ScaledWidth, (setter)BitmapTransform_put_ScaledWidth, nullptr, nullptr },
    { const_cast<char*>("ScaledHeight"), (getter)BitmapTransform_get_ScaledHeight, (setter)BitmapTransform_put_ScaledHeight, nullptr, nullptr },
    { const_cast<char*>("Rotation"), (getter)BitmapTransform_get_Rotation, (setter)BitmapTransform_put_Rotation, nullptr, nullptr },
    { const_cast<char*>("InterpolationMode"), (getter)BitmapTransform_get_InterpolationMode, (setter)BitmapTransform_put_InterpolationMode, nullptr, nullptr },
    { const_cast<char*>("Flip"), (getter)BitmapTransform_get_Flip, (setter)BitmapTransform_put_Flip, nullptr, nullptr },
    { const_cast<char*>("Bounds"), (getter)BitmapTransform_get_Bounds, (setter)BitmapTransform_put_Bounds, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapTransform_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapTransform_dealloc },
    { Py_tp_new, BitmapTransform_new },
    { Py_tp_methods, BitmapTransform_methods },
    { Py_tp_getset, BitmapTransform_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapTransform_Type_spec =
{
    "BitmapTransform",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapTransform_Type_slots
};

// ----- BitmapTypedValue class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type;

static PyObject* BitmapTypedValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::PropertyType>(args, 1);
            
            winrt::Windows::Graphics::Imaging::BitmapTypedValue instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void BitmapTypedValue_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapTypedValue_get_Type(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Type();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapTypedValue_get_Value(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __BitmapTypedValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapTypedValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef BitmapTypedValue_methods[] = {
    { "_from", (PyCFunction)__BitmapTypedValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef BitmapTypedValue_getset[] = {
    { const_cast<char*>("Type"), (getter)BitmapTypedValue_get_Type, nullptr, nullptr, nullptr },
    { const_cast<char*>("Value"), (getter)BitmapTypedValue_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapTypedValue_Type_slots[] = 
{
    { Py_tp_dealloc, BitmapTypedValue_dealloc },
    { Py_tp_new, BitmapTypedValue_new },
    { Py_tp_methods, BitmapTypedValue_methods },
    { Py_tp_getset, BitmapTypedValue_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapTypedValue_Type_spec =
{
    "BitmapTypedValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapTypedValue_Type_slots
};

// ----- ImageStream class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type;

static PyObject* ImageStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageStream is not activatable");
    return nullptr;
}

static void ImageStream_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageStream_CloneStream(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.CloneStream();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.FlushAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetInputStreamAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = self->obj.GetOutputStreamAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);
            
            auto return_value = self->obj.ReadAsync(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_Seek(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            self->obj.Seek(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            auto return_value = self->obj.WriteAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* ImageStream_get_ContentType(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ContentType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageStream_get_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int ImageStream_put_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint64_t>(arg);
        
        self->obj.Size(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* ImageStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanRead();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CanWrite();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageStream_get_Position(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ImageStream_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::ImageStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __ImageStream_enter(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __ImageStream_exit(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ImageStream_methods[] = {
    { "CloneStream", (PyCFunction)ImageStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)ImageStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)ImageStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)ImageStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)ImageStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)ImageStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)ImageStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)ImageStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__ImageStream_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__ImageStream_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__ImageStream_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef ImageStream_getset[] = {
    { const_cast<char*>("ContentType"), (getter)ImageStream_get_ContentType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Size"), (getter)ImageStream_get_Size, (setter)ImageStream_put_Size, nullptr, nullptr },
    { const_cast<char*>("CanRead"), (getter)ImageStream_get_CanRead, nullptr, nullptr, nullptr },
    { const_cast<char*>("CanWrite"), (getter)ImageStream_get_CanWrite, nullptr, nullptr, nullptr },
    { const_cast<char*>("Position"), (getter)ImageStream_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot ImageStream_Type_slots[] = 
{
    { Py_tp_dealloc, ImageStream_dealloc },
    { Py_tp_new, ImageStream_new },
    { Py_tp_methods, ImageStream_methods },
    { Py_tp_getset, ImageStream_getset },
    { 0, nullptr },
};

static PyType_Spec ImageStream_Type_spec =
{
    "ImageStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageStream_Type_slots
};

// ----- PixelDataProvider class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type;

static PyObject* PixelDataProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PixelDataProvider is not activatable");
    return nullptr;
}

static void PixelDataProvider_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PixelDataProvider_DetachPixelData(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.DetachPixelData();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __PixelDataProvider_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::PixelDataProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef PixelDataProvider_methods[] = {
    { "DetachPixelData", (PyCFunction)PixelDataProvider_DetachPixelData, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__PixelDataProvider_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef PixelDataProvider_getset[] = {
    { nullptr }
};

static PyType_Slot PixelDataProvider_Type_slots[] = 
{
    { Py_tp_dealloc, PixelDataProvider_dealloc },
    { Py_tp_new, PixelDataProvider_new },
    { Py_tp_methods, PixelDataProvider_methods },
    { Py_tp_getset, PixelDataProvider_getset },
    { 0, nullptr },
};

static PyType_Spec PixelDataProvider_Type_spec =
{
    "PixelDataProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    PixelDataProvider_Type_slots
};

// ----- SoftwareBitmap class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type;

static PyObject* SoftwareBitmap_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            
            winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);
            
            winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void SoftwareBitmap_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SoftwareBitmap_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_Convert(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 2);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_Copy(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Copy(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyFromBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            self->obj.CopyFromBuffer(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyTo(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            
            self->obj.CopyTo(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyToBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            
            self->obj.CopyToBuffer(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_CreateCopyFromBuffer(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<int32_t>(args, 3);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<int32_t>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 4);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_CreateCopyFromSurfaceAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            
            auto return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_GetReadOnlyView(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetReadOnlyView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_LockBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>(args, 0);
            
            auto return_value = self->obj.LockBuffer(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* SoftwareBitmap_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiY();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SoftwareBitmap_put_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.DpiY(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SoftwareBitmap_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiX();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SoftwareBitmap_put_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.DpiX(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SoftwareBitmap_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SoftwareBitmap_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SoftwareBitmap_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.IsReadOnly();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SoftwareBitmap_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SoftwareBitmap_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SoftwareBitmap_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::SoftwareBitmap>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __SoftwareBitmap_enter(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* __SoftwareBitmap_exit(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self)
{
    try
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef SoftwareBitmap_methods[] = {
    { "Close", (PyCFunction)SoftwareBitmap_Close, METH_VARARGS, nullptr },
    { "Convert", (PyCFunction)SoftwareBitmap_Convert, METH_VARARGS | METH_STATIC, nullptr },
    { "Copy", (PyCFunction)SoftwareBitmap_Copy, METH_VARARGS | METH_STATIC, nullptr },
    { "CopyFromBuffer", (PyCFunction)SoftwareBitmap_CopyFromBuffer, METH_VARARGS, nullptr },
    { "CopyTo", (PyCFunction)SoftwareBitmap_CopyTo, METH_VARARGS, nullptr },
    { "CopyToBuffer", (PyCFunction)SoftwareBitmap_CopyToBuffer, METH_VARARGS, nullptr },
    { "CreateCopyFromBuffer", (PyCFunction)SoftwareBitmap_CreateCopyFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateCopyFromSurfaceAsync", (PyCFunction)SoftwareBitmap_CreateCopyFromSurfaceAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetReadOnlyView", (PyCFunction)SoftwareBitmap_GetReadOnlyView, METH_VARARGS, nullptr },
    { "LockBuffer", (PyCFunction)SoftwareBitmap_LockBuffer, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__SoftwareBitmap_from, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)__SoftwareBitmap_enter, METH_O, nullptr },
    { "__exit__",  (PyCFunction)__SoftwareBitmap_exit,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef SoftwareBitmap_getset[] = {
    { const_cast<char*>("DpiY"), (getter)SoftwareBitmap_get_DpiY, (setter)SoftwareBitmap_put_DpiY, nullptr, nullptr },
    { const_cast<char*>("DpiX"), (getter)SoftwareBitmap_get_DpiX, (setter)SoftwareBitmap_put_DpiX, nullptr, nullptr },
    { const_cast<char*>("BitmapAlphaMode"), (getter)SoftwareBitmap_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)SoftwareBitmap_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("IsReadOnly"), (getter)SoftwareBitmap_get_IsReadOnly, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelHeight"), (getter)SoftwareBitmap_get_PixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelWidth"), (getter)SoftwareBitmap_get_PixelWidth, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SoftwareBitmap_Type_slots[] = 
{
    { Py_tp_dealloc, SoftwareBitmap_dealloc },
    { Py_tp_new, SoftwareBitmap_new },
    { Py_tp_methods, SoftwareBitmap_methods },
    { Py_tp_getset, SoftwareBitmap_getset },
    { 0, nullptr },
};

static PyType_Spec SoftwareBitmap_Type_spec =
{
    "SoftwareBitmap",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>),
    0,
    Py_TPFLAGS_DEFAULT,
    SoftwareBitmap_Type_slots
};

// ----- IBitmapFrame interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type;

PyObject* IBitmapFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapFrame interface is not activatable");
    return nullptr;
}

static void IBitmapFrame_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapFrame_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPixelDataAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IBitmapFrame_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetThumbnailAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IBitmapFrame_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiX();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiY();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IBitmapFrame_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IBitmapFrame_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)IBitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IBitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IBitmapFrame_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IBitmapFrame_getset[] = {
    { const_cast<char*>("BitmapAlphaMode"), (getter)IBitmapFrame_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)IBitmapFrame_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapProperties"), (getter)IBitmapFrame_get_BitmapProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiX"), (getter)IBitmapFrame_get_DpiX, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiY"), (getter)IBitmapFrame_get_DpiY, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelHeight"), (getter)IBitmapFrame_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelWidth"), (getter)IBitmapFrame_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelHeight"), (getter)IBitmapFrame_get_PixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelWidth"), (getter)IBitmapFrame_get_PixelWidth, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IBitmapFrame_Type_slots[] = 
{
    { Py_tp_dealloc, IBitmapFrame_dealloc },
    { Py_tp_new, IBitmapFrame_new },
    { Py_tp_methods, IBitmapFrame_methods },
    { Py_tp_getset, IBitmapFrame_getset },
    { 0, nullptr },
};

static PyType_Spec IBitmapFrame_Type_spec =
{
    "IBitmapFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapFrame_Type_slots
};

// ----- IBitmapFrameWithSoftwareBitmap interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type;

PyObject* IBitmapFrameWithSoftwareBitmap_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapFrameWithSoftwareBitmap interface is not activatable");
    return nullptr;
}

static void IBitmapFrameWithSoftwareBitmap_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetPixelDataAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetSoftwareBitmapAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);
            
            auto return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetThumbnailAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapAlphaMode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapPixelFormat();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.BitmapProperties();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiX();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DpiY();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.OrientedPixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelHeight();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PixelWidth();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IBitmapFrameWithSoftwareBitmap_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IBitmapFrameWithSoftwareBitmap_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IBitmapFrameWithSoftwareBitmap_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IBitmapFrameWithSoftwareBitmap_getset[] = {
    { const_cast<char*>("BitmapAlphaMode"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapPixelFormat"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
    { const_cast<char*>("BitmapProperties"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapProperties, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiX"), (getter)IBitmapFrameWithSoftwareBitmap_get_DpiX, nullptr, nullptr, nullptr },
    { const_cast<char*>("DpiY"), (getter)IBitmapFrameWithSoftwareBitmap_get_DpiY, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelHeight"), (getter)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("OrientedPixelWidth"), (getter)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelHeight"), (getter)IBitmapFrameWithSoftwareBitmap_get_PixelHeight, nullptr, nullptr, nullptr },
    { const_cast<char*>("PixelWidth"), (getter)IBitmapFrameWithSoftwareBitmap_get_PixelWidth, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IBitmapFrameWithSoftwareBitmap_Type_slots[] = 
{
    { Py_tp_dealloc, IBitmapFrameWithSoftwareBitmap_dealloc },
    { Py_tp_new, IBitmapFrameWithSoftwareBitmap_new },
    { Py_tp_methods, IBitmapFrameWithSoftwareBitmap_methods },
    { Py_tp_getset, IBitmapFrameWithSoftwareBitmap_getset },
    { 0, nullptr },
};

static PyType_Spec IBitmapFrameWithSoftwareBitmap_Type_spec =
{
    "IBitmapFrameWithSoftwareBitmap",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapFrameWithSoftwareBitmap_Type_slots
};

// ----- IBitmapPropertiesView interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type;

PyObject* IBitmapPropertiesView_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapPropertiesView interface is not activatable");
    return nullptr;
}

static void IBitmapPropertiesView_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapPropertiesView_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
            
            auto return_value = self->obj.GetPropertiesAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __IBitmapPropertiesView_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IBitmapPropertiesView_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)IBitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IBitmapPropertiesView_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IBitmapPropertiesView_getset[] = {
    { nullptr }
};

static PyType_Slot IBitmapPropertiesView_Type_slots[] = 
{
    { Py_tp_dealloc, IBitmapPropertiesView_dealloc },
    { Py_tp_new, IBitmapPropertiesView_new },
    { Py_tp_methods, IBitmapPropertiesView_methods },
    { Py_tp_getset, IBitmapPropertiesView_getset },
    { 0, nullptr },
};

static PyType_Spec IBitmapPropertiesView_Type_spec =
{
    "IBitmapPropertiesView",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapPropertiesView_Type_slots
};

// ----- BitmapBounds struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert(winrt::Windows::Graphics::Imaging::BitmapBounds instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapBounds>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>());
}

winrt::Windows::Graphics::Imaging::BitmapBounds py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapBounds new_value{};
    
    PyObject* py_X = PyDict_GetItemString(obj, "X");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<uint32_t>::convert_to(py_X);
    
    PyObject* py_Y = PyDict_GetItemString(obj, "Y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<uint32_t>::convert_to(py_Y);
    
    PyObject* py_Width = PyDict_GetItemString(obj, "Width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<uint32_t>::convert_to(py_Width);
    
    PyObject* py_Height = PyDict_GetItemString(obj, "Height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<uint32_t>::convert_to(py_Height);
    
    return new_value;
}

PyObject* BitmapBounds_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    uint32_t _X{};
    uint32_t _Y{};
    uint32_t _Width{};
    uint32_t _Height{};
    
    static char* kwlist[] = {"X", "Y", "Width", "Height", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", kwlist, &_X, &_Y, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapBounds instance{ _X, _Y, _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapBounds_get_X(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_X(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Y(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Y(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapBounds_getset[] = {
    { const_cast<char*>("X"), (getter)BitmapBounds_get_X, (setter)BitmapBounds_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)BitmapBounds_get_Y, (setter)BitmapBounds_set_Y, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)BitmapBounds_get_Width, (setter)BitmapBounds_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapBounds_get_Height, (setter)BitmapBounds_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapBounds_Type_slots[] = 
{
    { Py_tp_new, BitmapBounds_new },
    { Py_tp_getset, BitmapBounds_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapBounds_Type_spec =
{
    "BitmapBounds",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapBounds_Type_slots
};

// ----- BitmapPlaneDescription struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert(winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>());
}

winrt::Windows::Graphics::Imaging::BitmapPlaneDescription py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapPlaneDescription new_value{};
    
    PyObject* py_StartIndex = PyDict_GetItemString(obj, "StartIndex");
    if (!py_StartIndex) { throw winrt::hresult_invalid_argument(); }
    new_value.StartIndex = converter<int32_t>::convert_to(py_StartIndex);
    
    PyObject* py_Width = PyDict_GetItemString(obj, "Width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<int32_t>::convert_to(py_Width);
    
    PyObject* py_Height = PyDict_GetItemString(obj, "Height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<int32_t>::convert_to(py_Height);
    
    PyObject* py_Stride = PyDict_GetItemString(obj, "Stride");
    if (!py_Stride) { throw winrt::hresult_invalid_argument(); }
    new_value.Stride = converter<int32_t>::convert_to(py_Stride);
    
    return new_value;
}

PyObject* BitmapPlaneDescription_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    int32_t _StartIndex{};
    int32_t _Width{};
    int32_t _Height{};
    int32_t _Stride{};
    
    static char* kwlist[] = {"StartIndex", "Width", "Height", "Stride", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", kwlist, &_StartIndex, &_Width, &_Height, &_Stride))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance{ _StartIndex, _Width, _Height, _Stride };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapPlaneDescription_get_StartIndex(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.StartIndex);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_StartIndex(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.StartIndex = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Stride(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Stride);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Stride(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Stride = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapPlaneDescription_getset[] = {
    { const_cast<char*>("StartIndex"), (getter)BitmapPlaneDescription_get_StartIndex, (setter)BitmapPlaneDescription_set_StartIndex, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)BitmapPlaneDescription_get_Width, (setter)BitmapPlaneDescription_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapPlaneDescription_get_Height, (setter)BitmapPlaneDescription_set_Height, nullptr, nullptr },
    { const_cast<char*>("Stride"), (getter)BitmapPlaneDescription_get_Stride, (setter)BitmapPlaneDescription_set_Stride, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapPlaneDescription_Type_slots[] = 
{
    { Py_tp_new, BitmapPlaneDescription_new },
    { Py_tp_getset, BitmapPlaneDescription_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapPlaneDescription_Type_spec =
{
    "BitmapPlaneDescription",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPlaneDescription_Type_slots
};

// ----- BitmapSize struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert(winrt::Windows::Graphics::Imaging::BitmapSize instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapSize>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>());
}

winrt::Windows::Graphics::Imaging::BitmapSize py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapSize new_value{};
    
    PyObject* py_Width = PyDict_GetItemString(obj, "Width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<uint32_t>::convert_to(py_Width);
    
    PyObject* py_Height = PyDict_GetItemString(obj, "Height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<uint32_t>::convert_to(py_Height);
    
    return new_value;
}

PyObject* BitmapSize_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapSize instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    uint32_t _Width{};
    uint32_t _Height{};
    
    static char* kwlist[] = {"Width", "Height", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", kwlist, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapSize instance{ _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapSize_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapSize_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapSize_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapSize_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapSize_getset[] = {
    { const_cast<char*>("Width"), (getter)BitmapSize_get_Width, (setter)BitmapSize_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapSize_get_Height, (setter)BitmapSize_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapSize_Type_slots[] = 
{
    { Py_tp_new, BitmapSize_new },
    { Py_tp_getset, BitmapSize_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapSize_Type_spec =
{
    "BitmapSize",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapSize_Type_slots
};

// ----- Windows.Graphics.Imaging Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&BitmapBuffer_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapBuffer", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapCodecInformation_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapCodecInformation", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapDecoder_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapDecoder", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapEncoder_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapEncoder", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapFrame_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapFrame", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapProperties_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapProperties", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapPropertiesView_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPropertiesView", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapPropertySet_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPropertySet", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapTransform_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapTransform", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&BitmapTypedValue_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapTypedValue", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&ImageStream_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageStream", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&PixelDataProvider_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PixelDataProvider", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&SoftwareBitmap_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SoftwareBitmap", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IBitmapFrame_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapFrame", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IBitmapFrameWithSoftwareBitmap_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapFrameWithSoftwareBitmap", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IBitmapPropertiesView_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapPropertiesView", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&BitmapBounds_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapBounds", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&BitmapPlaneDescription_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPlaneDescription", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&BitmapSize_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapSize", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Graphics.Imaging");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Graphics_Imaging",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Graphics_Imaging(void)
{
    return PyModuleDef_Init(&module_def);
}
