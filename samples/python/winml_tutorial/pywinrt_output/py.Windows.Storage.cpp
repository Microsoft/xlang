// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.h"

// ----- AppDataPaths class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type;


PyObject* AppDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "AppDataPaths is not activatable");
    return nullptr;
}

static void AppDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* AppDataPaths__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::AppDataPaths>::convert(instance.as<winrt::Windows::Storage::AppDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::AppDataPaths return_value = winrt::Windows::Storage::AppDataPaths::GetDefault();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

            winrt::Windows::Storage::AppDataPaths return_value = winrt::Windows::Storage::AppDataPaths::GetForUser(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* AppDataPaths_get_Cookies(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Cookies();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_Desktop(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Desktop();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_Documents(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Documents();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_Favorites(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Favorites();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_History(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.History();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_InternetCache(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.InternetCache();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_LocalAppData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.LocalAppData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_ProgramData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ProgramData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* AppDataPaths_get_RoamingAppData(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.RoamingAppData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef AppDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)AppDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "GetForUser", (PyCFunction)AppDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Cookies", (PyCFunction)AppDataPaths_get_Cookies, METH_NOARGS, nullptr },
    { "get_Desktop", (PyCFunction)AppDataPaths_get_Desktop, METH_NOARGS, nullptr },
    { "get_Documents", (PyCFunction)AppDataPaths_get_Documents, METH_NOARGS, nullptr },
    { "get_Favorites", (PyCFunction)AppDataPaths_get_Favorites, METH_NOARGS, nullptr },
    { "get_History", (PyCFunction)AppDataPaths_get_History, METH_NOARGS, nullptr },
    { "get_InternetCache", (PyCFunction)AppDataPaths_get_InternetCache, METH_NOARGS, nullptr },
    { "get_LocalAppData", (PyCFunction)AppDataPaths_get_LocalAppData, METH_NOARGS, nullptr },
    { "get_ProgramData", (PyCFunction)AppDataPaths_get_ProgramData, METH_NOARGS, nullptr },
    { "get_RoamingAppData", (PyCFunction)AppDataPaths_get_RoamingAppData, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)AppDataPaths__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot AppDataPaths_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, AppDataPaths_dealloc },
    { Py_tp_new, AppDataPaths_new },
    { Py_tp_methods, AppDataPaths_methods },
    { 0, nullptr },
};

static PyType_Spec AppDataPaths_Type_spec =
{
    "AppDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::AppDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    AppDataPaths_Type_slots
};

// ----- ApplicationData class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type;


PyObject* ApplicationData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationData is not activatable");
    return nullptr;
}

static void ApplicationData_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationData__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::ApplicationData>::convert(instance.as<winrt::Windows::Storage::ApplicationData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationData_ClearAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.ClearAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.ClearAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.ClearPublisherCacheFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::ApplicationData> return_value = winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_GetPublisherCacheFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Storage::StorageFolder return_value = self->obj.GetPublisherCacheFolder(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_SetVersionAsync(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.SetVersionAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_SignalDataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.SignalDataChanged();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationData_add_DataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.DataChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::ApplicationData return_value = winrt::Windows::Storage::ApplicationData::Current();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_LocalCacheFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.LocalCacheFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_LocalFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.LocalFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_LocalSettings(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::ApplicationDataContainer return_value = self->obj.LocalSettings();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_RoamingFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.RoamingFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_RoamingSettings(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::ApplicationDataContainer return_value = self->obj.RoamingSettings();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_RoamingStorageQuota(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.RoamingStorageQuota();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_SharedLocalFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.SharedLocalFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_TemporaryFolder(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.TemporaryFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_get_Version(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Version();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationData_remove_DataChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.DataChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ApplicationData_methods[] = {
    { "ClearAsync", (PyCFunction)ApplicationData_ClearAsync, METH_VARARGS, nullptr },
    { "ClearPublisherCacheFolderAsync", (PyCFunction)ApplicationData_ClearPublisherCacheFolderAsync, METH_VARARGS, nullptr },
    { "GetForUserAsync", (PyCFunction)ApplicationData_GetForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetPublisherCacheFolder", (PyCFunction)ApplicationData_GetPublisherCacheFolder, METH_VARARGS, nullptr },
    { "SetVersionAsync", (PyCFunction)ApplicationData_SetVersionAsync, METH_VARARGS, nullptr },
    { "SignalDataChanged", (PyCFunction)ApplicationData_SignalDataChanged, METH_VARARGS, nullptr },
    { "add_DataChanged", (PyCFunction)ApplicationData_add_DataChanged, METH_O, nullptr },
    { "get_Current", (PyCFunction)ApplicationData_get_Current, METH_NOARGS | METH_STATIC, nullptr },
    { "get_LocalCacheFolder", (PyCFunction)ApplicationData_get_LocalCacheFolder, METH_NOARGS, nullptr },
    { "get_LocalFolder", (PyCFunction)ApplicationData_get_LocalFolder, METH_NOARGS, nullptr },
    { "get_LocalSettings", (PyCFunction)ApplicationData_get_LocalSettings, METH_NOARGS, nullptr },
    { "get_RoamingFolder", (PyCFunction)ApplicationData_get_RoamingFolder, METH_NOARGS, nullptr },
    { "get_RoamingSettings", (PyCFunction)ApplicationData_get_RoamingSettings, METH_NOARGS, nullptr },
    { "get_RoamingStorageQuota", (PyCFunction)ApplicationData_get_RoamingStorageQuota, METH_NOARGS, nullptr },
    { "get_SharedLocalFolder", (PyCFunction)ApplicationData_get_SharedLocalFolder, METH_NOARGS, nullptr },
    { "get_TemporaryFolder", (PyCFunction)ApplicationData_get_TemporaryFolder, METH_NOARGS, nullptr },
    { "get_Version", (PyCFunction)ApplicationData_get_Version, METH_NOARGS, nullptr },
    { "remove_DataChanged", (PyCFunction)ApplicationData_remove_DataChanged, METH_O, nullptr },
    { "_from", (PyCFunction)ApplicationData__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationData_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ApplicationData_dealloc },
    { Py_tp_new, ApplicationData_new },
    { Py_tp_methods, ApplicationData_methods },
    { 0, nullptr },
};

static PyType_Spec ApplicationData_Type_spec =
{
    "ApplicationData",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationData>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationData_Type_slots
};

// ----- ApplicationDataCompositeValue class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type;


PyObject* ApplicationDataCompositeValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::ApplicationDataCompositeValue instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void ApplicationDataCompositeValue_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataCompositeValue__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::ApplicationDataCompositeValue>::convert(instance.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataCompositeValue_Clear(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_First(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_GetView(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> return_value = self->obj.GetView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_HasKey(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            bool return_value = self->obj.HasKey(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Insert(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

            bool return_value = self->obj.Insert(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Lookup(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.Lookup(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_Remove(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            self->obj.Remove(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.MapChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataCompositeValue_get_Size(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ApplicationDataCompositeValue_methods[] = {
    { "Clear", (PyCFunction)ApplicationDataCompositeValue_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)ApplicationDataCompositeValue_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)ApplicationDataCompositeValue_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)ApplicationDataCompositeValue_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)ApplicationDataCompositeValue_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)ApplicationDataCompositeValue_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)ApplicationDataCompositeValue_Remove, METH_VARARGS, nullptr },
    { "add_MapChanged", (PyCFunction)ApplicationDataCompositeValue_add_MapChanged, METH_O, nullptr },
    { "get_Size", (PyCFunction)ApplicationDataCompositeValue_get_Size, METH_NOARGS, nullptr },
    { "remove_MapChanged", (PyCFunction)ApplicationDataCompositeValue_remove_MapChanged, METH_O, nullptr },
    { "_from", (PyCFunction)ApplicationDataCompositeValue__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataCompositeValue_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ApplicationDataCompositeValue_dealloc },
    { Py_tp_new, ApplicationDataCompositeValue_new },
    { Py_tp_methods, ApplicationDataCompositeValue_methods },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataCompositeValue_Type_spec =
{
    "ApplicationDataCompositeValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataCompositeValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataCompositeValue_Type_slots
};

// ----- ApplicationDataContainer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type;


PyObject* ApplicationDataContainer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationDataContainer is not activatable");
    return nullptr;
}

static void ApplicationDataContainer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataContainer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::ApplicationDataContainer>::convert(instance.as<winrt::Windows::Storage::ApplicationDataContainer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainer_CreateContainer(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);

            winrt::Windows::Storage::ApplicationDataContainer return_value = self->obj.CreateContainer(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainer_DeleteContainer(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            self->obj.DeleteContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainer_get_Containers(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Storage::ApplicationDataContainer> return_value = self->obj.Containers();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataContainer_get_Locality(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::ApplicationDataLocality return_value = self->obj.Locality();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataContainer_get_Name(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataContainer_get_Values(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IPropertySet return_value = self->obj.Values();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ApplicationDataContainer_methods[] = {
    { "CreateContainer", (PyCFunction)ApplicationDataContainer_CreateContainer, METH_VARARGS, nullptr },
    { "DeleteContainer", (PyCFunction)ApplicationDataContainer_DeleteContainer, METH_VARARGS, nullptr },
    { "get_Containers", (PyCFunction)ApplicationDataContainer_get_Containers, METH_NOARGS, nullptr },
    { "get_Locality", (PyCFunction)ApplicationDataContainer_get_Locality, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)ApplicationDataContainer_get_Name, METH_NOARGS, nullptr },
    { "get_Values", (PyCFunction)ApplicationDataContainer_get_Values, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ApplicationDataContainer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataContainer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ApplicationDataContainer_dealloc },
    { Py_tp_new, ApplicationDataContainer_new },
    { Py_tp_methods, ApplicationDataContainer_methods },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataContainer_Type_spec =
{
    "ApplicationDataContainer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainer>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataContainer_Type_slots
};

// ----- ApplicationDataContainerSettings class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type;


PyObject* ApplicationDataContainerSettings_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ApplicationDataContainerSettings is not activatable");
    return nullptr;
}

static void ApplicationDataContainerSettings_dealloc(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ApplicationDataContainerSettings__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::ApplicationDataContainerSettings>::convert(instance.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ApplicationDataContainerSettings_Clear(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_First(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_GetView(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> return_value = self->obj.GetView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_HasKey(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            bool return_value = self->obj.HasKey(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Insert(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

            bool return_value = self->obj.Insert(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Lookup(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.Lookup(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_Remove(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            self->obj.Remove(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.MapChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataContainerSettings_get_Size(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ApplicationDataContainerSettings_methods[] = {
    { "Clear", (PyCFunction)ApplicationDataContainerSettings_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)ApplicationDataContainerSettings_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)ApplicationDataContainerSettings_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)ApplicationDataContainerSettings_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)ApplicationDataContainerSettings_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)ApplicationDataContainerSettings_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)ApplicationDataContainerSettings_Remove, METH_VARARGS, nullptr },
    { "add_MapChanged", (PyCFunction)ApplicationDataContainerSettings_add_MapChanged, METH_O, nullptr },
    { "get_Size", (PyCFunction)ApplicationDataContainerSettings_get_Size, METH_NOARGS, nullptr },
    { "remove_MapChanged", (PyCFunction)ApplicationDataContainerSettings_remove_MapChanged, METH_O, nullptr },
    { "_from", (PyCFunction)ApplicationDataContainerSettings__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ApplicationDataContainerSettings_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ApplicationDataContainerSettings_dealloc },
    { Py_tp_new, ApplicationDataContainerSettings_new },
    { Py_tp_methods, ApplicationDataContainerSettings_methods },
    { 0, nullptr },
};

static PyType_Spec ApplicationDataContainerSettings_Type_spec =
{
    "ApplicationDataContainerSettings",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::ApplicationDataContainerSettings>),
    0,
    Py_TPFLAGS_DEFAULT,
    ApplicationDataContainerSettings_Type_slots
};

// ----- CachedFileManager class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type;


PyObject* CachedFileManager_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "CachedFileManager is not activatable");
    return nullptr;
}

static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Provider::FileUpdateStatus> return_value = winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef CachedFileManager_methods[] = {
    { "CompleteUpdatesAsync", (PyCFunction)CachedFileManager_CompleteUpdatesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "DeferUpdates", (PyCFunction)CachedFileManager_DeferUpdates, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot CachedFileManager_Type_slots[] = 
{
    { Py_tp_new, CachedFileManager_new },
    { Py_tp_methods, CachedFileManager_methods },
    { 0, nullptr },
};

static PyType_Spec CachedFileManager_Type_spec =
{
    "CachedFileManager",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    CachedFileManager_Type_slots
};

// ----- DownloadsFolder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type;


PyObject* DownloadsFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DownloadsFolder is not activatable");
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef DownloadsFolder_methods[] = {
    { "CreateFileAsync", (PyCFunction)DownloadsFolder_CreateFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFileForUserAsync", (PyCFunction)DownloadsFolder_CreateFileForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFolderAsync", (PyCFunction)DownloadsFolder_CreateFolderAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFolderForUserAsync", (PyCFunction)DownloadsFolder_CreateFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot DownloadsFolder_Type_slots[] = 
{
    { Py_tp_new, DownloadsFolder_new },
    { Py_tp_methods, DownloadsFolder_methods },
    { 0, nullptr },
};

static PyType_Spec DownloadsFolder_Type_spec =
{
    "DownloadsFolder",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    DownloadsFolder_Type_slots
};

// ----- FileIO class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::FileIO>::python_type;


PyObject* FileIO_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileIO is not activatable");
    return nullptr;
}

static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IBuffer> return_value = winrt::Windows::Storage::FileIO::ReadBufferAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>> return_value = winrt::Windows::Storage::FileIO::ReadLinesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>> return_value = winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::hstring> return_value = winrt::Windows::Storage::FileIO::ReadTextAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::hstring> return_value = winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            /*p*/ winrt::array_view<uint8_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef FileIO_methods[] = {
    { "AppendLinesAsync", (PyCFunction)FileIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "AppendTextAsync", (PyCFunction)FileIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadBufferAsync", (PyCFunction)FileIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadLinesAsync", (PyCFunction)FileIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadTextAsync", (PyCFunction)FileIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBufferAsync", (PyCFunction)FileIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBytesAsync", (PyCFunction)FileIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteLinesAsync", (PyCFunction)FileIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteTextAsync", (PyCFunction)FileIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot FileIO_Type_slots[] = 
{
    { Py_tp_new, FileIO_new },
    { Py_tp_methods, FileIO_methods },
    { 0, nullptr },
};

static PyType_Spec FileIO_Type_spec =
{
    "FileIO",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    FileIO_Type_slots
};

// ----- KnownFolders class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type;


PyObject* KnownFolders_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "KnownFolders is not activatable");
    return nullptr;
}

static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::AppCaptures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::CameraRoll();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::DocumentsLibrary();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::HomeGroup();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::MediaServerDevices();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::MusicLibrary();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::Objects3D();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::PicturesLibrary();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::Playlists();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::RecordedCalls();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::RemovableDevices();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::SavedPictures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = winrt::Windows::Storage::KnownFolders::VideosLibrary();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef KnownFolders_methods[] = {
    { "GetFolderForUserAsync", (PyCFunction)KnownFolders_GetFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_AppCaptures", (PyCFunction)KnownFolders_get_AppCaptures, METH_NOARGS | METH_STATIC, nullptr },
    { "get_CameraRoll", (PyCFunction)KnownFolders_get_CameraRoll, METH_NOARGS | METH_STATIC, nullptr },
    { "get_DocumentsLibrary", (PyCFunction)KnownFolders_get_DocumentsLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HomeGroup", (PyCFunction)KnownFolders_get_HomeGroup, METH_NOARGS | METH_STATIC, nullptr },
    { "get_MediaServerDevices", (PyCFunction)KnownFolders_get_MediaServerDevices, METH_NOARGS | METH_STATIC, nullptr },
    { "get_MusicLibrary", (PyCFunction)KnownFolders_get_MusicLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Objects3D", (PyCFunction)KnownFolders_get_Objects3D, METH_NOARGS | METH_STATIC, nullptr },
    { "get_PicturesLibrary", (PyCFunction)KnownFolders_get_PicturesLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Playlists", (PyCFunction)KnownFolders_get_Playlists, METH_NOARGS | METH_STATIC, nullptr },
    { "get_RecordedCalls", (PyCFunction)KnownFolders_get_RecordedCalls, METH_NOARGS | METH_STATIC, nullptr },
    { "get_RemovableDevices", (PyCFunction)KnownFolders_get_RemovableDevices, METH_NOARGS | METH_STATIC, nullptr },
    { "get_SavedPictures", (PyCFunction)KnownFolders_get_SavedPictures, METH_NOARGS | METH_STATIC, nullptr },
    { "get_VideosLibrary", (PyCFunction)KnownFolders_get_VideosLibrary, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot KnownFolders_Type_slots[] = 
{
    { Py_tp_new, KnownFolders_new },
    { Py_tp_methods, KnownFolders_methods },
    { 0, nullptr },
};

static PyType_Spec KnownFolders_Type_spec =
{
    "KnownFolders",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    KnownFolders_Type_slots
};

// ----- PathIO class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::PathIO>::python_type;


PyObject* PathIO_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PathIO is not activatable");
    return nullptr;
}

static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IBuffer> return_value = winrt::Windows::Storage::PathIO::ReadBufferAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>> return_value = winrt::Windows::Storage::PathIO::ReadLinesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>> return_value = winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::hstring> return_value = winrt::Windows::Storage::PathIO::ReadTextAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::hstring> return_value = winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            /*p*/ winrt::array_view<uint8_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef PathIO_methods[] = {
    { "AppendLinesAsync", (PyCFunction)PathIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "AppendTextAsync", (PyCFunction)PathIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadBufferAsync", (PyCFunction)PathIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadLinesAsync", (PyCFunction)PathIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadTextAsync", (PyCFunction)PathIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBufferAsync", (PyCFunction)PathIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteBytesAsync", (PyCFunction)PathIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteLinesAsync", (PyCFunction)PathIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "WriteTextAsync", (PyCFunction)PathIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot PathIO_Type_slots[] = 
{
    { Py_tp_new, PathIO_new },
    { Py_tp_methods, PathIO_methods },
    { 0, nullptr },
};

static PyType_Spec PathIO_Type_spec =
{
    "PathIO",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    PathIO_Type_slots
};

// ----- SetVersionDeferral class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type;


PyObject* SetVersionDeferral_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SetVersionDeferral is not activatable");
    return nullptr;
}

static void SetVersionDeferral_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SetVersionDeferral__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SetVersionDeferral>::convert(instance.as<winrt::Windows::Storage::SetVersionDeferral>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SetVersionDeferral_Complete(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Complete();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef SetVersionDeferral_methods[] = {
    { "Complete", (PyCFunction)SetVersionDeferral_Complete, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)SetVersionDeferral__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SetVersionDeferral_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SetVersionDeferral_dealloc },
    { Py_tp_new, SetVersionDeferral_new },
    { Py_tp_methods, SetVersionDeferral_methods },
    { 0, nullptr },
};

static PyType_Spec SetVersionDeferral_Type_spec =
{
    "SetVersionDeferral",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SetVersionDeferral>),
    0,
    Py_TPFLAGS_DEFAULT,
    SetVersionDeferral_Type_slots
};

// ----- SetVersionRequest class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type;


PyObject* SetVersionRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SetVersionRequest is not activatable");
    return nullptr;
}

static void SetVersionRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SetVersionRequest__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SetVersionRequest>::convert(instance.as<winrt::Windows::Storage::SetVersionRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SetVersionRequest_GetDeferral(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::SetVersionDeferral return_value = self->obj.GetDeferral();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SetVersionRequest_get_CurrentVersion(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.CurrentVersion();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SetVersionRequest_get_DesiredVersion(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.DesiredVersion();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SetVersionRequest_methods[] = {
    { "GetDeferral", (PyCFunction)SetVersionRequest_GetDeferral, METH_VARARGS, nullptr },
    { "get_CurrentVersion", (PyCFunction)SetVersionRequest_get_CurrentVersion, METH_NOARGS, nullptr },
    { "get_DesiredVersion", (PyCFunction)SetVersionRequest_get_DesiredVersion, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SetVersionRequest__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SetVersionRequest_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SetVersionRequest_dealloc },
    { Py_tp_new, SetVersionRequest_new },
    { Py_tp_methods, SetVersionRequest_methods },
    { 0, nullptr },
};

static PyType_Spec SetVersionRequest_Type_spec =
{
    "SetVersionRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SetVersionRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    SetVersionRequest_Type_slots
};

// ----- StorageFile class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type;


PyObject* StorageFile_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFile is not activatable");
    return nullptr;
}

static void StorageFile_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFile__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageFile>::convert(instance.as<winrt::Windows::Storage::StorageFile>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFile_CopyAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.CopyAndReplaceAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_CopyAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.GetParentAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

            bool return_value = self->obj.IsEqual(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_MoveAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAndReplaceAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_MoveAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = self->obj.OpenAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = self->obj.OpenAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType> return_value = self->obj.OpenReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream> return_value = self->obj.OpenSequentialReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = self->obj.OpenTransactedWriteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = self->obj.OpenTransactedWriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFile_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_FileType(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FileType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FolderRelativeId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_IsAvailable(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsAvailable();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_Name(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileProperties::StorageItemContentProperties return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFile_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageProvider return_value = self->obj.Provider();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageFile_methods[] = {
    { "CopyAndReplaceAsync", (PyCFunction)StorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
    { "CopyAsync", (PyCFunction)StorageFile_CopyAsync, METH_VARARGS, nullptr },
    { "CreateStreamedFileAsync", (PyCFunction)StorageFile_CreateStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateStreamedFileFromUriAsync", (PyCFunction)StorageFile_CreateStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "DeleteAsync", (PyCFunction)StorageFile_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)StorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileFromApplicationUriAsync", (PyCFunction)StorageFile_GetFileFromApplicationUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFileFromPathAsync", (PyCFunction)StorageFile_GetFileFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetParentAsync", (PyCFunction)StorageFile_GetParentAsync, METH_VARARGS, nullptr },
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)StorageFile_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)StorageFile_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)StorageFile_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageFile_IsOfType, METH_VARARGS, nullptr },
    { "MoveAndReplaceAsync", (PyCFunction)StorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
    { "MoveAsync", (PyCFunction)StorageFile_MoveAsync, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)StorageFile_OpenAsync, METH_VARARGS, nullptr },
    { "OpenReadAsync", (PyCFunction)StorageFile_OpenReadAsync, METH_VARARGS, nullptr },
    { "OpenSequentialReadAsync", (PyCFunction)StorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)StorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)StorageFile_RenameAsync, METH_VARARGS, nullptr },
    { "ReplaceWithStreamedFileAsync", (PyCFunction)StorageFile_ReplaceWithStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReplaceWithStreamedFileFromUriAsync", (PyCFunction)StorageFile_ReplaceWithStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Attributes", (PyCFunction)StorageFile_get_Attributes, METH_NOARGS, nullptr },
    { "get_ContentType", (PyCFunction)StorageFile_get_ContentType, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)StorageFile_get_DateCreated, METH_NOARGS, nullptr },
    { "get_DisplayName", (PyCFunction)StorageFile_get_DisplayName, METH_NOARGS, nullptr },
    { "get_DisplayType", (PyCFunction)StorageFile_get_DisplayType, METH_NOARGS, nullptr },
    { "get_FileType", (PyCFunction)StorageFile_get_FileType, METH_NOARGS, nullptr },
    { "get_FolderRelativeId", (PyCFunction)StorageFile_get_FolderRelativeId, METH_NOARGS, nullptr },
    { "get_IsAvailable", (PyCFunction)StorageFile_get_IsAvailable, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)StorageFile_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)StorageFile_get_Path, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)StorageFile_get_Properties, METH_NOARGS, nullptr },
    { "get_Provider", (PyCFunction)StorageFile_get_Provider, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageFile__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageFile_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageFile_dealloc },
    { Py_tp_new, StorageFile_new },
    { Py_tp_methods, StorageFile_methods },
    { 0, nullptr },
};

static PyType_Spec StorageFile_Type_spec =
{
    "StorageFile",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageFile>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFile_Type_slots
};

// ----- StorageFolder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type;


PyObject* StorageFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFolder is not activatable");
    return nullptr;
}

static void StorageFolder_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFolder__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageFolder>::convert(instance.as<winrt::Windows::Storage::StorageFolder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolder_AreQueryOptionsSupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            bool return_value = self->obj.AreQueryOptionsSupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CreateFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CreateFileAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFileQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQuery(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFileQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.CreateFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.CreateFolderAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQuery(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateItemQuery(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageItemQueryResult return_value = self->obj.CreateItemQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_CreateItemQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageItemQueryResult return_value = self->obj.CreateItemQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.GetFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.GetFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetIndexedStateAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Search::IndexedState> return_value = self->obj.GetIndexedStateAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem> return_value = self->obj.GetItemAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.GetParentAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_IsCommonFileQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            bool return_value = self->obj.IsCommonFileQuerySupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            bool return_value = self->obj.IsCommonFolderQuerySupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

            bool return_value = self->obj.IsEqual(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_TryGetChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::StorageLibraryChangeTracker return_value = self->obj.TryGetChangeTracker();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_TryGetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem> return_value = self->obj.TryGetItemAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolder_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FolderRelativeId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_Name(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileProperties::StorageItemContentProperties return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolder_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageProvider return_value = self->obj.Provider();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageFolder_methods[] = {
    { "AreQueryOptionsSupported", (PyCFunction)StorageFolder_AreQueryOptionsSupported, METH_VARARGS, nullptr },
    { "CreateFileAsync", (PyCFunction)StorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
    { "CreateFileQuery", (PyCFunction)StorageFolder_CreateFileQuery, METH_VARARGS, nullptr },
    { "CreateFileQueryWithOptions", (PyCFunction)StorageFolder_CreateFileQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateFolderAsync", (PyCFunction)StorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
    { "CreateFolderQuery", (PyCFunction)StorageFolder_CreateFolderQuery, METH_VARARGS, nullptr },
    { "CreateFolderQueryWithOptions", (PyCFunction)StorageFolder_CreateFolderQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateItemQuery", (PyCFunction)StorageFolder_CreateItemQuery, METH_VARARGS, nullptr },
    { "CreateItemQueryWithOptions", (PyCFunction)StorageFolder_CreateItemQueryWithOptions, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)StorageFolder_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)StorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileAsync", (PyCFunction)StorageFolder_GetFileAsync, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)StorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFolderAsync", (PyCFunction)StorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
    { "GetFolderFromPathAsync", (PyCFunction)StorageFolder_GetFolderFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFoldersAsync", (PyCFunction)StorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetIndexedStateAsync", (PyCFunction)StorageFolder_GetIndexedStateAsync, METH_VARARGS, nullptr },
    { "GetItemAsync", (PyCFunction)StorageFolder_GetItemAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)StorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
    { "GetParentAsync", (PyCFunction)StorageFolder_GetParentAsync, METH_VARARGS, nullptr },
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)StorageFolder_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)StorageFolder_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "IsCommonFileQuerySupported", (PyCFunction)StorageFolder_IsCommonFileQuerySupported, METH_VARARGS, nullptr },
    { "IsCommonFolderQuerySupported", (PyCFunction)StorageFolder_IsCommonFolderQuerySupported, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)StorageFolder_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageFolder_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)StorageFolder_RenameAsync, METH_VARARGS, nullptr },
    { "TryGetChangeTracker", (PyCFunction)StorageFolder_TryGetChangeTracker, METH_VARARGS, nullptr },
    { "TryGetItemAsync", (PyCFunction)StorageFolder_TryGetItemAsync, METH_VARARGS, nullptr },
    { "get_Attributes", (PyCFunction)StorageFolder_get_Attributes, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)StorageFolder_get_DateCreated, METH_NOARGS, nullptr },
    { "get_DisplayName", (PyCFunction)StorageFolder_get_DisplayName, METH_NOARGS, nullptr },
    { "get_DisplayType", (PyCFunction)StorageFolder_get_DisplayType, METH_NOARGS, nullptr },
    { "get_FolderRelativeId", (PyCFunction)StorageFolder_get_FolderRelativeId, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)StorageFolder_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)StorageFolder_get_Path, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)StorageFolder_get_Properties, METH_NOARGS, nullptr },
    { "get_Provider", (PyCFunction)StorageFolder_get_Provider, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageFolder__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageFolder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageFolder_dealloc },
    { Py_tp_new, StorageFolder_new },
    { Py_tp_methods, StorageFolder_methods },
    { 0, nullptr },
};

static PyType_Spec StorageFolder_Type_spec =
{
    "StorageFolder",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageFolder>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFolder_Type_slots
};

// ----- StorageLibrary class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type;


PyObject* StorageLibrary_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibrary is not activatable");
    return nullptr;
}

static void StorageLibrary_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibrary__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageLibrary>::convert(instance.as<winrt::Windows::Storage::StorageLibrary>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.AreFolderSuggestionsAvailableAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageLibrary> return_value = winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageLibrary> return_value = winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibrary_RequestAddFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.RequestAddFolderAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.RequestRemoveFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibrary_add_DefinitionChanged(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.DefinitionChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibrary_get_ChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageLibraryChangeTracker return_value = self->obj.ChangeTracker();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibrary_get_Folders(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::Storage::StorageFolder> return_value = self->obj.Folders();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibrary_get_SaveFolder(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.SaveFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibrary_remove_DefinitionChanged(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.DefinitionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageLibrary_methods[] = {
    { "AreFolderSuggestionsAvailableAsync", (PyCFunction)StorageLibrary_AreFolderSuggestionsAvailableAsync, METH_VARARGS, nullptr },
    { "GetLibraryAsync", (PyCFunction)StorageLibrary_GetLibraryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetLibraryForUserAsync", (PyCFunction)StorageLibrary_GetLibraryForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "RequestAddFolderAsync", (PyCFunction)StorageLibrary_RequestAddFolderAsync, METH_VARARGS, nullptr },
    { "RequestRemoveFolderAsync", (PyCFunction)StorageLibrary_RequestRemoveFolderAsync, METH_VARARGS, nullptr },
    { "add_DefinitionChanged", (PyCFunction)StorageLibrary_add_DefinitionChanged, METH_O, nullptr },
    { "get_ChangeTracker", (PyCFunction)StorageLibrary_get_ChangeTracker, METH_NOARGS, nullptr },
    { "get_Folders", (PyCFunction)StorageLibrary_get_Folders, METH_NOARGS, nullptr },
    { "get_SaveFolder", (PyCFunction)StorageLibrary_get_SaveFolder, METH_NOARGS, nullptr },
    { "remove_DefinitionChanged", (PyCFunction)StorageLibrary_remove_DefinitionChanged, METH_O, nullptr },
    { "_from", (PyCFunction)StorageLibrary__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibrary_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibrary_dealloc },
    { Py_tp_new, StorageLibrary_new },
    { Py_tp_methods, StorageLibrary_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibrary_Type_spec =
{
    "StorageLibrary",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibrary>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibrary_Type_slots
};

// ----- StorageLibraryChange class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type;


PyObject* StorageLibraryChange_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChange is not activatable");
    return nullptr;
}

static void StorageLibraryChange_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChange__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageLibraryChange>::convert(instance.as<winrt::Windows::Storage::StorageLibraryChange>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChange_GetStorageItemAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem> return_value = self->obj.GetStorageItemAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryChange_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryChange_get_ChangeType(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageLibraryChangeType return_value = self->obj.ChangeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibraryChange_get_Path(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibraryChange_get_PreviousPath(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PreviousPath();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageLibraryChange_methods[] = {
    { "GetStorageItemAsync", (PyCFunction)StorageLibraryChange_GetStorageItemAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)StorageLibraryChange_IsOfType, METH_VARARGS, nullptr },
    { "get_ChangeType", (PyCFunction)StorageLibraryChange_get_ChangeType, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)StorageLibraryChange_get_Path, METH_NOARGS, nullptr },
    { "get_PreviousPath", (PyCFunction)StorageLibraryChange_get_PreviousPath, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageLibraryChange__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChange_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibraryChange_dealloc },
    { Py_tp_new, StorageLibraryChange_new },
    { Py_tp_methods, StorageLibraryChange_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChange_Type_spec =
{
    "StorageLibraryChange",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChange>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChange_Type_slots
};

// ----- StorageLibraryChangeReader class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type;


PyObject* StorageLibraryChangeReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeReader is not activatable");
    return nullptr;
}

static void StorageLibraryChangeReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeReader__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageLibraryChangeReader>::convert(instance.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.AcceptChangesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>> return_value = self->obj.ReadBatchAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef StorageLibraryChangeReader_methods[] = {
    { "AcceptChangesAsync", (PyCFunction)StorageLibraryChangeReader_AcceptChangesAsync, METH_VARARGS, nullptr },
    { "ReadBatchAsync", (PyCFunction)StorageLibraryChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)StorageLibraryChangeReader__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChangeReader_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibraryChangeReader_dealloc },
    { Py_tp_new, StorageLibraryChangeReader_new },
    { Py_tp_methods, StorageLibraryChangeReader_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeReader_Type_spec =
{
    "StorageLibraryChangeReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeReader_Type_slots
};

// ----- StorageLibraryChangeTracker class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type;


PyObject* StorageLibraryChangeTracker_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeTracker is not activatable");
    return nullptr;
}

static void StorageLibraryChangeTracker_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeTracker__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageLibraryChangeTracker>::convert(instance.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChangeTracker_Enable(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Enable();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::StorageLibraryChangeReader return_value = self->obj.GetChangeReader();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryChangeTracker_Reset(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Reset();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef StorageLibraryChangeTracker_methods[] = {
    { "Enable", (PyCFunction)StorageLibraryChangeTracker_Enable, METH_VARARGS, nullptr },
    { "GetChangeReader", (PyCFunction)StorageLibraryChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
    { "Reset", (PyCFunction)StorageLibraryChangeTracker_Reset, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)StorageLibraryChangeTracker__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChangeTracker_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibraryChangeTracker_dealloc },
    { Py_tp_new, StorageLibraryChangeTracker_new },
    { Py_tp_methods, StorageLibraryChangeTracker_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeTracker_Type_spec =
{
    "StorageLibraryChangeTracker",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageLibraryChangeTracker>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeTracker_Type_slots
};

// ----- StorageProvider class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type;


PyObject* StorageProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageProvider is not activatable");
    return nullptr;
}

static void StorageProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageProvider__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageProvider>::convert(instance.as<winrt::Windows::Storage::StorageProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.IsPropertySupportedForPartialFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageProvider_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageProvider_get_Id(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageProvider_methods[] = {
    { "IsPropertySupportedForPartialFileAsync", (PyCFunction)StorageProvider_IsPropertySupportedForPartialFileAsync, METH_VARARGS, nullptr },
    { "get_DisplayName", (PyCFunction)StorageProvider_get_DisplayName, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)StorageProvider_get_Id, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageProvider__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageProvider_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageProvider_dealloc },
    { Py_tp_new, StorageProvider_new },
    { Py_tp_methods, StorageProvider_methods },
    { 0, nullptr },
};

static PyType_Spec StorageProvider_Type_spec =
{
    "StorageProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageProvider_Type_slots
};

// ----- StorageStreamTransaction class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type;


PyObject* StorageStreamTransaction_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageStreamTransaction is not activatable");
    return nullptr;
}

static void StorageStreamTransaction_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageStreamTransaction__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StorageStreamTransaction>::convert(instance.as<winrt::Windows::Storage::StorageStreamTransaction>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageStreamTransaction_Close(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageStreamTransaction_CommitAsync(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.CommitAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageStreamTransaction_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.Stream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageStreamTransaction_methods[] = {
    { "Close", (PyCFunction)StorageStreamTransaction_Close, METH_VARARGS, nullptr },
    { "CommitAsync", (PyCFunction)StorageStreamTransaction_CommitAsync, METH_VARARGS, nullptr },
    { "get_Stream", (PyCFunction)StorageStreamTransaction_get_Stream, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageStreamTransaction__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageStreamTransaction_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageStreamTransaction_dealloc },
    { Py_tp_new, StorageStreamTransaction_new },
    { Py_tp_methods, StorageStreamTransaction_methods },
    { 0, nullptr },
};

static PyType_Spec StorageStreamTransaction_Type_spec =
{
    "StorageStreamTransaction",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StorageStreamTransaction>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageStreamTransaction_Type_slots
};

// ----- StreamedFileDataRequest class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type;


PyObject* StreamedFileDataRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StreamedFileDataRequest is not activatable");
    return nullptr;
}

static void StreamedFileDataRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StreamedFileDataRequest__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::StreamedFileDataRequest>::convert(instance.as<winrt::Windows::Storage::StreamedFileDataRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StreamedFileDataRequest_Close(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StreamedFileDataRequest_FailAndClose(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

            self->obj.FailAndClose(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StreamedFileDataRequest_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StreamedFileDataRequest_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef StreamedFileDataRequest_methods[] = {
    { "Close", (PyCFunction)StreamedFileDataRequest_Close, METH_VARARGS, nullptr },
    { "FailAndClose", (PyCFunction)StreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)StreamedFileDataRequest_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)StreamedFileDataRequest_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)StreamedFileDataRequest__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StreamedFileDataRequest_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StreamedFileDataRequest_dealloc },
    { Py_tp_new, StreamedFileDataRequest_new },
    { Py_tp_methods, StreamedFileDataRequest_methods },
    { 0, nullptr },
};

static PyType_Spec StreamedFileDataRequest_Type_spec =
{
    "StreamedFileDataRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::StreamedFileDataRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    StreamedFileDataRequest_Type_slots
};

// ----- SystemAudioProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type;


PyObject* SystemAudioProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemAudioProperties is not activatable");
    return nullptr;
}

static void SystemAudioProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemAudioProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemAudioProperties>::convert(instance.as<winrt::Windows::Storage::SystemAudioProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemAudioProperties_get_EncodingBitrate(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.EncodingBitrate();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemAudioProperties_methods[] = {
    { "get_EncodingBitrate", (PyCFunction)SystemAudioProperties_get_EncodingBitrate, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemAudioProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemAudioProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemAudioProperties_dealloc },
    { Py_tp_new, SystemAudioProperties_new },
    { Py_tp_methods, SystemAudioProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemAudioProperties_Type_spec =
{
    "SystemAudioProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemAudioProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemAudioProperties_Type_slots
};

// ----- SystemDataPaths class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type;


PyObject* SystemDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemDataPaths is not activatable");
    return nullptr;
}

static void SystemDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemDataPaths__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemDataPaths>::convert(instance.as<winrt::Windows::Storage::SystemDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::SystemDataPaths return_value = winrt::Windows::Storage::SystemDataPaths::GetDefault();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SystemDataPaths_get_Fonts(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Fonts();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_ProgramData(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ProgramData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_Public(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Public();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicDesktop(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicDesktop();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicDocuments(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicDocuments();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicDownloads(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicDownloads();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicMusic(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicMusic();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicPictures(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicPictures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_PublicVideos(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PublicVideos();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_System(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.System();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_SystemArm(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SystemArm();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_SystemHost(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SystemHost();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_SystemX64(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SystemX64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_SystemX86(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SystemX86();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_UserProfiles(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.UserProfiles();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemDataPaths_get_Windows(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Windows();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)SystemDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Fonts", (PyCFunction)SystemDataPaths_get_Fonts, METH_NOARGS, nullptr },
    { "get_ProgramData", (PyCFunction)SystemDataPaths_get_ProgramData, METH_NOARGS, nullptr },
    { "get_Public", (PyCFunction)SystemDataPaths_get_Public, METH_NOARGS, nullptr },
    { "get_PublicDesktop", (PyCFunction)SystemDataPaths_get_PublicDesktop, METH_NOARGS, nullptr },
    { "get_PublicDocuments", (PyCFunction)SystemDataPaths_get_PublicDocuments, METH_NOARGS, nullptr },
    { "get_PublicDownloads", (PyCFunction)SystemDataPaths_get_PublicDownloads, METH_NOARGS, nullptr },
    { "get_PublicMusic", (PyCFunction)SystemDataPaths_get_PublicMusic, METH_NOARGS, nullptr },
    { "get_PublicPictures", (PyCFunction)SystemDataPaths_get_PublicPictures, METH_NOARGS, nullptr },
    { "get_PublicVideos", (PyCFunction)SystemDataPaths_get_PublicVideos, METH_NOARGS, nullptr },
    { "get_System", (PyCFunction)SystemDataPaths_get_System, METH_NOARGS, nullptr },
    { "get_SystemArm", (PyCFunction)SystemDataPaths_get_SystemArm, METH_NOARGS, nullptr },
    { "get_SystemHost", (PyCFunction)SystemDataPaths_get_SystemHost, METH_NOARGS, nullptr },
    { "get_SystemX64", (PyCFunction)SystemDataPaths_get_SystemX64, METH_NOARGS, nullptr },
    { "get_SystemX86", (PyCFunction)SystemDataPaths_get_SystemX86, METH_NOARGS, nullptr },
    { "get_UserProfiles", (PyCFunction)SystemDataPaths_get_UserProfiles, METH_NOARGS, nullptr },
    { "get_Windows", (PyCFunction)SystemDataPaths_get_Windows, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemDataPaths__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemDataPaths_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemDataPaths_dealloc },
    { Py_tp_new, SystemDataPaths_new },
    { Py_tp_methods, SystemDataPaths_methods },
    { 0, nullptr },
};

static PyType_Spec SystemDataPaths_Type_spec =
{
    "SystemDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemDataPaths_Type_slots
};

// ----- SystemGPSProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type;


PyObject* SystemGPSProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemGPSProperties is not activatable");
    return nullptr;
}

static void SystemGPSProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemGPSProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemGPSProperties>::convert(instance.as<winrt::Windows::Storage::SystemGPSProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.LatitudeDecimal();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.LongitudeDecimal();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemGPSProperties_methods[] = {
    { "get_LatitudeDecimal", (PyCFunction)SystemGPSProperties_get_LatitudeDecimal, METH_NOARGS, nullptr },
    { "get_LongitudeDecimal", (PyCFunction)SystemGPSProperties_get_LongitudeDecimal, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemGPSProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemGPSProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemGPSProperties_dealloc },
    { Py_tp_new, SystemGPSProperties_new },
    { Py_tp_methods, SystemGPSProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemGPSProperties_Type_spec =
{
    "SystemGPSProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemGPSProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemGPSProperties_Type_slots
};

// ----- SystemImageProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type;


PyObject* SystemImageProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemImageProperties is not activatable");
    return nullptr;
}

static void SystemImageProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemImageProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemImageProperties>::convert(instance.as<winrt::Windows::Storage::SystemImageProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemImageProperties_get_HorizontalSize(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.HorizontalSize();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemImageProperties_get_VerticalSize(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.VerticalSize();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemImageProperties_methods[] = {
    { "get_HorizontalSize", (PyCFunction)SystemImageProperties_get_HorizontalSize, METH_NOARGS, nullptr },
    { "get_VerticalSize", (PyCFunction)SystemImageProperties_get_VerticalSize, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemImageProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemImageProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemImageProperties_dealloc },
    { Py_tp_new, SystemImageProperties_new },
    { Py_tp_methods, SystemImageProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemImageProperties_Type_spec =
{
    "SystemImageProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemImageProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemImageProperties_Type_slots
};

// ----- SystemMediaProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type;


PyObject* SystemMediaProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMediaProperties is not activatable");
    return nullptr;
}

static void SystemMediaProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMediaProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemMediaProperties>::convert(instance.as<winrt::Windows::Storage::SystemMediaProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMediaProperties_get_Duration(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Duration();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMediaProperties_get_Producer(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Producer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMediaProperties_get_Publisher(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Publisher();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMediaProperties_get_SubTitle(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SubTitle();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMediaProperties_get_Writer(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Writer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMediaProperties_get_Year(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Year();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemMediaProperties_methods[] = {
    { "get_Duration", (PyCFunction)SystemMediaProperties_get_Duration, METH_NOARGS, nullptr },
    { "get_Producer", (PyCFunction)SystemMediaProperties_get_Producer, METH_NOARGS, nullptr },
    { "get_Publisher", (PyCFunction)SystemMediaProperties_get_Publisher, METH_NOARGS, nullptr },
    { "get_SubTitle", (PyCFunction)SystemMediaProperties_get_SubTitle, METH_NOARGS, nullptr },
    { "get_Writer", (PyCFunction)SystemMediaProperties_get_Writer, METH_NOARGS, nullptr },
    { "get_Year", (PyCFunction)SystemMediaProperties_get_Year, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemMediaProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemMediaProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemMediaProperties_dealloc },
    { Py_tp_new, SystemMediaProperties_new },
    { Py_tp_methods, SystemMediaProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemMediaProperties_Type_spec =
{
    "SystemMediaProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemMediaProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMediaProperties_Type_slots
};

// ----- SystemMusicProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type;


PyObject* SystemMusicProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemMusicProperties is not activatable");
    return nullptr;
}

static void SystemMusicProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemMusicProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemMusicProperties>::convert(instance.as<winrt::Windows::Storage::SystemMusicProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemMusicProperties_get_AlbumArtist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.AlbumArtist();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_AlbumTitle(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.AlbumTitle();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_Artist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Artist();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_Composer(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Composer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_Conductor(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Conductor();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_DisplayArtist(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayArtist();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_Genre(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Genre();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemMusicProperties_get_TrackNumber(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.TrackNumber();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemMusicProperties_methods[] = {
    { "get_AlbumArtist", (PyCFunction)SystemMusicProperties_get_AlbumArtist, METH_NOARGS, nullptr },
    { "get_AlbumTitle", (PyCFunction)SystemMusicProperties_get_AlbumTitle, METH_NOARGS, nullptr },
    { "get_Artist", (PyCFunction)SystemMusicProperties_get_Artist, METH_NOARGS, nullptr },
    { "get_Composer", (PyCFunction)SystemMusicProperties_get_Composer, METH_NOARGS, nullptr },
    { "get_Conductor", (PyCFunction)SystemMusicProperties_get_Conductor, METH_NOARGS, nullptr },
    { "get_DisplayArtist", (PyCFunction)SystemMusicProperties_get_DisplayArtist, METH_NOARGS, nullptr },
    { "get_Genre", (PyCFunction)SystemMusicProperties_get_Genre, METH_NOARGS, nullptr },
    { "get_TrackNumber", (PyCFunction)SystemMusicProperties_get_TrackNumber, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemMusicProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemMusicProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemMusicProperties_dealloc },
    { Py_tp_new, SystemMusicProperties_new },
    { Py_tp_methods, SystemMusicProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemMusicProperties_Type_spec =
{
    "SystemMusicProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemMusicProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemMusicProperties_Type_slots
};

// ----- SystemPhotoProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type;


PyObject* SystemPhotoProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemPhotoProperties is not activatable");
    return nullptr;
}

static void SystemPhotoProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemPhotoProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemPhotoProperties>::convert(instance.as<winrt::Windows::Storage::SystemPhotoProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.CameraManufacturer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemPhotoProperties_get_CameraModel(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.CameraModel();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemPhotoProperties_get_DateTaken(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DateTaken();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemPhotoProperties_get_Orientation(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Orientation();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemPhotoProperties_get_PeopleNames(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PeopleNames();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemPhotoProperties_methods[] = {
    { "get_CameraManufacturer", (PyCFunction)SystemPhotoProperties_get_CameraManufacturer, METH_NOARGS, nullptr },
    { "get_CameraModel", (PyCFunction)SystemPhotoProperties_get_CameraModel, METH_NOARGS, nullptr },
    { "get_DateTaken", (PyCFunction)SystemPhotoProperties_get_DateTaken, METH_NOARGS, nullptr },
    { "get_Orientation", (PyCFunction)SystemPhotoProperties_get_Orientation, METH_NOARGS, nullptr },
    { "get_PeopleNames", (PyCFunction)SystemPhotoProperties_get_PeopleNames, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemPhotoProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemPhotoProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemPhotoProperties_dealloc },
    { Py_tp_new, SystemPhotoProperties_new },
    { Py_tp_methods, SystemPhotoProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemPhotoProperties_Type_spec =
{
    "SystemPhotoProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemPhotoProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemPhotoProperties_Type_slots
};

// ----- SystemProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type;


PyObject* SystemProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemProperties is not activatable");
    return nullptr;
}

static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemAudioProperties return_value = winrt::Windows::Storage::SystemProperties::Audio();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::Author();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::Comment();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemGPSProperties return_value = winrt::Windows::Storage::SystemProperties::GPS();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemImageProperties return_value = winrt::Windows::Storage::SystemProperties::Image();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::ItemNameDisplay();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::Keywords();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemMediaProperties return_value = winrt::Windows::Storage::SystemProperties::Media();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemMusicProperties return_value = winrt::Windows::Storage::SystemProperties::Music();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemPhotoProperties return_value = winrt::Windows::Storage::SystemProperties::Photo();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::Rating();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = winrt::Windows::Storage::SystemProperties::Title();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::SystemVideoProperties return_value = winrt::Windows::Storage::SystemProperties::Video();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemProperties_methods[] = {
    { "get_Audio", (PyCFunction)SystemProperties_get_Audio, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Author", (PyCFunction)SystemProperties_get_Author, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Comment", (PyCFunction)SystemProperties_get_Comment, METH_NOARGS | METH_STATIC, nullptr },
    { "get_GPS", (PyCFunction)SystemProperties_get_GPS, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Image", (PyCFunction)SystemProperties_get_Image, METH_NOARGS | METH_STATIC, nullptr },
    { "get_ItemNameDisplay", (PyCFunction)SystemProperties_get_ItemNameDisplay, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Keywords", (PyCFunction)SystemProperties_get_Keywords, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Media", (PyCFunction)SystemProperties_get_Media, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Music", (PyCFunction)SystemProperties_get_Music, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Photo", (PyCFunction)SystemProperties_get_Photo, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Rating", (PyCFunction)SystemProperties_get_Rating, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Title", (PyCFunction)SystemProperties_get_Title, METH_NOARGS | METH_STATIC, nullptr },
    { "get_Video", (PyCFunction)SystemProperties_get_Video, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemProperties_Type_slots[] = 
{
    { Py_tp_new, SystemProperties_new },
    { Py_tp_methods, SystemProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemProperties_Type_spec =
{
    "SystemProperties",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    SystemProperties_Type_slots
};

// ----- SystemVideoProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type;


PyObject* SystemVideoProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SystemVideoProperties is not activatable");
    return nullptr;
}

static void SystemVideoProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SystemVideoProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::SystemVideoProperties>::convert(instance.as<winrt::Windows::Storage::SystemVideoProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SystemVideoProperties_get_Director(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Director();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemVideoProperties_get_FrameHeight(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FrameHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemVideoProperties_get_FrameWidth(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FrameWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemVideoProperties_get_Orientation(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Orientation();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SystemVideoProperties_get_TotalBitrate(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.TotalBitrate();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SystemVideoProperties_methods[] = {
    { "get_Director", (PyCFunction)SystemVideoProperties_get_Director, METH_NOARGS, nullptr },
    { "get_FrameHeight", (PyCFunction)SystemVideoProperties_get_FrameHeight, METH_NOARGS, nullptr },
    { "get_FrameWidth", (PyCFunction)SystemVideoProperties_get_FrameWidth, METH_NOARGS, nullptr },
    { "get_Orientation", (PyCFunction)SystemVideoProperties_get_Orientation, METH_NOARGS, nullptr },
    { "get_TotalBitrate", (PyCFunction)SystemVideoProperties_get_TotalBitrate, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SystemVideoProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SystemVideoProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SystemVideoProperties_dealloc },
    { Py_tp_new, SystemVideoProperties_new },
    { Py_tp_methods, SystemVideoProperties_methods },
    { 0, nullptr },
};

static PyType_Spec SystemVideoProperties_Type_spec =
{
    "SystemVideoProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::SystemVideoProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    SystemVideoProperties_Type_slots
};

// ----- UserDataPaths class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type;


PyObject* UserDataPaths_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "UserDataPaths is not activatable");
    return nullptr;
}

static void UserDataPaths_dealloc(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* UserDataPaths__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::UserDataPaths>::convert(instance.as<winrt::Windows::Storage::UserDataPaths>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::UserDataPaths return_value = winrt::Windows::Storage::UserDataPaths::GetDefault();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

            winrt::Windows::Storage::UserDataPaths return_value = winrt::Windows::Storage::UserDataPaths::GetForUser(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* UserDataPaths_get_CameraRoll(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.CameraRoll();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Cookies(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Cookies();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Desktop(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Desktop();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Documents(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Documents();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Downloads(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Downloads();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Favorites(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Favorites();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_History(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.History();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_InternetCache(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.InternetCache();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_LocalAppData(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.LocalAppData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_LocalAppDataLow(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.LocalAppDataLow();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Music(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Music();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Pictures(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Pictures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Profile(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Profile();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Recent(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Recent();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_RoamingAppData(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.RoamingAppData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_SavedPictures(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SavedPictures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Screenshots(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Screenshots();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Templates(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Templates();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* UserDataPaths_get_Videos(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Videos();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef UserDataPaths_methods[] = {
    { "GetDefault", (PyCFunction)UserDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
    { "GetForUser", (PyCFunction)UserDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
    { "get_CameraRoll", (PyCFunction)UserDataPaths_get_CameraRoll, METH_NOARGS, nullptr },
    { "get_Cookies", (PyCFunction)UserDataPaths_get_Cookies, METH_NOARGS, nullptr },
    { "get_Desktop", (PyCFunction)UserDataPaths_get_Desktop, METH_NOARGS, nullptr },
    { "get_Documents", (PyCFunction)UserDataPaths_get_Documents, METH_NOARGS, nullptr },
    { "get_Downloads", (PyCFunction)UserDataPaths_get_Downloads, METH_NOARGS, nullptr },
    { "get_Favorites", (PyCFunction)UserDataPaths_get_Favorites, METH_NOARGS, nullptr },
    { "get_History", (PyCFunction)UserDataPaths_get_History, METH_NOARGS, nullptr },
    { "get_InternetCache", (PyCFunction)UserDataPaths_get_InternetCache, METH_NOARGS, nullptr },
    { "get_LocalAppData", (PyCFunction)UserDataPaths_get_LocalAppData, METH_NOARGS, nullptr },
    { "get_LocalAppDataLow", (PyCFunction)UserDataPaths_get_LocalAppDataLow, METH_NOARGS, nullptr },
    { "get_Music", (PyCFunction)UserDataPaths_get_Music, METH_NOARGS, nullptr },
    { "get_Pictures", (PyCFunction)UserDataPaths_get_Pictures, METH_NOARGS, nullptr },
    { "get_Profile", (PyCFunction)UserDataPaths_get_Profile, METH_NOARGS, nullptr },
    { "get_Recent", (PyCFunction)UserDataPaths_get_Recent, METH_NOARGS, nullptr },
    { "get_RoamingAppData", (PyCFunction)UserDataPaths_get_RoamingAppData, METH_NOARGS, nullptr },
    { "get_SavedPictures", (PyCFunction)UserDataPaths_get_SavedPictures, METH_NOARGS, nullptr },
    { "get_Screenshots", (PyCFunction)UserDataPaths_get_Screenshots, METH_NOARGS, nullptr },
    { "get_Templates", (PyCFunction)UserDataPaths_get_Templates, METH_NOARGS, nullptr },
    { "get_Videos", (PyCFunction)UserDataPaths_get_Videos, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)UserDataPaths__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot UserDataPaths_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, UserDataPaths_dealloc },
    { Py_tp_new, UserDataPaths_new },
    { Py_tp_methods, UserDataPaths_methods },
    { 0, nullptr },
};

static PyType_Spec UserDataPaths_Type_spec =
{
    "UserDataPaths",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::UserDataPaths>),
    0,
    Py_TPFLAGS_DEFAULT,
    UserDataPaths_Type_slots
};

// ----- IStorageFile interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type;


PyObject* IStorageFile_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFile interface is not activatable");
    return nullptr;
}

static void IStorageFile_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFile__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageFile>::convert(instance.as<winrt::Windows::Storage::IStorageFile>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile_CopyAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.CopyAndReplaceAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_CopyAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CopyAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_MoveAndReplaceAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAndReplaceAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_MoveAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.MoveAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = self->obj.OpenAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType> return_value = self->obj.OpenReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream> return_value = self->obj.OpenSequentialReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = self->obj.OpenTransactedWriteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFile_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFile_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFile_get_FileType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FileType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFile_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFile_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageFile_methods[] = {
    { "CopyAndReplaceAsync", (PyCFunction)IStorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
    { "CopyAsync", (PyCFunction)IStorageFile_CopyAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)IStorageFile_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageFile_IsOfType, METH_VARARGS, nullptr },
    { "MoveAndReplaceAsync", (PyCFunction)IStorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
    { "MoveAsync", (PyCFunction)IStorageFile_MoveAsync, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)IStorageFile_OpenAsync, METH_VARARGS, nullptr },
    { "OpenReadAsync", (PyCFunction)IStorageFile_OpenReadAsync, METH_VARARGS, nullptr },
    { "OpenSequentialReadAsync", (PyCFunction)IStorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)IStorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageFile_RenameAsync, METH_VARARGS, nullptr },
    { "get_Attributes", (PyCFunction)IStorageFile_get_Attributes, METH_NOARGS, nullptr },
    { "get_ContentType", (PyCFunction)IStorageFile_get_ContentType, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)IStorageFile_get_DateCreated, METH_NOARGS, nullptr },
    { "get_FileType", (PyCFunction)IStorageFile_get_FileType, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)IStorageFile_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)IStorageFile_get_Path, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageFile__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFile_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFile_dealloc },
    { Py_tp_new, IStorageFile_new },
    { Py_tp_methods, IStorageFile_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFile_Type_spec =
{
    "IStorageFile",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFile_Type_slots
};

// ----- IStorageFile2 interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type;


PyObject* IStorageFile2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFile2 interface is not activatable");
    return nullptr;
}

static void IStorageFile2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFile2__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageFile2>::convert(instance.as<winrt::Windows::Storage::IStorageFile2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFile2_OpenAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = self->obj.OpenAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFile2_OpenTransactedWriteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = self->obj.OpenTransactedWriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStorageFile2_methods[] = {
    { "OpenAsync", (PyCFunction)IStorageFile2_OpenAsync, METH_VARARGS, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)IStorageFile2_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IStorageFile2__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFile2_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFile2_dealloc },
    { Py_tp_new, IStorageFile2_new },
    { Py_tp_methods, IStorageFile2_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFile2_Type_spec =
{
    "IStorageFile2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFile2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFile2_Type_slots
};

// ----- IStorageFilePropertiesWithAvailability interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type;


PyObject* IStorageFilePropertiesWithAvailability_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFilePropertiesWithAvailability interface is not activatable");
    return nullptr;
}

static void IStorageFilePropertiesWithAvailability_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFilePropertiesWithAvailability__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::convert(instance.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsAvailable();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageFilePropertiesWithAvailability_methods[] = {
    { "get_IsAvailable", (PyCFunction)IStorageFilePropertiesWithAvailability_get_IsAvailable, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageFilePropertiesWithAvailability__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFilePropertiesWithAvailability_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFilePropertiesWithAvailability_dealloc },
    { Py_tp_new, IStorageFilePropertiesWithAvailability_new },
    { Py_tp_methods, IStorageFilePropertiesWithAvailability_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFilePropertiesWithAvailability_Type_spec =
{
    "IStorageFilePropertiesWithAvailability",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFilePropertiesWithAvailability_Type_slots
};

// ----- IStorageFolder interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type;


PyObject* IStorageFolder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolder interface is not activatable");
    return nullptr;
}

static void IStorageFolder_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolder__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageFolder>::convert(instance.as<winrt::Windows::Storage::IStorageFolder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolder_CreateFileAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CreateFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.CreateFileAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_CreateFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.CreateFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.CreateFolderAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetFileAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile> return_value = self->obj.GetFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetFolderAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.GetFolderAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem> return_value = self->obj.GetItemAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolder_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFolder_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFolder_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageFolder_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageFolder_methods[] = {
    { "CreateFileAsync", (PyCFunction)IStorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
    { "CreateFolderAsync", (PyCFunction)IStorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)IStorageFolder_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetFileAsync", (PyCFunction)IStorageFolder_GetFileAsync, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)IStorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFolderAsync", (PyCFunction)IStorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)IStorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetItemAsync", (PyCFunction)IStorageFolder_GetItemAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)IStorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageFolder_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageFolder_RenameAsync, METH_VARARGS, nullptr },
    { "get_Attributes", (PyCFunction)IStorageFolder_get_Attributes, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)IStorageFolder_get_DateCreated, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)IStorageFolder_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)IStorageFolder_get_Path, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageFolder__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFolder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFolder_dealloc },
    { Py_tp_new, IStorageFolder_new },
    { Py_tp_methods, IStorageFolder_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFolder_Type_spec =
{
    "IStorageFolder",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolder_Type_slots
};

// ----- IStorageFolder2 interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type;


PyObject* IStorageFolder2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolder2 interface is not activatable");
    return nullptr;
}

static void IStorageFolder2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolder2__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageFolder2>::convert(instance.as<winrt::Windows::Storage::IStorageFolder2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolder2_TryGetItemAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem> return_value = self->obj.TryGetItemAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStorageFolder2_methods[] = {
    { "TryGetItemAsync", (PyCFunction)IStorageFolder2_TryGetItemAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IStorageFolder2__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFolder2_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFolder2_dealloc },
    { Py_tp_new, IStorageFolder2_new },
    { Py_tp_methods, IStorageFolder2_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFolder2_Type_spec =
{
    "IStorageFolder2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageFolder2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolder2_Type_slots
};

// ----- IStorageItem interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type;


PyObject* IStorageItem_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItem interface is not activatable");
    return nullptr;
}

static void IStorageItem_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItem__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageItem>::convert(instance.as<winrt::Windows::Storage::IStorageItem>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageItem_methods[] = {
    { "DeleteAsync", (PyCFunction)IStorageItem_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageItem_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageItem_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageItem_RenameAsync, METH_VARARGS, nullptr },
    { "get_Attributes", (PyCFunction)IStorageItem_get_Attributes, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)IStorageItem_get_DateCreated, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)IStorageItem_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)IStorageItem_get_Path, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageItem__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItem_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageItem_dealloc },
    { Py_tp_new, IStorageItem_new },
    { Py_tp_methods, IStorageItem_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageItem_Type_spec =
{
    "IStorageItem",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItem_Type_slots
};

// ----- IStorageItem2 interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type;


PyObject* IStorageItem2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItem2 interface is not activatable");
    return nullptr;
}

static void IStorageItem2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItem2__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageItem2>::convert(instance.as<winrt::Windows::Storage::IStorageItem2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItem2_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties> return_value = self->obj.GetBasicPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_GetParentAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder> return_value = self->obj.GetParentAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_IsEqual(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

            bool return_value = self->obj.IsEqual(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_IsOfType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

            bool return_value = self->obj.IsOfType(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_RenameAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.RenameAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItem2_get_Attributes(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileAttributes return_value = self->obj.Attributes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem2_get_DateCreated(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.DateCreated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem2_get_Name(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItem2_get_Path(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageItem2_methods[] = {
    { "DeleteAsync", (PyCFunction)IStorageItem2_DeleteAsync, METH_VARARGS, nullptr },
    { "GetBasicPropertiesAsync", (PyCFunction)IStorageItem2_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
    { "GetParentAsync", (PyCFunction)IStorageItem2_GetParentAsync, METH_VARARGS, nullptr },
    { "IsEqual", (PyCFunction)IStorageItem2_IsEqual, METH_VARARGS, nullptr },
    { "IsOfType", (PyCFunction)IStorageItem2_IsOfType, METH_VARARGS, nullptr },
    { "RenameAsync", (PyCFunction)IStorageItem2_RenameAsync, METH_VARARGS, nullptr },
    { "get_Attributes", (PyCFunction)IStorageItem2_get_Attributes, METH_NOARGS, nullptr },
    { "get_DateCreated", (PyCFunction)IStorageItem2_get_DateCreated, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)IStorageItem2_get_Name, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)IStorageItem2_get_Path, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageItem2__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItem2_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageItem2_dealloc },
    { Py_tp_new, IStorageItem2_new },
    { Py_tp_methods, IStorageItem2_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageItem2_Type_spec =
{
    "IStorageItem2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItem2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItem2_Type_slots
};

// ----- IStorageItemProperties interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type;


PyObject* IStorageItemProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemProperties interface is not activatable");
    return nullptr;
}

static void IStorageItemProperties_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageItemProperties>::convert(instance.as<winrt::Windows::Storage::IStorageItemProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItemProperties_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FolderRelativeId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileProperties::StorageItemContentProperties return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageItemProperties_methods[] = {
    { "GetThumbnailAsync", (PyCFunction)IStorageItemProperties_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_DisplayName", (PyCFunction)IStorageItemProperties_get_DisplayName, METH_NOARGS, nullptr },
    { "get_DisplayType", (PyCFunction)IStorageItemProperties_get_DisplayType, METH_NOARGS, nullptr },
    { "get_FolderRelativeId", (PyCFunction)IStorageItemProperties_get_FolderRelativeId, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)IStorageItemProperties_get_Properties, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageItemProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageItemProperties_dealloc },
    { Py_tp_new, IStorageItemProperties_new },
    { Py_tp_methods, IStorageItemProperties_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageItemProperties_Type_spec =
{
    "IStorageItemProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemProperties_Type_slots
};

// ----- IStorageItemProperties2 interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type;


PyObject* IStorageItemProperties2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemProperties2 interface is not activatable");
    return nullptr;
}

static void IStorageItemProperties2_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemProperties2__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageItemProperties2>::convert(instance.as<winrt::Windows::Storage::IStorageItemProperties2>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItemProperties2_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties2_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FolderRelativeId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemProperties2_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileProperties::StorageItemContentProperties return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageItemProperties2_methods[] = {
    { "GetScaledImageAsThumbnailAsync", (PyCFunction)IStorageItemProperties2_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IStorageItemProperties2_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_DisplayName", (PyCFunction)IStorageItemProperties2_get_DisplayName, METH_NOARGS, nullptr },
    { "get_DisplayType", (PyCFunction)IStorageItemProperties2_get_DisplayType, METH_NOARGS, nullptr },
    { "get_FolderRelativeId", (PyCFunction)IStorageItemProperties2_get_FolderRelativeId, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)IStorageItemProperties2_get_Properties, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageItemProperties2__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemProperties2_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageItemProperties2_dealloc },
    { Py_tp_new, IStorageItemProperties2_new },
    { Py_tp_methods, IStorageItemProperties2_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageItemProperties2_Type_spec =
{
    "IStorageItemProperties2",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemProperties2>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemProperties2_Type_slots
};

// ----- IStorageItemPropertiesWithProvider interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type;


PyObject* IStorageItemPropertiesWithProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageItemPropertiesWithProvider interface is not activatable");
    return nullptr;
}

static void IStorageItemPropertiesWithProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageItemPropertiesWithProvider__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::convert(instance.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail> return_value = self->obj.GetThumbnailAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FolderRelativeId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::FileProperties::StorageItemContentProperties return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageProvider return_value = self->obj.Provider();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageItemPropertiesWithProvider_methods[] = {
    { "GetThumbnailAsync", (PyCFunction)IStorageItemPropertiesWithProvider_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_DisplayName", (PyCFunction)IStorageItemPropertiesWithProvider_get_DisplayName, METH_NOARGS, nullptr },
    { "get_DisplayType", (PyCFunction)IStorageItemPropertiesWithProvider_get_DisplayType, METH_NOARGS, nullptr },
    { "get_FolderRelativeId", (PyCFunction)IStorageItemPropertiesWithProvider_get_FolderRelativeId, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)IStorageItemPropertiesWithProvider_get_Properties, METH_NOARGS, nullptr },
    { "get_Provider", (PyCFunction)IStorageItemPropertiesWithProvider_get_Provider, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IStorageItemPropertiesWithProvider__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageItemPropertiesWithProvider_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageItemPropertiesWithProvider_dealloc },
    { Py_tp_new, IStorageItemPropertiesWithProvider_new },
    { Py_tp_methods, IStorageItemPropertiesWithProvider_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageItemPropertiesWithProvider_Type_spec =
{
    "IStorageItemPropertiesWithProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageItemPropertiesWithProvider_Type_slots
};

// ----- IStreamedFileDataRequest interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type;


PyObject* IStreamedFileDataRequest_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStreamedFileDataRequest interface is not activatable");
    return nullptr;
}

static void IStreamedFileDataRequest_dealloc(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStreamedFileDataRequest__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::IStreamedFileDataRequest>::convert(instance.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStreamedFileDataRequest_FailAndClose(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

            self->obj.FailAndClose(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStreamedFileDataRequest_methods[] = {
    { "FailAndClose", (PyCFunction)IStreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IStreamedFileDataRequest__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStreamedFileDataRequest_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStreamedFileDataRequest_dealloc },
    { Py_tp_new, IStreamedFileDataRequest_new },
    { Py_tp_methods, IStreamedFileDataRequest_methods },
    { 0, nullptr },
};

static PyType_Spec IStreamedFileDataRequest_Type_spec =
{
    "IStreamedFileDataRequest",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::IStreamedFileDataRequest>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStreamedFileDataRequest_Type_slots
};

// ----- Windows.Storage Initialization --------------------

int initialize_Windows_Storage(PyObject* module)
{
    PyObject* type_object{ nullptr };


    AppDataPaths_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&AppDataPaths_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "AppDataPaths", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ApplicationData_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ApplicationData_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ApplicationData", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ApplicationDataCompositeValue_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ApplicationDataCompositeValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ApplicationDataCompositeValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ApplicationDataContainer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ApplicationDataContainer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ApplicationDataContainer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ApplicationDataContainerSettings_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ApplicationDataContainerSettings_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ApplicationDataContainerSettings", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&CachedFileManager_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "CachedFileManager", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&DownloadsFolder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DownloadsFolder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&FileIO_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "FileIO", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::FileIO>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&KnownFolders_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "KnownFolders", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&PathIO_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PathIO", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::PathIO>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SetVersionDeferral_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SetVersionDeferral_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SetVersionDeferral", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SetVersionRequest_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SetVersionRequest_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SetVersionRequest", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageFile_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageFile_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFile", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageFolder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageFolder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFolder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibrary_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibrary_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibrary", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibraryChange_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibraryChange_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryChange", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibraryChangeReader_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibraryChangeReader_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryChangeReader", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibraryChangeTracker_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibraryChangeTracker_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryChangeTracker", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageProvider_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageProvider_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageProvider", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageStreamTransaction_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageStreamTransaction_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageStreamTransaction", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StreamedFileDataRequest_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StreamedFileDataRequest_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StreamedFileDataRequest", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemAudioProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemAudioProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemAudioProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemDataPaths_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemDataPaths_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemDataPaths", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemGPSProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemGPSProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemGPSProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemImageProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemImageProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemImageProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemMediaProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemMediaProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMediaProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemMusicProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemMusicProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemMusicProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemPhotoProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemPhotoProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemPhotoProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&SystemProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SystemVideoProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SystemVideoProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SystemVideoProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    UserDataPaths_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&UserDataPaths_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "UserDataPaths", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFile_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFile_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFile", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFile2_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFile2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFile2", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFilePropertiesWithAvailability_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFilePropertiesWithAvailability_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFilePropertiesWithAvailability", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFolder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFolder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFolder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFolder2_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFolder2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFolder2", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageItem_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageItem_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageItem", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageItem2_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageItem2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageItem2", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageItemProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageItemProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageItemProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageItemProperties2_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageItemProperties2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageItemProperties2", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageItemPropertiesWithProvider_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageItemPropertiesWithProvider_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageItemPropertiesWithProvider", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStreamedFileDataRequest_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStreamedFileDataRequest_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStreamedFileDataRequest", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
