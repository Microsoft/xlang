// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.Search.h"

// ----- ContentIndexer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ContentIndexer>::python_type;


PyObject* ContentIndexer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ContentIndexer is not activatable");
    return nullptr;
}

static void ContentIndexer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ContentIndexer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::ContentIndexer>::convert(instance.as<winrt::Windows::Storage::Search::ContentIndexer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ContentIndexer_AddAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::IIndexableContent>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.AddAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_CreateQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>(args, 2);
            auto param3 = py::convert_to<winrt::hstring>(args, 3);

            winrt::Windows::Storage::Search::ContentIndexerQuery return_value = self->obj.CreateQuery(param0, param1, param2, param3);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>(args, 2);

            winrt::Windows::Storage::Search::ContentIndexerQuery return_value = self->obj.CreateQuery(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Storage::Search::ContentIndexerQuery return_value = self->obj.CreateQuery(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_DeleteAllAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAllAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_DeleteAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_DeleteMultipleAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.DeleteMultipleAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_GetIndexer(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Storage::Search::ContentIndexer return_value = winrt::Windows::Storage::Search::ContentIndexer::GetIndexer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::ContentIndexer return_value = winrt::Windows::Storage::Search::ContentIndexer::GetIndexer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_RetrievePropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>> return_value = self->obj.RetrievePropertiesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_UpdateAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::IIndexableContent>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.UpdateAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexer_get_Revision(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Revision();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ContentIndexer_methods[] = {
    { "AddAsync", (PyCFunction)ContentIndexer_AddAsync, METH_VARARGS, nullptr },
    { "CreateQuery", (PyCFunction)ContentIndexer_CreateQuery, METH_VARARGS, nullptr },
    { "DeleteAllAsync", (PyCFunction)ContentIndexer_DeleteAllAsync, METH_VARARGS, nullptr },
    { "DeleteAsync", (PyCFunction)ContentIndexer_DeleteAsync, METH_VARARGS, nullptr },
    { "DeleteMultipleAsync", (PyCFunction)ContentIndexer_DeleteMultipleAsync, METH_VARARGS, nullptr },
    { "GetIndexer", (PyCFunction)ContentIndexer_GetIndexer, METH_VARARGS | METH_STATIC, nullptr },
    { "RetrievePropertiesAsync", (PyCFunction)ContentIndexer_RetrievePropertiesAsync, METH_VARARGS, nullptr },
    { "UpdateAsync", (PyCFunction)ContentIndexer_UpdateAsync, METH_VARARGS, nullptr },
    { "get_Revision", (PyCFunction)ContentIndexer_get_Revision, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ContentIndexer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ContentIndexer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ContentIndexer_dealloc },
    { Py_tp_new, ContentIndexer_new },
    { Py_tp_methods, ContentIndexer_methods },
    { 0, nullptr },
};

static PyType_Spec ContentIndexer_Type_spec =
{
    "ContentIndexer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexer>),
    0,
    Py_TPFLAGS_DEFAULT,
    ContentIndexer_Type_slots
};

// ----- ContentIndexerQuery class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ContentIndexerQuery>::python_type;


PyObject* ContentIndexerQuery_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ContentIndexerQuery is not activatable");
    return nullptr;
}

static void ContentIndexerQuery_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ContentIndexerQuery__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::ContentIndexerQuery>::convert(instance.as<winrt::Windows::Storage::Search::ContentIndexerQuery>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ContentIndexerQuery_GetAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::IIndexableContent>> return_value = self->obj.GetAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::IIndexableContent>> return_value = self->obj.GetAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexerQuery_GetCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.GetCountAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexerQuery_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>> return_value = self->obj.GetPropertiesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>> return_value = self->obj.GetPropertiesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ContentIndexerQuery_get_QueryFolder(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.QueryFolder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ContentIndexerQuery_methods[] = {
    { "GetAsync", (PyCFunction)ContentIndexerQuery_GetAsync, METH_VARARGS, nullptr },
    { "GetCountAsync", (PyCFunction)ContentIndexerQuery_GetCountAsync, METH_VARARGS, nullptr },
    { "GetPropertiesAsync", (PyCFunction)ContentIndexerQuery_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "get_QueryFolder", (PyCFunction)ContentIndexerQuery_get_QueryFolder, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ContentIndexerQuery__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ContentIndexerQuery_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ContentIndexerQuery_dealloc },
    { Py_tp_new, ContentIndexerQuery_new },
    { Py_tp_methods, ContentIndexerQuery_methods },
    { 0, nullptr },
};

static PyType_Spec ContentIndexerQuery_Type_spec =
{
    "ContentIndexerQuery",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ContentIndexerQuery>),
    0,
    Py_TPFLAGS_DEFAULT,
    ContentIndexerQuery_Type_slots
};

// ----- IndexableContent class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IndexableContent>::python_type;


PyObject* IndexableContent_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::IndexableContent instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void IndexableContent_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IndexableContent__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::IndexableContent>::convert(instance.as<winrt::Windows::Storage::Search::IndexableContent>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IndexableContent_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable> return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.Stream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_get_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.StreamContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_put_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.Id(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_put_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::IRandomAccessStream>::convert_to(args);

            self->obj.Stream(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IndexableContent_put_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.StreamContentType(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IndexableContent_methods[] = {
    { "get_Id", (PyCFunction)IndexableContent_get_Id, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)IndexableContent_get_Properties, METH_NOARGS, nullptr },
    { "get_Stream", (PyCFunction)IndexableContent_get_Stream, METH_NOARGS, nullptr },
    { "get_StreamContentType", (PyCFunction)IndexableContent_get_StreamContentType, METH_NOARGS, nullptr },
    { "put_Id", (PyCFunction)IndexableContent_put_Id, METH_O, nullptr },
    { "put_Stream", (PyCFunction)IndexableContent_put_Stream, METH_O, nullptr },
    { "put_StreamContentType", (PyCFunction)IndexableContent_put_StreamContentType, METH_O, nullptr },
    { "_from", (PyCFunction)IndexableContent__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IndexableContent_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IndexableContent_dealloc },
    { Py_tp_new, IndexableContent_new },
    { Py_tp_methods, IndexableContent_methods },
    { 0, nullptr },
};

static PyType_Spec IndexableContent_Type_spec =
{
    "IndexableContent",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IndexableContent>),
    0,
    Py_TPFLAGS_DEFAULT,
    IndexableContent_Type_slots
};

// ----- QueryOptions class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::QueryOptions>::python_type;


PyObject* QueryOptions_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
            winrt::Windows::Storage::Search::QueryOptions instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            winrt::Windows::Storage::Search::QueryOptions instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void QueryOptions_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* QueryOptions__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::QueryOptions>::convert(instance.as<winrt::Windows::Storage::Search::QueryOptions>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* QueryOptions_LoadFromString(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            self->obj.LoadFromString(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* QueryOptions_SaveToString(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.SaveToString();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* QueryOptions_SetPropertyPrefetch(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::PropertyPrefetchOptions>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            self->obj.SetPropertyPrefetch(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* QueryOptions_SetThumbnailPrefetch(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

            self->obj.SetThumbnailPrefetch(param0, param1, param2);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* QueryOptions_get_ApplicationSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ApplicationSearchFilter();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_DateStackOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Search::DateStackOption return_value = self->obj.DateStackOption();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_FileTypeFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVector<winrt::hstring> return_value = self->obj.FileTypeFilter();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_FolderDepth(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Search::FolderDepth return_value = self->obj.FolderDepth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_GroupPropertyName(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.GroupPropertyName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_IndexerOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Search::IndexerOption return_value = self->obj.IndexerOption();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Language();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_SortOrder(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry> return_value = self->obj.SortOrder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_StorageProviderIdFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVector<winrt::hstring> return_value = self->obj.StorageProviderIdFilter();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_get_UserSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.UserSearchFilter();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_put_ApplicationSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.ApplicationSearchFilter(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_put_FolderDepth(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Search::FolderDepth>::convert_to(args);

            self->obj.FolderDepth(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_put_IndexerOption(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Search::IndexerOption>::convert_to(args);

            self->obj.IndexerOption(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_put_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.Language(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* QueryOptions_put_UserSearchFilter(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.UserSearchFilter(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef QueryOptions_methods[] = {
    { "LoadFromString", (PyCFunction)QueryOptions_LoadFromString, METH_VARARGS, nullptr },
    { "SaveToString", (PyCFunction)QueryOptions_SaveToString, METH_VARARGS, nullptr },
    { "SetPropertyPrefetch", (PyCFunction)QueryOptions_SetPropertyPrefetch, METH_VARARGS, nullptr },
    { "SetThumbnailPrefetch", (PyCFunction)QueryOptions_SetThumbnailPrefetch, METH_VARARGS, nullptr },
    { "get_ApplicationSearchFilter", (PyCFunction)QueryOptions_get_ApplicationSearchFilter, METH_NOARGS, nullptr },
    { "get_DateStackOption", (PyCFunction)QueryOptions_get_DateStackOption, METH_NOARGS, nullptr },
    { "get_FileTypeFilter", (PyCFunction)QueryOptions_get_FileTypeFilter, METH_NOARGS, nullptr },
    { "get_FolderDepth", (PyCFunction)QueryOptions_get_FolderDepth, METH_NOARGS, nullptr },
    { "get_GroupPropertyName", (PyCFunction)QueryOptions_get_GroupPropertyName, METH_NOARGS, nullptr },
    { "get_IndexerOption", (PyCFunction)QueryOptions_get_IndexerOption, METH_NOARGS, nullptr },
    { "get_Language", (PyCFunction)QueryOptions_get_Language, METH_NOARGS, nullptr },
    { "get_SortOrder", (PyCFunction)QueryOptions_get_SortOrder, METH_NOARGS, nullptr },
    { "get_StorageProviderIdFilter", (PyCFunction)QueryOptions_get_StorageProviderIdFilter, METH_NOARGS, nullptr },
    { "get_UserSearchFilter", (PyCFunction)QueryOptions_get_UserSearchFilter, METH_NOARGS, nullptr },
    { "put_ApplicationSearchFilter", (PyCFunction)QueryOptions_put_ApplicationSearchFilter, METH_O, nullptr },
    { "put_FolderDepth", (PyCFunction)QueryOptions_put_FolderDepth, METH_O, nullptr },
    { "put_IndexerOption", (PyCFunction)QueryOptions_put_IndexerOption, METH_O, nullptr },
    { "put_Language", (PyCFunction)QueryOptions_put_Language, METH_O, nullptr },
    { "put_UserSearchFilter", (PyCFunction)QueryOptions_put_UserSearchFilter, METH_O, nullptr },
    { "_from", (PyCFunction)QueryOptions__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot QueryOptions_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, QueryOptions_dealloc },
    { Py_tp_new, QueryOptions_new },
    { Py_tp_methods, QueryOptions_methods },
    { 0, nullptr },
};

static PyType_Spec QueryOptions_Type_spec =
{
    "QueryOptions",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::QueryOptions>),
    0,
    Py_TPFLAGS_DEFAULT,
    QueryOptions_Type_slots
};

// ----- SortEntryVector class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::SortEntryVector>::python_type;


PyObject* SortEntryVector_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SortEntryVector is not activatable");
    return nullptr;
}

static void SortEntryVector_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SortEntryVector__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::SortEntryVector>::convert(instance.as<winrt::Windows::Storage::Search::SortEntryVector>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SortEntryVector_Append(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 0);

            self->obj.Append(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_Clear(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_First(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::Search::SortEntry> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_GetAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Storage::Search::SortEntry return_value = self->obj.GetAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_GetMany(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*f*/ winrt::array_view<winrt::Windows::Storage::Search::SortEntry> param1 { }; // TODO: Convert incoming python parameter

            uint32_t return_value = self->obj.GetMany(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_GetView(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry> return_value = self->obj.GetView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_IndexOf(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 0);
            uint32_t param1 {  };

            bool return_value = self->obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::converter<decltype(return_value)>::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::converter<decltype(param1)>::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_InsertAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 1);

            self->obj.InsertAt(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_RemoveAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            self->obj.RemoveAt(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_RemoveAtEnd(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.RemoveAtEnd();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_ReplaceAll(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Storage::Search::SortEntry const> param0 { }; // TODO: Convert incoming python parameter

            self->obj.ReplaceAll(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_SetAt(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Search::SortEntry>(args, 1);

            self->obj.SetAt(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SortEntryVector_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SortEntryVector_methods[] = {
    { "Append", (PyCFunction)SortEntryVector_Append, METH_VARARGS, nullptr },
    { "Clear", (PyCFunction)SortEntryVector_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)SortEntryVector_First, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)SortEntryVector_GetAt, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)SortEntryVector_GetMany, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)SortEntryVector_GetView, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)SortEntryVector_IndexOf, METH_VARARGS, nullptr },
    { "InsertAt", (PyCFunction)SortEntryVector_InsertAt, METH_VARARGS, nullptr },
    { "RemoveAt", (PyCFunction)SortEntryVector_RemoveAt, METH_VARARGS, nullptr },
    { "RemoveAtEnd", (PyCFunction)SortEntryVector_RemoveAtEnd, METH_VARARGS, nullptr },
    { "ReplaceAll", (PyCFunction)SortEntryVector_ReplaceAll, METH_VARARGS, nullptr },
    { "SetAt", (PyCFunction)SortEntryVector_SetAt, METH_VARARGS, nullptr },
    { "get_Size", (PyCFunction)SortEntryVector_get_Size, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SortEntryVector__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SortEntryVector_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SortEntryVector_dealloc },
    { Py_tp_new, SortEntryVector_new },
    { Py_tp_methods, SortEntryVector_methods },
    { 0, nullptr },
};

static PyType_Spec SortEntryVector_Type_spec =
{
    "SortEntryVector",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::SortEntryVector>),
    0,
    Py_TPFLAGS_DEFAULT,
    SortEntryVector_Type_slots
};

// ----- StorageFileQueryResult class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageFileQueryResult>::python_type;


PyObject* StorageFileQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFileQueryResult is not activatable");
    return nullptr;
}

static void StorageFileQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFileQueryResult__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::StorageFileQueryResult>::convert(instance.as<winrt::Windows::Storage::Search::StorageFileQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFileQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            self->obj.ApplyNewQueryOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.FindStartIndexAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions return_value = self->obj.GetCurrentQueryOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.GetItemCountAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_GetMatchingPropertiesWithRanges(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

            winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>> return_value = self->obj.GetMatchingPropertiesWithRanges(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFileQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.ContentsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFileQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.OptionsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFileQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFileQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.ContentsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFileQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.OptionsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageFileQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageFileQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageFileQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageFileQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)StorageFileQueryResult_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageFileQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "GetMatchingPropertiesWithRanges", (PyCFunction)StorageFileQueryResult_GetMatchingPropertiesWithRanges, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageFileQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageFileQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "get_Folder", (PyCFunction)StorageFileQueryResult_get_Folder, METH_NOARGS, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageFileQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageFileQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)StorageFileQueryResult__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageFileQueryResult_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageFileQueryResult_dealloc },
    { Py_tp_new, StorageFileQueryResult_new },
    { Py_tp_methods, StorageFileQueryResult_methods },
    { 0, nullptr },
};

static PyType_Spec StorageFileQueryResult_Type_spec =
{
    "StorageFileQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFileQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFileQueryResult_Type_slots
};

// ----- StorageFolderQueryResult class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageFolderQueryResult>::python_type;


PyObject* StorageFolderQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageFolderQueryResult is not activatable");
    return nullptr;
}

static void StorageFolderQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageFolderQueryResult__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::StorageFolderQueryResult>::convert(instance.as<winrt::Windows::Storage::Search::StorageFolderQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageFolderQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            self->obj.ApplyNewQueryOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolderQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.FindStartIndexAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions return_value = self->obj.GetCurrentQueryOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolderQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.GetItemCountAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageFolderQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.ContentsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolderQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.OptionsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolderQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolderQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.ContentsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageFolderQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.OptionsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageFolderQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageFolderQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageFolderQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageFolderQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)StorageFolderQueryResult_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageFolderQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageFolderQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageFolderQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "get_Folder", (PyCFunction)StorageFolderQueryResult_get_Folder, METH_NOARGS, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageFolderQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageFolderQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)StorageFolderQueryResult__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageFolderQueryResult_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageFolderQueryResult_dealloc },
    { Py_tp_new, StorageFolderQueryResult_new },
    { Py_tp_methods, StorageFolderQueryResult_methods },
    { 0, nullptr },
};

static PyType_Spec StorageFolderQueryResult_Type_spec =
{
    "StorageFolderQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageFolderQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageFolderQueryResult_Type_slots
};

// ----- StorageItemQueryResult class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageItemQueryResult>::python_type;


PyObject* StorageItemQueryResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageItemQueryResult is not activatable");
    return nullptr;
}

static void StorageItemQueryResult_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageItemQueryResult__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::StorageItemQueryResult>::convert(instance.as<winrt::Windows::Storage::Search::StorageItemQueryResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageItemQueryResult_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            self->obj.ApplyNewQueryOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageItemQueryResult_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.FindStartIndexAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions return_value = self->obj.GetCurrentQueryOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.GetItemCountAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageItemQueryResult_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageItemQueryResult_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.ContentsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageItemQueryResult_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.OptionsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageItemQueryResult_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageItemQueryResult_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.ContentsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageItemQueryResult_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.OptionsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageItemQueryResult_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)StorageItemQueryResult_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)StorageItemQueryResult_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)StorageItemQueryResult_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)StorageItemQueryResult_GetItemCountAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)StorageItemQueryResult_GetItemsAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)StorageItemQueryResult_add_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)StorageItemQueryResult_add_OptionsChanged, METH_O, nullptr },
    { "get_Folder", (PyCFunction)StorageItemQueryResult_get_Folder, METH_NOARGS, nullptr },
    { "remove_ContentsChanged", (PyCFunction)StorageItemQueryResult_remove_ContentsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)StorageItemQueryResult_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)StorageItemQueryResult__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageItemQueryResult_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageItemQueryResult_dealloc },
    { Py_tp_new, StorageItemQueryResult_new },
    { Py_tp_methods, StorageItemQueryResult_methods },
    { 0, nullptr },
};

static PyType_Spec StorageItemQueryResult_Type_spec =
{
    "StorageItemQueryResult",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageItemQueryResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageItemQueryResult_Type_slots
};

// ----- StorageLibraryChangeTrackerTriggerDetails class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>::python_type;


PyObject* StorageLibraryChangeTrackerTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryChangeTrackerTriggerDetails is not activatable");
    return nullptr;
}

static void StorageLibraryChangeTrackerTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryChangeTrackerTriggerDetails__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>::convert(instance.as<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryChangeTrackerTriggerDetails_get_ChangeTracker(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageLibraryChangeTracker return_value = self->obj.ChangeTracker();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* StorageLibraryChangeTrackerTriggerDetails_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageLibraryChangeTrackerTriggerDetails_methods[] = {
    { "get_ChangeTracker", (PyCFunction)StorageLibraryChangeTrackerTriggerDetails_get_ChangeTracker, METH_NOARGS, nullptr },
    { "get_Folder", (PyCFunction)StorageLibraryChangeTrackerTriggerDetails_get_Folder, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageLibraryChangeTrackerTriggerDetails__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryChangeTrackerTriggerDetails_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibraryChangeTrackerTriggerDetails_dealloc },
    { Py_tp_new, StorageLibraryChangeTrackerTriggerDetails_new },
    { Py_tp_methods, StorageLibraryChangeTrackerTriggerDetails_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryChangeTrackerTriggerDetails_Type_spec =
{
    "StorageLibraryChangeTrackerTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryChangeTrackerTriggerDetails_Type_slots
};

// ----- StorageLibraryContentChangedTriggerDetails class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>::python_type;


PyObject* StorageLibraryContentChangedTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StorageLibraryContentChangedTriggerDetails is not activatable");
    return nullptr;
}

static void StorageLibraryContentChangedTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StorageLibraryContentChangedTriggerDetails__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>::convert(instance.as<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StorageLibraryContentChangedTriggerDetails_CreateModifiedSinceQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            winrt::Windows::Storage::Search::StorageItemQueryResult return_value = self->obj.CreateModifiedSinceQuery(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* StorageLibraryContentChangedTriggerDetails_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StorageLibraryContentChangedTriggerDetails_methods[] = {
    { "CreateModifiedSinceQuery", (PyCFunction)StorageLibraryContentChangedTriggerDetails_CreateModifiedSinceQuery, METH_VARARGS, nullptr },
    { "get_Folder", (PyCFunction)StorageLibraryContentChangedTriggerDetails_get_Folder, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StorageLibraryContentChangedTriggerDetails__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StorageLibraryContentChangedTriggerDetails_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StorageLibraryContentChangedTriggerDetails_dealloc },
    { Py_tp_new, StorageLibraryContentChangedTriggerDetails_new },
    { Py_tp_methods, StorageLibraryContentChangedTriggerDetails_methods },
    { 0, nullptr },
};

static PyType_Spec StorageLibraryContentChangedTriggerDetails_Type_spec =
{
    "StorageLibraryContentChangedTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    StorageLibraryContentChangedTriggerDetails_Type_slots
};

// ----- ValueAndLanguage class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::ValueAndLanguage>::python_type;


PyObject* ValueAndLanguage_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::ValueAndLanguage instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void ValueAndLanguage_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ValueAndLanguage__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::ValueAndLanguage>::convert(instance.as<winrt::Windows::Storage::Search::ValueAndLanguage>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ValueAndLanguage_get_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Language();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ValueAndLanguage_get_Value(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IInspectable return_value = self->obj.Value();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ValueAndLanguage_put_Language(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.Language(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ValueAndLanguage_put_Value(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(args);

            self->obj.Value(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ValueAndLanguage_methods[] = {
    { "get_Language", (PyCFunction)ValueAndLanguage_get_Language, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)ValueAndLanguage_get_Value, METH_NOARGS, nullptr },
    { "put_Language", (PyCFunction)ValueAndLanguage_put_Language, METH_O, nullptr },
    { "put_Value", (PyCFunction)ValueAndLanguage_put_Value, METH_O, nullptr },
    { "_from", (PyCFunction)ValueAndLanguage__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ValueAndLanguage_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ValueAndLanguage_dealloc },
    { Py_tp_new, ValueAndLanguage_new },
    { Py_tp_methods, ValueAndLanguage_methods },
    { 0, nullptr },
};

static PyType_Spec ValueAndLanguage_Type_spec =
{
    "ValueAndLanguage",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::ValueAndLanguage>),
    0,
    Py_TPFLAGS_DEFAULT,
    ValueAndLanguage_Type_slots
};

// ----- IIndexableContent interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IIndexableContent>::python_type;


PyObject* IIndexableContent_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IIndexableContent interface is not activatable");
    return nullptr;
}

static void IIndexableContent_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IIndexableContent__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::IIndexableContent>::convert(instance.as<winrt::Windows::Storage::Search::IIndexableContent>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IIndexableContent_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_get_Properties(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable> return_value = self->obj.Properties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_get_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.Stream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_get_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.StreamContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_put_Id(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.Id(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_put_Stream(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::IRandomAccessStream>::convert_to(args);

            self->obj.Stream(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IIndexableContent_put_StreamContentType(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::hstring>::convert_to(args);

            self->obj.StreamContentType(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IIndexableContent_methods[] = {
    { "get_Id", (PyCFunction)IIndexableContent_get_Id, METH_NOARGS, nullptr },
    { "get_Properties", (PyCFunction)IIndexableContent_get_Properties, METH_NOARGS, nullptr },
    { "get_Stream", (PyCFunction)IIndexableContent_get_Stream, METH_NOARGS, nullptr },
    { "get_StreamContentType", (PyCFunction)IIndexableContent_get_StreamContentType, METH_NOARGS, nullptr },
    { "put_Id", (PyCFunction)IIndexableContent_put_Id, METH_O, nullptr },
    { "put_Stream", (PyCFunction)IIndexableContent_put_Stream, METH_O, nullptr },
    { "put_StreamContentType", (PyCFunction)IIndexableContent_put_StreamContentType, METH_O, nullptr },
    { "_from", (PyCFunction)IIndexableContent__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IIndexableContent_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IIndexableContent_dealloc },
    { Py_tp_new, IIndexableContent_new },
    { Py_tp_methods, IIndexableContent_methods },
    { 0, nullptr },
};

static PyType_Spec IIndexableContent_Type_spec =
{
    "IIndexableContent",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IIndexableContent>),
    0,
    Py_TPFLAGS_DEFAULT,
    IIndexableContent_Type_slots
};

// ----- IStorageFolderQueryOperations interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>::python_type;


PyObject* IStorageFolderQueryOperations_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageFolderQueryOperations interface is not activatable");
    return nullptr;
}

static void IStorageFolderQueryOperations_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageFolderQueryOperations__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>::convert(instance.as<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageFolderQueryOperations_AreQueryOptionsSupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            bool return_value = self->obj.AreQueryOptionsSupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFileQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQuery(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFileQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageFileQueryResult return_value = self->obj.CreateFileQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFolderQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQuery(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateFolderQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageFolderQueryResult return_value = self->obj.CreateFolderQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateItemQuery(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::StorageItemQueryResult return_value = self->obj.CreateItemQuery();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_CreateItemQueryWithOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            winrt::Windows::Storage::Search::StorageItemQueryResult return_value = self->obj.CreateItemQueryWithOptions(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetFilesAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>> return_value = self->obj.GetFilesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetFoldersAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>> return_value = self->obj.GetFoldersAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetIndexedStateAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Search::IndexedState> return_value = self->obj.GetIndexedStateAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_GetItemsAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>> return_value = self->obj.GetItemsAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_IsCommonFileQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

            bool return_value = self->obj.IsCommonFileQuerySupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageFolderQueryOperations_IsCommonFolderQuerySupported(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

            bool return_value = self->obj.IsCommonFolderQuerySupported(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStorageFolderQueryOperations_methods[] = {
    { "AreQueryOptionsSupported", (PyCFunction)IStorageFolderQueryOperations_AreQueryOptionsSupported, METH_VARARGS, nullptr },
    { "CreateFileQuery", (PyCFunction)IStorageFolderQueryOperations_CreateFileQuery, METH_VARARGS, nullptr },
    { "CreateFileQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateFileQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateFolderQuery", (PyCFunction)IStorageFolderQueryOperations_CreateFolderQuery, METH_VARARGS, nullptr },
    { "CreateFolderQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateFolderQueryWithOptions, METH_VARARGS, nullptr },
    { "CreateItemQuery", (PyCFunction)IStorageFolderQueryOperations_CreateItemQuery, METH_VARARGS, nullptr },
    { "CreateItemQueryWithOptions", (PyCFunction)IStorageFolderQueryOperations_CreateItemQueryWithOptions, METH_VARARGS, nullptr },
    { "GetFilesAsync", (PyCFunction)IStorageFolderQueryOperations_GetFilesAsync, METH_VARARGS, nullptr },
    { "GetFoldersAsync", (PyCFunction)IStorageFolderQueryOperations_GetFoldersAsync, METH_VARARGS, nullptr },
    { "GetIndexedStateAsync", (PyCFunction)IStorageFolderQueryOperations_GetIndexedStateAsync, METH_VARARGS, nullptr },
    { "GetItemsAsync", (PyCFunction)IStorageFolderQueryOperations_GetItemsAsync, METH_VARARGS, nullptr },
    { "IsCommonFileQuerySupported", (PyCFunction)IStorageFolderQueryOperations_IsCommonFileQuerySupported, METH_VARARGS, nullptr },
    { "IsCommonFolderQuerySupported", (PyCFunction)IStorageFolderQueryOperations_IsCommonFolderQuerySupported, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IStorageFolderQueryOperations__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageFolderQueryOperations_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageFolderQueryOperations_dealloc },
    { Py_tp_new, IStorageFolderQueryOperations_new },
    { Py_tp_methods, IStorageFolderQueryOperations_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageFolderQueryOperations_Type_spec =
{
    "IStorageFolderQueryOperations",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageFolderQueryOperations_Type_slots
};

// ----- IStorageQueryResultBase interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::IStorageQueryResultBase>::python_type;


PyObject* IStorageQueryResultBase_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStorageQueryResultBase interface is not activatable");
    return nullptr;
}

static void IStorageQueryResultBase_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStorageQueryResultBase__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Search::IStorageQueryResultBase>::convert(instance.as<winrt::Windows::Storage::Search::IStorageQueryResultBase>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStorageQueryResultBase_ApplyNewQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

            self->obj.ApplyNewQueryOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageQueryResultBase_FindStartIndexAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.FindStartIndexAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageQueryResultBase_GetCurrentQueryOptions(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Search::QueryOptions return_value = self->obj.GetCurrentQueryOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageQueryResultBase_GetItemCountAsync(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<uint32_t> return_value = self->obj.GetItemCountAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IStorageQueryResultBase_add_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.ContentsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageQueryResultBase_add_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Search::IStorageQueryResultBase, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.OptionsChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageQueryResultBase_get_Folder(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::StorageFolder return_value = self->obj.Folder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageQueryResultBase_remove_ContentsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.ContentsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IStorageQueryResultBase_remove_OptionsChanged(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.OptionsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IStorageQueryResultBase_methods[] = {
    { "ApplyNewQueryOptions", (PyCFunction)IStorageQueryResultBase_ApplyNewQueryOptions, METH_VARARGS, nullptr },
    { "FindStartIndexAsync", (PyCFunction)IStorageQueryResultBase_FindStartIndexAsync, METH_VARARGS, nullptr },
    { "GetCurrentQueryOptions", (PyCFunction)IStorageQueryResultBase_GetCurrentQueryOptions, METH_VARARGS, nullptr },
    { "GetItemCountAsync", (PyCFunction)IStorageQueryResultBase_GetItemCountAsync, METH_VARARGS, nullptr },
    { "add_ContentsChanged", (PyCFunction)IStorageQueryResultBase_add_ContentsChanged, METH_O, nullptr },
    { "add_OptionsChanged", (PyCFunction)IStorageQueryResultBase_add_OptionsChanged, METH_O, nullptr },
    { "get_Folder", (PyCFunction)IStorageQueryResultBase_get_Folder, METH_NOARGS, nullptr },
    { "remove_ContentsChanged", (PyCFunction)IStorageQueryResultBase_remove_ContentsChanged, METH_O, nullptr },
    { "remove_OptionsChanged", (PyCFunction)IStorageQueryResultBase_remove_OptionsChanged, METH_O, nullptr },
    { "_from", (PyCFunction)IStorageQueryResultBase__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStorageQueryResultBase_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStorageQueryResultBase_dealloc },
    { Py_tp_new, IStorageQueryResultBase_new },
    { Py_tp_methods, IStorageQueryResultBase_methods },
    { 0, nullptr },
};

static PyType_Spec IStorageQueryResultBase_Type_spec =
{
    "IStorageQueryResultBase",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Search::IStorageQueryResultBase>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStorageQueryResultBase_Type_slots
};

// ----- SortEntry struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Search::SortEntry>::python_type;

PyObject* py::converter<winrt::Windows::Storage::Search::SortEntry>::convert(winrt::Windows::Storage::Search::SortEntry instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Storage::Search::SortEntry>(instance, py::get_python_type<winrt::Windows::Storage::Search::SortEntry>());
}

winrt::Windows::Storage::Search::SortEntry py::converter<winrt::Windows::Storage::Search::SortEntry>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Storage::Search::SortEntry>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Storage::Search::SortEntry new_value{};
    PyObject* pyPropertyName = PyDict_GetItemString(obj, "PropertyName");
    if (!pyPropertyName) { throw winrt::hresult_invalid_argument(); }
    new_value.PropertyName = converter<winrt::hstring>::convert_to(pyPropertyName);
    PyObject* pyAscendingOrder = PyDict_GetItemString(obj, "AscendingOrder");
    if (!pyAscendingOrder) { throw winrt::hresult_invalid_argument(); }
    new_value.AscendingOrder = converter<bool>::convert_to(pyAscendingOrder);
    return new_value;
}

PyObject* SortEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Storage::Search::SortEntry instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Storage::Search::SortEntry>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    winrt::hstring _PropertyName{};
    bool _AscendingOrder{};
    static char* kwlist[] = {"PropertyName", "AscendingOrder", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "up", kwlist, &_PropertyName, &_AscendingOrder))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Storage::Search::SortEntry instance{ _PropertyName, _AscendingOrder };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SortEntry_get_PropertyName(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.PropertyName)>::convert(self->obj.PropertyName);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SortEntry_set_PropertyName(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.PropertyName = py::converter<winrt::hstring>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* SortEntry_get_AscendingOrder(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.AscendingOrder)>::convert(self->obj.AscendingOrder);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int SortEntry_set_AscendingOrder(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.AscendingOrder = py::converter<bool>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef SortEntry_getset[] = {
    { const_cast<char*>("PropertyName"), (getter)SortEntry_get_PropertyName, (setter)SortEntry_set_PropertyName, nullptr, nullptr },
    { const_cast<char*>("AscendingOrder"), (getter)SortEntry_get_AscendingOrder, (setter)SortEntry_set_AscendingOrder, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot SortEntry_Type_slots[] = 
{
    { Py_tp_new, SortEntry_new },
    { Py_tp_getset, SortEntry_getset },
    { 0, nullptr },
};

static PyType_Spec SortEntry_Type_spec =
{
    "SortEntry",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Storage::Search::SortEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    SortEntry_Type_slots
};

// ----- Windows.Storage.Search Initialization --------------------

int initialize_Windows_Storage_Search(PyObject* module)
{
    PyObject* type_object{ nullptr };


    ContentIndexer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ContentIndexer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ContentIndexer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ContentIndexer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ContentIndexerQuery_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ContentIndexerQuery_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ContentIndexerQuery", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ContentIndexerQuery>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IndexableContent_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IndexableContent_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IndexableContent", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IndexableContent>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    QueryOptions_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&QueryOptions_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "QueryOptions", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::QueryOptions>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SortEntryVector_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SortEntryVector_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SortEntryVector", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::SortEntryVector>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageFileQueryResult_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageFileQueryResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFileQueryResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageFileQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageFolderQueryResult_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageFolderQueryResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageFolderQueryResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageFolderQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageItemQueryResult_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageItemQueryResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageItemQueryResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageItemQueryResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibraryChangeTrackerTriggerDetails_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibraryChangeTrackerTriggerDetails_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryChangeTrackerTriggerDetails", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StorageLibraryContentChangedTriggerDetails_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StorageLibraryContentChangedTriggerDetails_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StorageLibraryContentChangedTriggerDetails", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ValueAndLanguage_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ValueAndLanguage_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ValueAndLanguage", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::ValueAndLanguage>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IIndexableContent_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IIndexableContent_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IIndexableContent", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IIndexableContent>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageFolderQueryOperations_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageFolderQueryOperations_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageFolderQueryOperations", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IStorageFolderQueryOperations>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStorageQueryResultBase_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStorageQueryResultBase_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStorageQueryResultBase", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::IStorageQueryResultBase>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&SortEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SortEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Search::SortEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
