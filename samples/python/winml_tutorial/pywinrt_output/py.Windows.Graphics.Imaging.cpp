// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Graphics.Imaging.h"

// ----- BitmapBuffer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type;


PyObject* BitmapBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapBuffer is not activatable");
    return nullptr;
}

static void BitmapBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapBuffer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapBuffer>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapBuffer_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapBuffer_GetPlaneCount(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int32_t return_value = self->obj.GetPlaneCount();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapBuffer_GetPlaneDescription(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);

            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value = self->obj.GetPlaneDescription(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef BitmapBuffer_methods[] = {
    { "Close", (PyCFunction)BitmapBuffer_Close, METH_VARARGS, nullptr },
    { "CreateReference", (PyCFunction)BitmapBuffer_CreateReference, METH_VARARGS, nullptr },
    { "GetPlaneCount", (PyCFunction)BitmapBuffer_GetPlaneCount, METH_VARARGS, nullptr },
    { "GetPlaneDescription", (PyCFunction)BitmapBuffer_GetPlaneDescription, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)BitmapBuffer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapBuffer_dealloc },
    { Py_tp_new, BitmapBuffer_new },
    { Py_tp_methods, BitmapBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapBuffer_Type_spec =
{
    "BitmapBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapBuffer_Type_slots
};

// ----- BitmapCodecInformation class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type;


PyObject* BitmapCodecInformation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapCodecInformation is not activatable");
    return nullptr;
}

static void BitmapCodecInformation_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapCodecInformation__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapCodecInformation_get_CodecId(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = self->obj.CodecId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapCodecInformation_get_FileExtensions(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring> return_value = self->obj.FileExtensions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapCodecInformation_get_FriendlyName(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.FriendlyName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapCodecInformation_get_MimeTypes(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring> return_value = self->obj.MimeTypes();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapCodecInformation_methods[] = {
    { "get_CodecId", (PyCFunction)BitmapCodecInformation_get_CodecId, METH_NOARGS, nullptr },
    { "get_FileExtensions", (PyCFunction)BitmapCodecInformation_get_FileExtensions, METH_NOARGS, nullptr },
    { "get_FriendlyName", (PyCFunction)BitmapCodecInformation_get_FriendlyName, METH_NOARGS, nullptr },
    { "get_MimeTypes", (PyCFunction)BitmapCodecInformation_get_MimeTypes, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)BitmapCodecInformation__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapCodecInformation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapCodecInformation_dealloc },
    { Py_tp_new, BitmapCodecInformation_new },
    { Py_tp_methods, BitmapCodecInformation_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapCodecInformation_Type_spec =
{
    "BitmapCodecInformation",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapCodecInformation_Type_slots
};

// ----- BitmapDecoder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type;


PyObject* BitmapDecoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapDecoder is not activatable");
    return nullptr;
}

static void BitmapDecoder_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapDecoder__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapDecoder>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapDecoder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapDecoder_CreateAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapDecoder> return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapDecoder> return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetDecoderInformationEnumerator(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::Imaging::BitmapCodecInformation> return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::GetDecoderInformationEnumerator();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetFrameAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapFrame> return_value = self->obj.GetFrameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetPreviewAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::ImageStream> return_value = self->obj.GetPreviewAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::ImageStream> return_value = self->obj.GetThumbnailAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapDecoder_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_BitmapContainerProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertiesView return_value = self->obj.BitmapContainerProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertiesView return_value = self->obj.BitmapProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_BmpDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::BmpDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_DecoderInformation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapCodecInformation return_value = self->obj.DecoderInformation();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiX();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiY();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_FrameCount(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.FrameCount();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_GifDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::GifDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_HeifDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::HeifDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_IcoDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::IcoDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_JpegDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_JpegXRDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegXRDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_PngDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::PngDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_TiffDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::TiffDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapDecoder_get_WebpDecoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapDecoder::WebpDecoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapDecoder_methods[] = {
    { "CreateAsync", (PyCFunction)BitmapDecoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetDecoderInformationEnumerator", (PyCFunction)BitmapDecoder_GetDecoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
    { "GetFrameAsync", (PyCFunction)BitmapDecoder_GetFrameAsync, METH_VARARGS, nullptr },
    { "GetPixelDataAsync", (PyCFunction)BitmapDecoder_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetPreviewAsync", (PyCFunction)BitmapDecoder_GetPreviewAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)BitmapDecoder_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)BitmapDecoder_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_BitmapAlphaMode", (PyCFunction)BitmapDecoder_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapContainerProperties", (PyCFunction)BitmapDecoder_get_BitmapContainerProperties, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)BitmapDecoder_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_BitmapProperties", (PyCFunction)BitmapDecoder_get_BitmapProperties, METH_NOARGS, nullptr },
    { "get_BmpDecoderId", (PyCFunction)BitmapDecoder_get_BmpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_DecoderInformation", (PyCFunction)BitmapDecoder_get_DecoderInformation, METH_NOARGS, nullptr },
    { "get_DpiX", (PyCFunction)BitmapDecoder_get_DpiX, METH_NOARGS, nullptr },
    { "get_DpiY", (PyCFunction)BitmapDecoder_get_DpiY, METH_NOARGS, nullptr },
    { "get_FrameCount", (PyCFunction)BitmapDecoder_get_FrameCount, METH_NOARGS, nullptr },
    { "get_GifDecoderId", (PyCFunction)BitmapDecoder_get_GifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HeifDecoderId", (PyCFunction)BitmapDecoder_get_HeifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_IcoDecoderId", (PyCFunction)BitmapDecoder_get_IcoDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegDecoderId", (PyCFunction)BitmapDecoder_get_JpegDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegXRDecoderId", (PyCFunction)BitmapDecoder_get_JpegXRDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_OrientedPixelHeight", (PyCFunction)BitmapDecoder_get_OrientedPixelHeight, METH_NOARGS, nullptr },
    { "get_OrientedPixelWidth", (PyCFunction)BitmapDecoder_get_OrientedPixelWidth, METH_NOARGS, nullptr },
    { "get_PixelHeight", (PyCFunction)BitmapDecoder_get_PixelHeight, METH_NOARGS, nullptr },
    { "get_PixelWidth", (PyCFunction)BitmapDecoder_get_PixelWidth, METH_NOARGS, nullptr },
    { "get_PngDecoderId", (PyCFunction)BitmapDecoder_get_PngDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_TiffDecoderId", (PyCFunction)BitmapDecoder_get_TiffDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_WebpDecoderId", (PyCFunction)BitmapDecoder_get_WebpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)BitmapDecoder__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapDecoder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapDecoder_dealloc },
    { Py_tp_new, BitmapDecoder_new },
    { Py_tp_methods, BitmapDecoder_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapDecoder_Type_spec =
{
    "BitmapDecoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapDecoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapDecoder_Type_slots
};

// ----- BitmapEncoder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type;


PyObject* BitmapEncoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapEncoder is not activatable");
    return nullptr;
}

static void BitmapEncoder_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapEncoder__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapEncoder>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapEncoder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapEncoder_CreateAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapEncoder> return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapEncoder> return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_CreateForInPlacePropertyEncodingAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapEncoder> return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForInPlacePropertyEncodingAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_CreateForTranscodingAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapEncoder> return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForTranscodingAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_FlushAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_GetEncoderInformationEnumerator(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::Imaging::BitmapCodecInformation> return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::GetEncoderInformationEnumerator();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_GoToNextFrameAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.GoToNextFrameAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.GoToNextFrameAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_SetPixelData(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 7)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            auto param4 = py::convert_to<double>(args, 4);
            auto param5 = py::convert_to<double>(args, 5);
            /*p*/ winrt::array_view<uint8_t const> param6 { }; // TODO: Convert incoming python parameter

            self->obj.SetPixelData(param0, param1, param2, param3, param4, param5, param6);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_SetSoftwareBitmap(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

            self->obj.SetSoftwareBitmap(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapEncoder_get_BitmapContainerProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapProperties return_value = self->obj.BitmapContainerProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapProperties return_value = self->obj.BitmapProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_BitmapTransform(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapTransform return_value = self->obj.BitmapTransform();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_BmpEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::BmpEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_EncoderInformation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapCodecInformation return_value = self->obj.EncoderInformation();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_GeneratedThumbnailHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.GeneratedThumbnailHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_GeneratedThumbnailWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.GeneratedThumbnailWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_GifEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::GifEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_HeifEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::HeifEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_IsThumbnailGenerated(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsThumbnailGenerated();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_JpegEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_JpegXREncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegXREncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_PngEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::PngEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_get_TiffEncoderId(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Graphics::Imaging::BitmapEncoder::TiffEncoderId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_put_GeneratedThumbnailHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.GeneratedThumbnailHeight(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_put_GeneratedThumbnailWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.GeneratedThumbnailWidth(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapEncoder_put_IsThumbnailGenerated(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<bool>::convert_to(args);

            self->obj.IsThumbnailGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapEncoder_methods[] = {
    { "CreateAsync", (PyCFunction)BitmapEncoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateForInPlacePropertyEncodingAsync", (PyCFunction)BitmapEncoder_CreateForInPlacePropertyEncodingAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateForTranscodingAsync", (PyCFunction)BitmapEncoder_CreateForTranscodingAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "FlushAsync", (PyCFunction)BitmapEncoder_FlushAsync, METH_VARARGS, nullptr },
    { "GetEncoderInformationEnumerator", (PyCFunction)BitmapEncoder_GetEncoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
    { "GoToNextFrameAsync", (PyCFunction)BitmapEncoder_GoToNextFrameAsync, METH_VARARGS, nullptr },
    { "SetPixelData", (PyCFunction)BitmapEncoder_SetPixelData, METH_VARARGS, nullptr },
    { "SetSoftwareBitmap", (PyCFunction)BitmapEncoder_SetSoftwareBitmap, METH_VARARGS, nullptr },
    { "get_BitmapContainerProperties", (PyCFunction)BitmapEncoder_get_BitmapContainerProperties, METH_NOARGS, nullptr },
    { "get_BitmapProperties", (PyCFunction)BitmapEncoder_get_BitmapProperties, METH_NOARGS, nullptr },
    { "get_BitmapTransform", (PyCFunction)BitmapEncoder_get_BitmapTransform, METH_NOARGS, nullptr },
    { "get_BmpEncoderId", (PyCFunction)BitmapEncoder_get_BmpEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_EncoderInformation", (PyCFunction)BitmapEncoder_get_EncoderInformation, METH_NOARGS, nullptr },
    { "get_GeneratedThumbnailHeight", (PyCFunction)BitmapEncoder_get_GeneratedThumbnailHeight, METH_NOARGS, nullptr },
    { "get_GeneratedThumbnailWidth", (PyCFunction)BitmapEncoder_get_GeneratedThumbnailWidth, METH_NOARGS, nullptr },
    { "get_GifEncoderId", (PyCFunction)BitmapEncoder_get_GifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_HeifEncoderId", (PyCFunction)BitmapEncoder_get_HeifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_IsThumbnailGenerated", (PyCFunction)BitmapEncoder_get_IsThumbnailGenerated, METH_NOARGS, nullptr },
    { "get_JpegEncoderId", (PyCFunction)BitmapEncoder_get_JpegEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_JpegXREncoderId", (PyCFunction)BitmapEncoder_get_JpegXREncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_PngEncoderId", (PyCFunction)BitmapEncoder_get_PngEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "get_TiffEncoderId", (PyCFunction)BitmapEncoder_get_TiffEncoderId, METH_NOARGS | METH_STATIC, nullptr },
    { "put_GeneratedThumbnailHeight", (PyCFunction)BitmapEncoder_put_GeneratedThumbnailHeight, METH_O, nullptr },
    { "put_GeneratedThumbnailWidth", (PyCFunction)BitmapEncoder_put_GeneratedThumbnailWidth, METH_O, nullptr },
    { "put_IsThumbnailGenerated", (PyCFunction)BitmapEncoder_put_IsThumbnailGenerated, METH_O, nullptr },
    { "_from", (PyCFunction)BitmapEncoder__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapEncoder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapEncoder_dealloc },
    { Py_tp_new, BitmapEncoder_new },
    { Py_tp_methods, BitmapEncoder_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapEncoder_Type_spec =
{
    "BitmapEncoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapEncoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapEncoder_Type_slots
};

// ----- BitmapFrame class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type;


PyObject* BitmapFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapFrame is not activatable");
    return nullptr;
}

static void BitmapFrame_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapFrame__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapFrame>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapFrame_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapFrame_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapFrame_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::ImageStream> return_value = self->obj.GetThumbnailAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapFrame_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertiesView return_value = self->obj.BitmapProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiX();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiY();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapFrame_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapFrame_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)BitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)BitmapFrame_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)BitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_BitmapAlphaMode", (PyCFunction)BitmapFrame_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)BitmapFrame_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_BitmapProperties", (PyCFunction)BitmapFrame_get_BitmapProperties, METH_NOARGS, nullptr },
    { "get_DpiX", (PyCFunction)BitmapFrame_get_DpiX, METH_NOARGS, nullptr },
    { "get_DpiY", (PyCFunction)BitmapFrame_get_DpiY, METH_NOARGS, nullptr },
    { "get_OrientedPixelHeight", (PyCFunction)BitmapFrame_get_OrientedPixelHeight, METH_NOARGS, nullptr },
    { "get_OrientedPixelWidth", (PyCFunction)BitmapFrame_get_OrientedPixelWidth, METH_NOARGS, nullptr },
    { "get_PixelHeight", (PyCFunction)BitmapFrame_get_PixelHeight, METH_NOARGS, nullptr },
    { "get_PixelWidth", (PyCFunction)BitmapFrame_get_PixelWidth, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)BitmapFrame__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapFrame_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapFrame_dealloc },
    { Py_tp_new, BitmapFrame_new },
    { Py_tp_methods, BitmapFrame_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapFrame_Type_spec =
{
    "BitmapFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapFrame_Type_slots
};

// ----- BitmapProperties class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type;


PyObject* BitmapProperties_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapProperties is not activatable");
    return nullptr;
}

static void BitmapProperties_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapProperties__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapProperties>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapProperties>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapProperties_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapPropertySet> return_value = self->obj.GetPropertiesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapProperties_SetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

            winrt::Windows::Foundation::IAsyncAction return_value = self->obj.SetPropertiesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef BitmapProperties_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)BitmapProperties_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "SetPropertiesAsync", (PyCFunction)BitmapProperties_SetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)BitmapProperties__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapProperties_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapProperties_dealloc },
    { Py_tp_new, BitmapProperties_new },
    { Py_tp_methods, BitmapProperties_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapProperties_Type_spec =
{
    "BitmapProperties",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapProperties>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapProperties_Type_slots
};

// ----- BitmapPropertiesView class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type;


PyObject* BitmapPropertiesView_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "BitmapPropertiesView is not activatable");
    return nullptr;
}

static void BitmapPropertiesView_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapPropertiesView__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapPropertiesView_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapPropertySet> return_value = self->obj.GetPropertiesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef BitmapPropertiesView_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)BitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)BitmapPropertiesView__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapPropertiesView_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapPropertiesView_dealloc },
    { Py_tp_new, BitmapPropertiesView_new },
    { Py_tp_methods, BitmapPropertiesView_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapPropertiesView_Type_spec =
{
    "BitmapPropertiesView",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPropertiesView_Type_slots
};

// ----- BitmapPropertySet class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type;


PyObject* BitmapPropertySet_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertySet instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void BitmapPropertySet_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapPropertySet__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapPropertySet>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapPropertySet_Clear(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_First(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_GetView(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue> return_value = self->obj.GetView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_HasKey(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            bool return_value = self->obj.HasKey(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_Insert(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(args, 1);

            bool return_value = self->obj.Insert(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_Lookup(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Graphics::Imaging::BitmapTypedValue return_value = self->obj.Lookup(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_Remove(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            self->obj.Remove(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* BitmapPropertySet_get_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapPropertySet_methods[] = {
    { "Clear", (PyCFunction)BitmapPropertySet_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)BitmapPropertySet_First, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)BitmapPropertySet_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)BitmapPropertySet_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)BitmapPropertySet_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)BitmapPropertySet_Lookup, METH_VARARGS, nullptr },
    { "Remove", (PyCFunction)BitmapPropertySet_Remove, METH_VARARGS, nullptr },
    { "get_Size", (PyCFunction)BitmapPropertySet_get_Size, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)BitmapPropertySet__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapPropertySet_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapPropertySet_dealloc },
    { Py_tp_new, BitmapPropertySet_new },
    { Py_tp_methods, BitmapPropertySet_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapPropertySet_Type_spec =
{
    "BitmapPropertySet",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapPropertySet>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPropertySet_Type_slots
};

// ----- BitmapTransform class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type;


PyObject* BitmapTransform_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapTransform instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void BitmapTransform_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapTransform__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapTransform>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapTransform>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapTransform_get_Bounds(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds return_value = self->obj.Bounds();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_get_Flip(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapFlip return_value = self->obj.Flip();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_get_InterpolationMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapInterpolationMode return_value = self->obj.InterpolationMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_get_Rotation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapRotation return_value = self->obj.Rotation();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_get_ScaledHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.ScaledHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_get_ScaledWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.ScaledWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_Bounds(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(args);

            self->obj.Bounds(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_Flip(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Graphics::Imaging::BitmapFlip>::convert_to(args);

            self->obj.Flip(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_InterpolationMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>::convert_to(args);

            self->obj.InterpolationMode(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_Rotation(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Graphics::Imaging::BitmapRotation>::convert_to(args);

            self->obj.Rotation(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_ScaledHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.ScaledHeight(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTransform_put_ScaledWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.ScaledWidth(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapTransform_methods[] = {
    { "get_Bounds", (PyCFunction)BitmapTransform_get_Bounds, METH_NOARGS, nullptr },
    { "get_Flip", (PyCFunction)BitmapTransform_get_Flip, METH_NOARGS, nullptr },
    { "get_InterpolationMode", (PyCFunction)BitmapTransform_get_InterpolationMode, METH_NOARGS, nullptr },
    { "get_Rotation", (PyCFunction)BitmapTransform_get_Rotation, METH_NOARGS, nullptr },
    { "get_ScaledHeight", (PyCFunction)BitmapTransform_get_ScaledHeight, METH_NOARGS, nullptr },
    { "get_ScaledWidth", (PyCFunction)BitmapTransform_get_ScaledWidth, METH_NOARGS, nullptr },
    { "put_Bounds", (PyCFunction)BitmapTransform_put_Bounds, METH_O, nullptr },
    { "put_Flip", (PyCFunction)BitmapTransform_put_Flip, METH_O, nullptr },
    { "put_InterpolationMode", (PyCFunction)BitmapTransform_put_InterpolationMode, METH_O, nullptr },
    { "put_Rotation", (PyCFunction)BitmapTransform_put_Rotation, METH_O, nullptr },
    { "put_ScaledHeight", (PyCFunction)BitmapTransform_put_ScaledHeight, METH_O, nullptr },
    { "put_ScaledWidth", (PyCFunction)BitmapTransform_put_ScaledWidth, METH_O, nullptr },
    { "_from", (PyCFunction)BitmapTransform__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapTransform_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapTransform_dealloc },
    { Py_tp_new, BitmapTransform_new },
    { Py_tp_methods, BitmapTransform_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapTransform_Type_spec =
{
    "BitmapTransform",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTransform>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapTransform_Type_slots
};

// ----- BitmapTypedValue class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type;


PyObject* BitmapTypedValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::PropertyType>(args, 1);
            winrt::Windows::Graphics::Imaging::BitmapTypedValue instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void BitmapTypedValue_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* BitmapTypedValue__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::convert(instance.as<winrt::Windows::Graphics::Imaging::BitmapTypedValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapTypedValue_get_Type(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::PropertyType return_value = self->obj.Type();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* BitmapTypedValue_get_Value(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IInspectable return_value = self->obj.Value();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef BitmapTypedValue_methods[] = {
    { "get_Type", (PyCFunction)BitmapTypedValue_get_Type, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)BitmapTypedValue_get_Value, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)BitmapTypedValue__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot BitmapTypedValue_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, BitmapTypedValue_dealloc },
    { Py_tp_new, BitmapTypedValue_new },
    { Py_tp_methods, BitmapTypedValue_methods },
    { 0, nullptr },
};

static PyType_Spec BitmapTypedValue_Type_spec =
{
    "BitmapTypedValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::BitmapTypedValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapTypedValue_Type_slots
};

// ----- ImageStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type;


PyObject* ImageStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageStream is not activatable");
    return nullptr;
}

static void ImageStream_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::ImageStream>::convert(instance.as<winrt::Windows::Graphics::Imaging::ImageStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageStream_CloneStream(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_Seek(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageStream_get_ContentType(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageStream_get_Position(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageStream_get_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageStream_put_Size(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ImageStream_methods[] = {
    { "CloneStream", (PyCFunction)ImageStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)ImageStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)ImageStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)ImageStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)ImageStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)ImageStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)ImageStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)ImageStream_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)ImageStream_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)ImageStream_get_CanWrite, METH_NOARGS, nullptr },
    { "get_ContentType", (PyCFunction)ImageStream_get_ContentType, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)ImageStream_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)ImageStream_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)ImageStream_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)ImageStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ImageStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ImageStream_dealloc },
    { Py_tp_new, ImageStream_new },
    { Py_tp_methods, ImageStream_methods },
    { 0, nullptr },
};

static PyType_Spec ImageStream_Type_spec =
{
    "ImageStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::ImageStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageStream_Type_slots
};

// ----- PixelDataProvider class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type;


PyObject* PixelDataProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PixelDataProvider is not activatable");
    return nullptr;
}

static void PixelDataProvider_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PixelDataProvider__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::PixelDataProvider>::convert(instance.as<winrt::Windows::Graphics::Imaging::PixelDataProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* PixelDataProvider_DetachPixelData(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        // returning a ReceiveArray not impl
        return nullptr;
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef PixelDataProvider_methods[] = {
    { "DetachPixelData", (PyCFunction)PixelDataProvider_DetachPixelData, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)PixelDataProvider__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot PixelDataProvider_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, PixelDataProvider_dealloc },
    { Py_tp_new, PixelDataProvider_new },
    { Py_tp_methods, PixelDataProvider_methods },
    { 0, nullptr },
};

static PyType_Spec PixelDataProvider_Type_spec =
{
    "PixelDataProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::PixelDataProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    PixelDataProvider_Type_slots
};

// ----- SoftwareBitmap class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type;


PyObject* SoftwareBitmap_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<int32_t>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);
            winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void SoftwareBitmap_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SoftwareBitmap__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::convert(instance.as<winrt::Windows::Graphics::Imaging::SoftwareBitmap>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SoftwareBitmap_Close(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_Convert(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);

            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 2);

            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_Copy(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::Copy(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyFromBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            self->obj.CopyFromBuffer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyTo(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

            self->obj.CopyTo(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_CopyToBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            self->obj.CopyToBuffer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_CreateCopyFromBuffer(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<int32_t>(args, 3);

            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
            auto param2 = py::convert_to<int32_t>(args, 2);
            auto param3 = py::convert_to<int32_t>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 4);

            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_CreateCopyFromSurfaceAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_GetReadOnlyView(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Graphics::Imaging::SoftwareBitmap return_value = self->obj.GetReadOnlyView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_LockBuffer(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>(args, 0);

            winrt::Windows::Graphics::Imaging::BitmapBuffer return_value = self->obj.LockBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* SoftwareBitmap_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiX();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiY();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_IsReadOnly(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsReadOnly();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            int32_t return_value = self->obj.PixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            int32_t return_value = self->obj.PixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_put_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<double>::convert_to(args);

            self->obj.DpiX(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SoftwareBitmap_put_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<double>::convert_to(args);

            self->obj.DpiY(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SoftwareBitmap_methods[] = {
    { "Close", (PyCFunction)SoftwareBitmap_Close, METH_VARARGS, nullptr },
    { "Convert", (PyCFunction)SoftwareBitmap_Convert, METH_VARARGS | METH_STATIC, nullptr },
    { "Copy", (PyCFunction)SoftwareBitmap_Copy, METH_VARARGS | METH_STATIC, nullptr },
    { "CopyFromBuffer", (PyCFunction)SoftwareBitmap_CopyFromBuffer, METH_VARARGS, nullptr },
    { "CopyTo", (PyCFunction)SoftwareBitmap_CopyTo, METH_VARARGS, nullptr },
    { "CopyToBuffer", (PyCFunction)SoftwareBitmap_CopyToBuffer, METH_VARARGS, nullptr },
    { "CreateCopyFromBuffer", (PyCFunction)SoftwareBitmap_CreateCopyFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateCopyFromSurfaceAsync", (PyCFunction)SoftwareBitmap_CreateCopyFromSurfaceAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetReadOnlyView", (PyCFunction)SoftwareBitmap_GetReadOnlyView, METH_VARARGS, nullptr },
    { "LockBuffer", (PyCFunction)SoftwareBitmap_LockBuffer, METH_VARARGS, nullptr },
    { "get_BitmapAlphaMode", (PyCFunction)SoftwareBitmap_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)SoftwareBitmap_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_DpiX", (PyCFunction)SoftwareBitmap_get_DpiX, METH_NOARGS, nullptr },
    { "get_DpiY", (PyCFunction)SoftwareBitmap_get_DpiY, METH_NOARGS, nullptr },
    { "get_IsReadOnly", (PyCFunction)SoftwareBitmap_get_IsReadOnly, METH_NOARGS, nullptr },
    { "get_PixelHeight", (PyCFunction)SoftwareBitmap_get_PixelHeight, METH_NOARGS, nullptr },
    { "get_PixelWidth", (PyCFunction)SoftwareBitmap_get_PixelWidth, METH_NOARGS, nullptr },
    { "put_DpiX", (PyCFunction)SoftwareBitmap_put_DpiX, METH_O, nullptr },
    { "put_DpiY", (PyCFunction)SoftwareBitmap_put_DpiY, METH_O, nullptr },
    { "_from", (PyCFunction)SoftwareBitmap__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SoftwareBitmap_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SoftwareBitmap_dealloc },
    { Py_tp_new, SoftwareBitmap_new },
    { Py_tp_methods, SoftwareBitmap_methods },
    { 0, nullptr },
};

static PyType_Spec SoftwareBitmap_Type_spec =
{
    "SoftwareBitmap",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::SoftwareBitmap>),
    0,
    Py_TPFLAGS_DEFAULT,
    SoftwareBitmap_Type_slots
};

// ----- IBitmapFrame interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type;


PyObject* IBitmapFrame_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapFrame interface is not activatable");
    return nullptr;
}

static void IBitmapFrame_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapFrame__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::IBitmapFrame>::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapFrame>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrame_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IBitmapFrame_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::ImageStream> return_value = self->obj.GetThumbnailAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IBitmapFrame_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertiesView return_value = self->obj.BitmapProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiX();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiY();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrame_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IBitmapFrame_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)IBitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IBitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_BitmapAlphaMode", (PyCFunction)IBitmapFrame_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)IBitmapFrame_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_BitmapProperties", (PyCFunction)IBitmapFrame_get_BitmapProperties, METH_NOARGS, nullptr },
    { "get_DpiX", (PyCFunction)IBitmapFrame_get_DpiX, METH_NOARGS, nullptr },
    { "get_DpiY", (PyCFunction)IBitmapFrame_get_DpiY, METH_NOARGS, nullptr },
    { "get_OrientedPixelHeight", (PyCFunction)IBitmapFrame_get_OrientedPixelHeight, METH_NOARGS, nullptr },
    { "get_OrientedPixelWidth", (PyCFunction)IBitmapFrame_get_OrientedPixelWidth, METH_NOARGS, nullptr },
    { "get_PixelHeight", (PyCFunction)IBitmapFrame_get_PixelHeight, METH_NOARGS, nullptr },
    { "get_PixelWidth", (PyCFunction)IBitmapFrame_get_PixelWidth, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IBitmapFrame__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IBitmapFrame_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IBitmapFrame_dealloc },
    { Py_tp_new, IBitmapFrame_new },
    { Py_tp_methods, IBitmapFrame_methods },
    { 0, nullptr },
};

static PyType_Spec IBitmapFrame_Type_spec =
{
    "IBitmapFrame",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrame>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapFrame_Type_slots
};

// ----- IBitmapFrameWithSoftwareBitmap interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type;


PyObject* IBitmapFrameWithSoftwareBitmap_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapFrameWithSoftwareBitmap interface is not activatable");
    return nullptr;
}

static void IBitmapFrameWithSoftwareBitmap_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::PixelDataProvider> return_value = self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::SoftwareBitmap> return_value = self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::ImageStream> return_value = self->obj.GetThumbnailAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapProperties(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPropertiesView return_value = self->obj.BitmapProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiX(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiX();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiY(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.DpiY();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.OrientedPixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelHeight();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.PixelWidth();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IBitmapFrameWithSoftwareBitmap_methods[] = {
    { "GetPixelDataAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync, METH_VARARGS, nullptr },
    { "GetSoftwareBitmapAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
    { "GetThumbnailAsync", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync, METH_VARARGS, nullptr },
    { "get_BitmapAlphaMode", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_BitmapProperties", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_BitmapProperties, METH_NOARGS, nullptr },
    { "get_DpiX", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_DpiX, METH_NOARGS, nullptr },
    { "get_DpiY", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_DpiY, METH_NOARGS, nullptr },
    { "get_OrientedPixelHeight", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight, METH_NOARGS, nullptr },
    { "get_OrientedPixelWidth", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth, METH_NOARGS, nullptr },
    { "get_PixelHeight", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_PixelHeight, METH_NOARGS, nullptr },
    { "get_PixelWidth", (PyCFunction)IBitmapFrameWithSoftwareBitmap_get_PixelWidth, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IBitmapFrameWithSoftwareBitmap__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IBitmapFrameWithSoftwareBitmap_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IBitmapFrameWithSoftwareBitmap_dealloc },
    { Py_tp_new, IBitmapFrameWithSoftwareBitmap_new },
    { Py_tp_methods, IBitmapFrameWithSoftwareBitmap_methods },
    { 0, nullptr },
};

static PyType_Spec IBitmapFrameWithSoftwareBitmap_Type_spec =
{
    "IBitmapFrameWithSoftwareBitmap",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapFrameWithSoftwareBitmap_Type_slots
};

// ----- IBitmapPropertiesView interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type;


PyObject* IBitmapPropertiesView_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBitmapPropertiesView interface is not activatable");
    return nullptr;
}

static void IBitmapPropertiesView_dealloc(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBitmapPropertiesView__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::convert(instance.as<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBitmapPropertiesView_GetPropertiesAsync(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Graphics::Imaging::BitmapPropertySet> return_value = self->obj.GetPropertiesAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IBitmapPropertiesView_methods[] = {
    { "GetPropertiesAsync", (PyCFunction)IBitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IBitmapPropertiesView__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IBitmapPropertiesView_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IBitmapPropertiesView_dealloc },
    { Py_tp_new, IBitmapPropertiesView_new },
    { Py_tp_methods, IBitmapPropertiesView_methods },
    { 0, nullptr },
};

static PyType_Spec IBitmapPropertiesView_Type_spec =
{
    "IBitmapPropertiesView",
    sizeof(py::winrt_wrapper<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBitmapPropertiesView_Type_slots
};

// ----- BitmapBounds struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert(winrt::Windows::Graphics::Imaging::BitmapBounds instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapBounds>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>());
}

winrt::Windows::Graphics::Imaging::BitmapBounds py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapBounds new_value{};
    PyObject* pyX = PyDict_GetItemString(obj, "X");
    if (!pyX) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<uint32_t>::convert_to(pyX);
    PyObject* pyY = PyDict_GetItemString(obj, "Y");
    if (!pyY) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<uint32_t>::convert_to(pyY);
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<uint32_t>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<uint32_t>::convert_to(pyHeight);
    return new_value;
}

PyObject* BitmapBounds_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    uint32_t _X{};
    uint32_t _Y{};
    uint32_t _Width{};
    uint32_t _Height{};
    static char* kwlist[] = {"X", "Y", "Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", kwlist, &_X, &_Y, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapBounds instance{ _X, _Y, _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapBounds_get_X(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.X)>::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_X(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Y(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Y)>::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Y(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Width)>::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapBounds_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Height)>::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapBounds_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapBounds_getset[] = {
    { const_cast<char*>("X"), (getter)BitmapBounds_get_X, (setter)BitmapBounds_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)BitmapBounds_get_Y, (setter)BitmapBounds_set_Y, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)BitmapBounds_get_Width, (setter)BitmapBounds_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapBounds_get_Height, (setter)BitmapBounds_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapBounds_Type_slots[] = 
{
    { Py_tp_new, BitmapBounds_new },
    { Py_tp_getset, BitmapBounds_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapBounds_Type_spec =
{
    "BitmapBounds",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapBounds_Type_slots
};

// ----- BitmapPlaneDescription struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert(winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>());
}

winrt::Windows::Graphics::Imaging::BitmapPlaneDescription py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapPlaneDescription new_value{};
    PyObject* pyStartIndex = PyDict_GetItemString(obj, "StartIndex");
    if (!pyStartIndex) { throw winrt::hresult_invalid_argument(); }
    new_value.StartIndex = converter<int32_t>::convert_to(pyStartIndex);
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<int32_t>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<int32_t>::convert_to(pyHeight);
    PyObject* pyStride = PyDict_GetItemString(obj, "Stride");
    if (!pyStride) { throw winrt::hresult_invalid_argument(); }
    new_value.Stride = converter<int32_t>::convert_to(pyStride);
    return new_value;
}

PyObject* BitmapPlaneDescription_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int32_t _StartIndex{};
    int32_t _Width{};
    int32_t _Height{};
    int32_t _Stride{};
    static char* kwlist[] = {"StartIndex", "Width", "Height", "Stride", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", kwlist, &_StartIndex, &_Width, &_Height, &_Stride))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance{ _StartIndex, _Width, _Height, _Stride };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapPlaneDescription_get_StartIndex(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.StartIndex)>::convert(self->obj.StartIndex);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_StartIndex(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.StartIndex = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Width)>::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Height)>::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapPlaneDescription_get_Stride(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Stride)>::convert(self->obj.Stride);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapPlaneDescription_set_Stride(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Stride = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapPlaneDescription_getset[] = {
    { const_cast<char*>("StartIndex"), (getter)BitmapPlaneDescription_get_StartIndex, (setter)BitmapPlaneDescription_set_StartIndex, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)BitmapPlaneDescription_get_Width, (setter)BitmapPlaneDescription_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapPlaneDescription_get_Height, (setter)BitmapPlaneDescription_set_Height, nullptr, nullptr },
    { const_cast<char*>("Stride"), (getter)BitmapPlaneDescription_get_Stride, (setter)BitmapPlaneDescription_set_Stride, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapPlaneDescription_Type_slots[] = 
{
    { Py_tp_new, BitmapPlaneDescription_new },
    { Py_tp_getset, BitmapPlaneDescription_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapPlaneDescription_Type_spec =
{
    "BitmapPlaneDescription",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapPlaneDescription_Type_slots
};

// ----- BitmapSize struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert(winrt::Windows::Graphics::Imaging::BitmapSize instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Graphics::Imaging::BitmapSize>(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>());
}

winrt::Windows::Graphics::Imaging::BitmapSize py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Graphics::Imaging::BitmapSize new_value{};
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<uint32_t>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<uint32_t>::convert_to(pyHeight);
    return new_value;
}

PyObject* BitmapSize_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapSize instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    uint32_t _Width{};
    uint32_t _Height{};
    static char* kwlist[] = {"Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", kwlist, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Graphics::Imaging::BitmapSize instance{ _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BitmapSize_get_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Width)>::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapSize_set_Width(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BitmapSize_get_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Height)>::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BitmapSize_set_Height(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BitmapSize_getset[] = {
    { const_cast<char*>("Width"), (getter)BitmapSize_get_Width, (setter)BitmapSize_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)BitmapSize_get_Height, (setter)BitmapSize_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BitmapSize_Type_slots[] = 
{
    { Py_tp_new, BitmapSize_new },
    { Py_tp_getset, BitmapSize_getset },
    { 0, nullptr },
};

static PyType_Spec BitmapSize_Type_spec =
{
    "BitmapSize",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>),
    0,
    Py_TPFLAGS_DEFAULT,
    BitmapSize_Type_slots
};

// ----- Windows.Graphics.Imaging Initialization --------------------

int initialize_Windows_Graphics_Imaging(PyObject* module)
{
    PyObject* type_object{ nullptr };


    BitmapBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapCodecInformation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapCodecInformation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapCodecInformation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapDecoder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapDecoder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapDecoder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapEncoder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapEncoder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapEncoder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapFrame_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapFrame_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapFrame", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapProperties_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapProperties_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapProperties", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapPropertiesView_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapPropertiesView_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPropertiesView", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapPropertySet_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapPropertySet_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPropertySet", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapTransform_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapTransform_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapTransform", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    BitmapTypedValue_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&BitmapTypedValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapTypedValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ImageStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ImageStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    PixelDataProvider_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&PixelDataProvider_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PixelDataProvider", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SoftwareBitmap_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SoftwareBitmap_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SoftwareBitmap", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IBitmapFrame_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IBitmapFrame_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapFrame", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IBitmapFrameWithSoftwareBitmap_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IBitmapFrameWithSoftwareBitmap_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapFrameWithSoftwareBitmap", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IBitmapPropertiesView_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IBitmapPropertiesView_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBitmapPropertiesView", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&BitmapBounds_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapBounds", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&BitmapPlaneDescription_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapPlaneDescription", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&BitmapSize_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BitmapSize", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
