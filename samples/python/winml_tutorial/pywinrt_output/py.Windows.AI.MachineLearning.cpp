// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.AI.MachineLearning.h"

// ----- ImageFeatureDescriptor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type;


PyObject* ImageFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageFeatureDescriptor is not activatable");
    return nullptr;
}

static void ImageFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageFeatureDescriptor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::convert(instance.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapAlphaMode return_value = self->obj.BitmapAlphaMode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPixelFormat return_value = self->obj.BitmapPixelFormat();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_Height(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Height();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsRequired();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureDescriptor_get_Width(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Width();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ImageFeatureDescriptor_methods[] = {
    { "get_BitmapAlphaMode", (PyCFunction)ImageFeatureDescriptor_get_BitmapAlphaMode, METH_NOARGS, nullptr },
    { "get_BitmapPixelFormat", (PyCFunction)ImageFeatureDescriptor_get_BitmapPixelFormat, METH_NOARGS, nullptr },
    { "get_Description", (PyCFunction)ImageFeatureDescriptor_get_Description, METH_NOARGS, nullptr },
    { "get_Height", (PyCFunction)ImageFeatureDescriptor_get_Height, METH_NOARGS, nullptr },
    { "get_IsRequired", (PyCFunction)ImageFeatureDescriptor_get_IsRequired, METH_NOARGS, nullptr },
    { "get_Kind", (PyCFunction)ImageFeatureDescriptor_get_Kind, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)ImageFeatureDescriptor_get_Name, METH_NOARGS, nullptr },
    { "get_Width", (PyCFunction)ImageFeatureDescriptor_get_Width, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ImageFeatureDescriptor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ImageFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ImageFeatureDescriptor_dealloc },
    { Py_tp_new, ImageFeatureDescriptor_new },
    { Py_tp_methods, ImageFeatureDescriptor_methods },
    { 0, nullptr },
};

static PyType_Spec ImageFeatureDescriptor_Type_spec =
{
    "ImageFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageFeatureDescriptor_Type_slots
};

// ----- ImageFeatureValue class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type;


PyObject* ImageFeatureValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ImageFeatureValue is not activatable");
    return nullptr;
}

static void ImageFeatureValue_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ImageFeatureValue__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::convert(instance.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

            winrt::Windows::AI::MachineLearning::ImageFeatureValue return_value = winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* ImageFeatureValue_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ImageFeatureValue_get_VideoFrame(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Media::VideoFrame return_value = self->obj.VideoFrame();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ImageFeatureValue_methods[] = {
    { "CreateFromVideoFrame", (PyCFunction)ImageFeatureValue_CreateFromVideoFrame, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Kind", (PyCFunction)ImageFeatureValue_get_Kind, METH_NOARGS, nullptr },
    { "get_VideoFrame", (PyCFunction)ImageFeatureValue_get_VideoFrame, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ImageFeatureValue__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ImageFeatureValue_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ImageFeatureValue_dealloc },
    { Py_tp_new, ImageFeatureValue_new },
    { Py_tp_methods, ImageFeatureValue_methods },
    { 0, nullptr },
};

static PyType_Spec ImageFeatureValue_Type_spec =
{
    "ImageFeatureValue",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ImageFeatureValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ImageFeatureValue_Type_slots
};

// ----- LearningModel class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type;


PyObject* LearningModel_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "LearningModel is not activatable");
    return nullptr;
}

static void LearningModel_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModel__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::LearningModel>::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModel>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModel_Close(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::AI::MachineLearning::LearningModel return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

            winrt::Windows::AI::MachineLearning::LearningModel return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModel> return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModel> return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

            winrt::Windows::AI::MachineLearning::LearningModel return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

            winrt::Windows::AI::MachineLearning::LearningModel return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModel> return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModel> return_value = winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModel_get_Author(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Author();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_Domain(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Domain();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_InputFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor> return_value = self->obj.InputFeatures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_Metadata(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::hstring> return_value = self->obj.Metadata();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_OutputFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor> return_value = self->obj.OutputFeatures();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModel_get_Version(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            int64_t return_value = self->obj.Version();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef LearningModel_methods[] = {
    { "Close", (PyCFunction)LearningModel_Close, METH_VARARGS, nullptr },
    { "LoadFromFilePath", (PyCFunction)LearningModel_LoadFromFilePath, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStorageFileAsync", (PyCFunction)LearningModel_LoadFromStorageFileAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStream", (PyCFunction)LearningModel_LoadFromStream, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadFromStreamAsync", (PyCFunction)LearningModel_LoadFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Author", (PyCFunction)LearningModel_get_Author, METH_NOARGS, nullptr },
    { "get_Description", (PyCFunction)LearningModel_get_Description, METH_NOARGS, nullptr },
    { "get_Domain", (PyCFunction)LearningModel_get_Domain, METH_NOARGS, nullptr },
    { "get_InputFeatures", (PyCFunction)LearningModel_get_InputFeatures, METH_NOARGS, nullptr },
    { "get_Metadata", (PyCFunction)LearningModel_get_Metadata, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)LearningModel_get_Name, METH_NOARGS, nullptr },
    { "get_OutputFeatures", (PyCFunction)LearningModel_get_OutputFeatures, METH_NOARGS, nullptr },
    { "get_Version", (PyCFunction)LearningModel_get_Version, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)LearningModel__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot LearningModel_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, LearningModel_dealloc },
    { Py_tp_new, LearningModel_new },
    { Py_tp_methods, LearningModel_methods },
    { 0, nullptr },
};

static PyType_Spec LearningModel_Type_spec =
{
    "LearningModel",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModel>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModel_Type_slots
};

// ----- LearningModelBinding class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type;


PyObject* LearningModelBinding_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);
            winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void LearningModelBinding_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelBinding__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::LearningModelBinding>::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelBinding_Bind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

            self->obj.Bind(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

            self->obj.Bind(param0, param1, param2);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_Clear(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_First(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_HasKey(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            bool return_value = self->obj.HasKey(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_Lookup(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.Lookup(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_Split(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };

            self->obj.Split(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelBinding_get_Size(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef LearningModelBinding_methods[] = {
    { "Bind", (PyCFunction)LearningModelBinding_Bind, METH_VARARGS, nullptr },
    { "Clear", (PyCFunction)LearningModelBinding_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)LearningModelBinding_First, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)LearningModelBinding_HasKey, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)LearningModelBinding_Lookup, METH_VARARGS, nullptr },
    { "Split", (PyCFunction)LearningModelBinding_Split, METH_VARARGS, nullptr },
    { "get_Size", (PyCFunction)LearningModelBinding_get_Size, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)LearningModelBinding__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelBinding_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, LearningModelBinding_dealloc },
    { Py_tp_new, LearningModelBinding_new },
    { Py_tp_methods, LearningModelBinding_methods },
    { 0, nullptr },
};

static PyType_Spec LearningModelBinding_Type_spec =
{
    "LearningModelBinding",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelBinding>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelBinding_Type_slots
};

// ----- LearningModelDevice class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type;


PyObject* LearningModelDevice_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);
            winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void LearningModelDevice_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelDevice__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::LearningModelDevice>::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);

            winrt::Windows::AI::MachineLearning::LearningModelDevice return_value = winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelDevice_get_AdapterId(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::DisplayAdapterId return_value = self->obj.AdapterId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelDevice_get_Direct3D11Device(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice return_value = self->obj.Direct3D11Device();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef LearningModelDevice_methods[] = {
    { "CreateFromDirect3D11Device", (PyCFunction)LearningModelDevice_CreateFromDirect3D11Device, METH_VARARGS | METH_STATIC, nullptr },
    { "get_AdapterId", (PyCFunction)LearningModelDevice_get_AdapterId, METH_NOARGS, nullptr },
    { "get_Direct3D11Device", (PyCFunction)LearningModelDevice_get_Direct3D11Device, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)LearningModelDevice__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelDevice_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, LearningModelDevice_dealloc },
    { Py_tp_new, LearningModelDevice_new },
    { Py_tp_methods, LearningModelDevice_methods },
    { 0, nullptr },
};

static PyType_Spec LearningModelDevice_Type_spec =
{
    "LearningModelDevice",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelDevice>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelDevice_Type_slots
};

// ----- LearningModelEvaluationResult class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type;


PyObject* LearningModelEvaluationResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "LearningModelEvaluationResult is not activatable");
    return nullptr;
}

static void LearningModelEvaluationResult_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelEvaluationResult__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.CorrelationId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            int32_t return_value = self->obj.ErrorStatus();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelEvaluationResult_get_Outputs(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> return_value = self->obj.Outputs();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelEvaluationResult_get_Succeeded(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.Succeeded();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef LearningModelEvaluationResult_methods[] = {
    { "get_CorrelationId", (PyCFunction)LearningModelEvaluationResult_get_CorrelationId, METH_NOARGS, nullptr },
    { "get_ErrorStatus", (PyCFunction)LearningModelEvaluationResult_get_ErrorStatus, METH_NOARGS, nullptr },
    { "get_Outputs", (PyCFunction)LearningModelEvaluationResult_get_Outputs, METH_NOARGS, nullptr },
    { "get_Succeeded", (PyCFunction)LearningModelEvaluationResult_get_Succeeded, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)LearningModelEvaluationResult__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelEvaluationResult_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, LearningModelEvaluationResult_dealloc },
    { Py_tp_new, LearningModelEvaluationResult_new },
    { Py_tp_methods, LearningModelEvaluationResult_methods },
    { 0, nullptr },
};

static PyType_Spec LearningModelEvaluationResult_Type_spec =
{
    "LearningModelEvaluationResult",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelEvaluationResult_Type_slots
};

// ----- LearningModelSession class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type;


PyObject* LearningModelSession_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
            winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
            winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void LearningModelSession_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* LearningModelSession__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::LearningModelSession>::convert(instance.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* LearningModelSession_Close(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelSession_Evaluate(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult return_value = self->obj.Evaluate(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateAsync(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult> return_value = self->obj.EvaluateAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateFeatures(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult return_value = self->obj.EvaluateFeatures(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult> return_value = self->obj.EvaluateFeaturesAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* LearningModelSession_get_Device(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelDevice return_value = self->obj.Device();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelSession_get_EvaluationProperties(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IPropertySet return_value = self->obj.EvaluationProperties();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* LearningModelSession_get_Model(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModel return_value = self->obj.Model();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef LearningModelSession_methods[] = {
    { "Close", (PyCFunction)LearningModelSession_Close, METH_VARARGS, nullptr },
    { "Evaluate", (PyCFunction)LearningModelSession_Evaluate, METH_VARARGS, nullptr },
    { "EvaluateAsync", (PyCFunction)LearningModelSession_EvaluateAsync, METH_VARARGS, nullptr },
    { "EvaluateFeatures", (PyCFunction)LearningModelSession_EvaluateFeatures, METH_VARARGS, nullptr },
    { "EvaluateFeaturesAsync", (PyCFunction)LearningModelSession_EvaluateFeaturesAsync, METH_VARARGS, nullptr },
    { "get_Device", (PyCFunction)LearningModelSession_get_Device, METH_NOARGS, nullptr },
    { "get_EvaluationProperties", (PyCFunction)LearningModelSession_get_EvaluationProperties, METH_NOARGS, nullptr },
    { "get_Model", (PyCFunction)LearningModelSession_get_Model, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)LearningModelSession__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot LearningModelSession_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, LearningModelSession_dealloc },
    { Py_tp_new, LearningModelSession_new },
    { Py_tp_methods, LearningModelSession_methods },
    { 0, nullptr },
};

static PyType_Spec LearningModelSession_Type_spec =
{
    "LearningModelSession",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::LearningModelSession>),
    0,
    Py_TPFLAGS_DEFAULT,
    LearningModelSession_Type_slots
};

// ----- MapFeatureDescriptor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type;


PyObject* MapFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "MapFeatureDescriptor is not activatable");
    return nullptr;
}

static void MapFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MapFeatureDescriptor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::convert(instance.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MapFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* MapFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsRequired();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* MapFeatureDescriptor_get_KeyKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.KeyKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* MapFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* MapFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor return_value = self->obj.ValueDescriptor();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef MapFeatureDescriptor_methods[] = {
    { "get_Description", (PyCFunction)MapFeatureDescriptor_get_Description, METH_NOARGS, nullptr },
    { "get_IsRequired", (PyCFunction)MapFeatureDescriptor_get_IsRequired, METH_NOARGS, nullptr },
    { "get_KeyKind", (PyCFunction)MapFeatureDescriptor_get_KeyKind, METH_NOARGS, nullptr },
    { "get_Kind", (PyCFunction)MapFeatureDescriptor_get_Kind, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)MapFeatureDescriptor_get_Name, METH_NOARGS, nullptr },
    { "get_ValueDescriptor", (PyCFunction)MapFeatureDescriptor_get_ValueDescriptor, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)MapFeatureDescriptor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot MapFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, MapFeatureDescriptor_dealloc },
    { Py_tp_new, MapFeatureDescriptor_new },
    { Py_tp_methods, MapFeatureDescriptor_methods },
    { 0, nullptr },
};

static PyType_Spec MapFeatureDescriptor_Type_spec =
{
    "MapFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    MapFeatureDescriptor_Type_slots
};

// ----- SequenceFeatureDescriptor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type;


PyObject* SequenceFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "SequenceFeatureDescriptor is not activatable");
    return nullptr;
}

static void SequenceFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* SequenceFeatureDescriptor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::convert(instance.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* SequenceFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor return_value = self->obj.ElementDescriptor();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsRequired();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SequenceFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* SequenceFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef SequenceFeatureDescriptor_methods[] = {
    { "get_Description", (PyCFunction)SequenceFeatureDescriptor_get_Description, METH_NOARGS, nullptr },
    { "get_ElementDescriptor", (PyCFunction)SequenceFeatureDescriptor_get_ElementDescriptor, METH_NOARGS, nullptr },
    { "get_IsRequired", (PyCFunction)SequenceFeatureDescriptor_get_IsRequired, METH_NOARGS, nullptr },
    { "get_Kind", (PyCFunction)SequenceFeatureDescriptor_get_Kind, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)SequenceFeatureDescriptor_get_Name, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)SequenceFeatureDescriptor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot SequenceFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, SequenceFeatureDescriptor_dealloc },
    { Py_tp_new, SequenceFeatureDescriptor_new },
    { Py_tp_methods, SequenceFeatureDescriptor_methods },
    { 0, nullptr },
};

static PyType_Spec SequenceFeatureDescriptor_Type_spec =
{
    "SequenceFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    SequenceFeatureDescriptor_Type_slots
};

// ----- TensorBoolean class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type;


PyObject* TensorBoolean_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorBoolean is not activatable");
    return nullptr;
}

static void TensorBoolean_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorBoolean__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorBoolean>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorBoolean return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorBoolean return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<bool const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorBoolean return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorBoolean return_value = winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorBoolean_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<bool> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorBoolean_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorBoolean_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorBoolean_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorBoolean_methods[] = {
    { "Create", (PyCFunction)TensorBoolean_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorBoolean_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorBoolean_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorBoolean_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorBoolean_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorBoolean_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorBoolean_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorBoolean__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorBoolean_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorBoolean_dealloc },
    { Py_tp_new, TensorBoolean_new },
    { Py_tp_methods, TensorBoolean_methods },
    { 0, nullptr },
};

static PyType_Spec TensorBoolean_Type_spec =
{
    "TensorBoolean",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorBoolean>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorBoolean_Type_slots
};

// ----- TensorDouble class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type;


PyObject* TensorDouble_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorDouble is not activatable");
    return nullptr;
}

static void TensorDouble_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorDouble__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorDouble>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorDouble return_value = winrt::Windows::AI::MachineLearning::TensorDouble::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorDouble return_value = winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<double const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorDouble return_value = winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorDouble return_value = winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorDouble_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<double> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorDouble_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorDouble_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorDouble_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorDouble_methods[] = {
    { "Create", (PyCFunction)TensorDouble_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorDouble_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorDouble_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorDouble_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorDouble_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorDouble_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorDouble_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorDouble__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorDouble_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorDouble_dealloc },
    { Py_tp_new, TensorDouble_new },
    { Py_tp_methods, TensorDouble_methods },
    { 0, nullptr },
};

static PyType_Spec TensorDouble_Type_spec =
{
    "TensorDouble",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorDouble>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorDouble_Type_slots
};

// ----- TensorFeatureDescriptor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type;


PyObject* TensorFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFeatureDescriptor is not activatable");
    return nullptr;
}

static void TensorFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFeatureDescriptor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsRequired();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFeatureDescriptor_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFeatureDescriptor_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorFeatureDescriptor_methods[] = {
    { "get_Description", (PyCFunction)TensorFeatureDescriptor_get_Description, METH_NOARGS, nullptr },
    { "get_IsRequired", (PyCFunction)TensorFeatureDescriptor_get_IsRequired, METH_NOARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorFeatureDescriptor_get_Kind, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)TensorFeatureDescriptor_get_Name, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorFeatureDescriptor_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorFeatureDescriptor_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorFeatureDescriptor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorFeatureDescriptor_dealloc },
    { Py_tp_new, TensorFeatureDescriptor_new },
    { Py_tp_methods, TensorFeatureDescriptor_methods },
    { 0, nullptr },
};

static PyType_Spec TensorFeatureDescriptor_Type_spec =
{
    "TensorFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFeatureDescriptor_Type_slots
};

// ----- TensorFloat class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type;


PyObject* TensorFloat_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFloat is not activatable");
    return nullptr;
}

static void TensorFloat_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFloat__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorFloat>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorFloat return_value = winrt::Windows::AI::MachineLearning::TensorFloat::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorFloat return_value = winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<float const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorFloat return_value = winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorFloat return_value = winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<float> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFloat_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFloat_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorFloat_methods[] = {
    { "Create", (PyCFunction)TensorFloat_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorFloat_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorFloat_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorFloat_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorFloat_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorFloat_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorFloat_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorFloat__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorFloat_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorFloat_dealloc },
    { Py_tp_new, TensorFloat_new },
    { Py_tp_methods, TensorFloat_methods },
    { 0, nullptr },
};

static PyType_Spec TensorFloat_Type_spec =
{
    "TensorFloat",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFloat_Type_slots
};

// ----- TensorFloat16Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type;


PyObject* TensorFloat16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorFloat16Bit is not activatable");
    return nullptr;
}

static void TensorFloat16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorFloat16Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorFloat16Bit return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorFloat16Bit return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<float const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorFloat16Bit return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorFloat16Bit return_value = winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<float> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorFloat16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFloat16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorFloat16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorFloat16Bit_methods[] = {
    { "Create", (PyCFunction)TensorFloat16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorFloat16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorFloat16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorFloat16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorFloat16Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorFloat16Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorFloat16Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorFloat16Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorFloat16Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorFloat16Bit_dealloc },
    { Py_tp_new, TensorFloat16Bit_new },
    { Py_tp_methods, TensorFloat16Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorFloat16Bit_Type_spec =
{
    "TensorFloat16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorFloat16Bit_Type_slots
};

// ----- TensorInt16Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type;


PyObject* TensorInt16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt16Bit is not activatable");
    return nullptr;
}

static void TensorInt16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt16Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<int16_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int16_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorInt16Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorInt16Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorInt16Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorInt16Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorInt16Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt16Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorInt16Bit_dealloc },
    { Py_tp_new, TensorInt16Bit_new },
    { Py_tp_methods, TensorInt16Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorInt16Bit_Type_spec =
{
    "TensorInt16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt16Bit_Type_slots
};

// ----- TensorInt32Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type;


PyObject* TensorInt32Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt32Bit is not activatable");
    return nullptr;
}

static void TensorInt32Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt32Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<int32_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt32Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int32_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt32Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt32Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt32Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorInt32Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorInt32Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorInt32Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorInt32Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorInt32Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt32Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorInt32Bit_dealloc },
    { Py_tp_new, TensorInt32Bit_new },
    { Py_tp_methods, TensorInt32Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorInt32Bit_Type_spec =
{
    "TensorInt32Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt32Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt32Bit_Type_slots
};

// ----- TensorInt64Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type;


PyObject* TensorInt64Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt64Bit is not activatable");
    return nullptr;
}

static void TensorInt64Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt64Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<int64_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt64Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt64Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt64Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt64Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorInt64Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorInt64Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorInt64Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorInt64Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorInt64Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt64Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorInt64Bit_dealloc },
    { Py_tp_new, TensorInt64Bit_new },
    { Py_tp_methods, TensorInt64Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorInt64Bit_Type_spec =
{
    "TensorInt64Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt64Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt64Bit_Type_slots
};

// ----- TensorInt8Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type;


PyObject* TensorInt8Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorInt8Bit is not activatable");
    return nullptr;
}

static void TensorInt8Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorInt8Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<uint8_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt8Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<uint8_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorInt8Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt8Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorInt8Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorInt8Bit_methods[] = {
    { "Create", (PyCFunction)TensorInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorInt8Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorInt8Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorInt8Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorInt8Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorInt8Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorInt8Bit_dealloc },
    { Py_tp_new, TensorInt8Bit_new },
    { Py_tp_methods, TensorInt8Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorInt8Bit_Type_spec =
{
    "TensorInt8Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorInt8Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorInt8Bit_Type_slots
};

// ----- TensorString class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type;


PyObject* TensorString_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorString is not activatable");
    return nullptr;
}

static void TensorString_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorString__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorString>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorString>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorString return_value = winrt::Windows::AI::MachineLearning::TensorString::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorString return_value = winrt::Windows::AI::MachineLearning::TensorString::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<winrt::hstring const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorString return_value = winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorString return_value = winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorString_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorString_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorString_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorString_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorString_methods[] = {
    { "Create", (PyCFunction)TensorString_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorString_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorString_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorString_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorString_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorString_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorString_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorString__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorString_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorString_dealloc },
    { Py_tp_new, TensorString_new },
    { Py_tp_methods, TensorString_methods },
    { 0, nullptr },
};

static PyType_Spec TensorString_Type_spec =
{
    "TensorString",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorString>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorString_Type_slots
};

// ----- TensorUInt16Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type;


PyObject* TensorUInt16Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt16Bit is not activatable");
    return nullptr;
}

static void TensorUInt16Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt16Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorUInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorUInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<uint16_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorUInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorUInt16Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt16Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<uint16_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt16Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt16Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt16Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorUInt16Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorUInt16Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorUInt16Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorUInt16Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorUInt16Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt16Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorUInt16Bit_dealloc },
    { Py_tp_new, TensorUInt16Bit_new },
    { Py_tp_methods, TensorUInt16Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorUInt16Bit_Type_spec =
{
    "TensorUInt16Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt16Bit_Type_slots
};

// ----- TensorUInt32Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type;


PyObject* TensorUInt32Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt32Bit is not activatable");
    return nullptr;
}

static void TensorUInt32Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt32Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorUInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorUInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<uint32_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorUInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorUInt32Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt32Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<uint32_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt32Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt32Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt32Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorUInt32Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorUInt32Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorUInt32Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorUInt32Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorUInt32Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt32Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorUInt32Bit_dealloc },
    { Py_tp_new, TensorUInt32Bit_new },
    { Py_tp_methods, TensorUInt32Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorUInt32Bit_Type_spec =
{
    "TensorUInt32Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt32Bit_Type_slots
};

// ----- TensorUInt64Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type;


PyObject* TensorUInt64Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt64Bit is not activatable");
    return nullptr;
}

static void TensorUInt64Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt64Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorUInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorUInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<uint64_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorUInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorUInt64Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt64Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<uint64_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt64Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt64Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt64Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorUInt64Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorUInt64Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorUInt64Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorUInt64Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorUInt64Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt64Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorUInt64Bit_dealloc },
    { Py_tp_new, TensorUInt64Bit_new },
    { Py_tp_methods, TensorUInt64Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorUInt64Bit_Type_spec =
{
    "TensorUInt64Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt64Bit_Type_slots
};

// ----- TensorUInt8Bit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type;


PyObject* TensorUInt8Bit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "TensorUInt8Bit is not activatable");
    return nullptr;
}

static void TensorUInt8Bit_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* TensorUInt8Bit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::convert(instance.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::AI::MachineLearning::TensorUInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

            winrt::Windows::AI::MachineLearning::TensorUInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            /*p*/ winrt::array_view<uint8_t const> param1 { }; // TODO: Convert incoming python parameter

            winrt::Windows::AI::MachineLearning::TensorUInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

            winrt::Windows::AI::MachineLearning::TensorUInt8Bit return_value = winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt8Bit_GetAsVectorView(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<uint8_t> return_value = self->obj.GetAsVectorView();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* TensorUInt8Bit_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt8Bit_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* TensorUInt8Bit_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef TensorUInt8Bit_methods[] = {
    { "Create", (PyCFunction)TensorUInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromArray", (PyCFunction)TensorUInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromIterable", (PyCFunction)TensorUInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
    { "GetAsVectorView", (PyCFunction)TensorUInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
    { "get_Kind", (PyCFunction)TensorUInt8Bit_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)TensorUInt8Bit_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)TensorUInt8Bit_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)TensorUInt8Bit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot TensorUInt8Bit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, TensorUInt8Bit_dealloc },
    { Py_tp_new, TensorUInt8Bit_new },
    { Py_tp_methods, TensorUInt8Bit_methods },
    { 0, nullptr },
};

static PyType_Spec TensorUInt8Bit_Type_spec =
{
    "TensorUInt8Bit",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>),
    0,
    Py_TPFLAGS_DEFAULT,
    TensorUInt8Bit_Type_slots
};

// ----- ILearningModelFeatureDescriptor interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type;


PyObject* ILearningModelFeatureDescriptor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelFeatureDescriptor interface is not activatable");
    return nullptr;
}

static void ILearningModelFeatureDescriptor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ILearningModelFeatureDescriptor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ILearningModelFeatureDescriptor_get_Description(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Description();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsRequired();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ILearningModelFeatureDescriptor_get_Name(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ILearningModelFeatureDescriptor_methods[] = {
    { "get_Description", (PyCFunction)ILearningModelFeatureDescriptor_get_Description, METH_NOARGS, nullptr },
    { "get_IsRequired", (PyCFunction)ILearningModelFeatureDescriptor_get_IsRequired, METH_NOARGS, nullptr },
    { "get_Kind", (PyCFunction)ILearningModelFeatureDescriptor_get_Kind, METH_NOARGS, nullptr },
    { "get_Name", (PyCFunction)ILearningModelFeatureDescriptor_get_Name, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ILearningModelFeatureDescriptor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ILearningModelFeatureDescriptor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ILearningModelFeatureDescriptor_dealloc },
    { Py_tp_new, ILearningModelFeatureDescriptor_new },
    { Py_tp_methods, ILearningModelFeatureDescriptor_methods },
    { 0, nullptr },
};

static PyType_Spec ILearningModelFeatureDescriptor_Type_spec =
{
    "ILearningModelFeatureDescriptor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelFeatureDescriptor_Type_slots
};

// ----- ILearningModelFeatureValue interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type;


PyObject* ILearningModelFeatureValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelFeatureValue interface is not activatable");
    return nullptr;
}

static void ILearningModelFeatureValue_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ILearningModelFeatureValue__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ILearningModelFeatureValue_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ILearningModelFeatureValue_methods[] = {
    { "get_Kind", (PyCFunction)ILearningModelFeatureValue_get_Kind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ILearningModelFeatureValue__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ILearningModelFeatureValue_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ILearningModelFeatureValue_dealloc },
    { Py_tp_new, ILearningModelFeatureValue_new },
    { Py_tp_methods, ILearningModelFeatureValue_methods },
    { 0, nullptr },
};

static PyType_Spec ILearningModelFeatureValue_Type_spec =
{
    "ILearningModelFeatureValue",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelFeatureValue_Type_slots
};

// ----- ILearningModelOperatorProvider interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type;


PyObject* ILearningModelOperatorProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ILearningModelOperatorProvider interface is not activatable");
    return nullptr;
}

static void ILearningModelOperatorProvider_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ILearningModelOperatorProvider__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::convert(instance.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef ILearningModelOperatorProvider_methods[] = {
    { "_from", (PyCFunction)ILearningModelOperatorProvider__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ILearningModelOperatorProvider_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ILearningModelOperatorProvider_dealloc },
    { Py_tp_new, ILearningModelOperatorProvider_new },
    { Py_tp_methods, ILearningModelOperatorProvider_methods },
    { 0, nullptr },
};

static PyType_Spec ILearningModelOperatorProvider_Type_spec =
{
    "ILearningModelOperatorProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    ILearningModelOperatorProvider_Type_slots
};

// ----- ITensor interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type;


PyObject* ITensor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "ITensor interface is not activatable");
    return nullptr;
}

static void ITensor_dealloc(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* ITensor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::AI::MachineLearning::ITensor>::convert(instance.as<winrt::Windows::AI::MachineLearning::ITensor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* ITensor_get_Kind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::LearningModelFeatureKind return_value = self->obj.Kind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ITensor_get_Shape(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<int64_t> return_value = self->obj.Shape();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* ITensor_get_TensorKind(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::AI::MachineLearning::TensorKind return_value = self->obj.TensorKind();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef ITensor_methods[] = {
    { "get_Kind", (PyCFunction)ITensor_get_Kind, METH_NOARGS, nullptr },
    { "get_Shape", (PyCFunction)ITensor_get_Shape, METH_NOARGS, nullptr },
    { "get_TensorKind", (PyCFunction)ITensor_get_TensorKind, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)ITensor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot ITensor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, ITensor_dealloc },
    { Py_tp_new, ITensor_new },
    { Py_tp_methods, ITensor_methods },
    { 0, nullptr },
};

static PyType_Spec ITensor_Type_spec =
{
    "ITensor",
    sizeof(py::winrt_wrapper<winrt::Windows::AI::MachineLearning::ITensor>),
    0,
    Py_TPFLAGS_DEFAULT,
    ITensor_Type_slots
};

// ----- Windows.AI.MachineLearning Initialization --------------------

int initialize_Windows_AI_MachineLearning(PyObject* module)
{
    PyObject* type_object{ nullptr };


    ImageFeatureDescriptor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ImageFeatureDescriptor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageFeatureDescriptor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ImageFeatureValue_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ImageFeatureValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ImageFeatureValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    LearningModel_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&LearningModel_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModel", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    LearningModelBinding_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&LearningModelBinding_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelBinding", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    LearningModelDevice_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&LearningModelDevice_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelDevice", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    LearningModelEvaluationResult_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&LearningModelEvaluationResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelEvaluationResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    LearningModelSession_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&LearningModelSession_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "LearningModelSession", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    MapFeatureDescriptor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&MapFeatureDescriptor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MapFeatureDescriptor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    SequenceFeatureDescriptor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&SequenceFeatureDescriptor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "SequenceFeatureDescriptor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorBoolean_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorBoolean_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorBoolean", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorDouble_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorDouble_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorDouble", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorFeatureDescriptor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorFeatureDescriptor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFeatureDescriptor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorFloat_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorFloat_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFloat", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorFloat16Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorFloat16Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorFloat16Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorInt16Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorInt16Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt16Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorInt32Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorInt32Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt32Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorInt64Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorInt64Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt64Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorInt8Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorInt8Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorInt8Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorString_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorString_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorString", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorUInt16Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorUInt16Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt16Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorUInt32Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorUInt32Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt32Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorUInt64Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorUInt64Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt64Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    TensorUInt8Bit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&TensorUInt8Bit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TensorUInt8Bit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ILearningModelFeatureDescriptor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ILearningModelFeatureDescriptor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelFeatureDescriptor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ILearningModelFeatureValue_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ILearningModelFeatureValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelFeatureValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ILearningModelOperatorProvider_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ILearningModelOperatorProvider_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ILearningModelOperatorProvider", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    ITensor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&ITensor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "ITensor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
