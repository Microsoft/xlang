// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Storage.Streams.h"

// ----- Buffer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type;


PyObject* Buffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            winrt::Windows::Storage::Streams::Buffer instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Buffer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Buffer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::Buffer>::convert(instance.as<winrt::Windows::Storage::Streams::Buffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Buffer_CreateCopyFromMemoryBuffer(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);

            winrt::Windows::Storage::Streams::Buffer return_value = winrt::Windows::Storage::Streams::Buffer::CreateCopyFromMemoryBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Buffer_CreateMemoryBufferOverIBuffer(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::MemoryBuffer return_value = winrt::Windows::Storage::Streams::Buffer::CreateMemoryBufferOverIBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Buffer_get_Capacity(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Capacity();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Buffer_get_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Length();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Buffer_put_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.Length(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Buffer_methods[] = {
    { "CreateCopyFromMemoryBuffer", (PyCFunction)Buffer_CreateCopyFromMemoryBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateMemoryBufferOverIBuffer", (PyCFunction)Buffer_CreateMemoryBufferOverIBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Capacity", (PyCFunction)Buffer_get_Capacity, METH_NOARGS, nullptr },
    { "get_Length", (PyCFunction)Buffer_get_Length, METH_NOARGS, nullptr },
    { "put_Length", (PyCFunction)Buffer_put_Length, METH_O, nullptr },
    { "_from", (PyCFunction)Buffer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Buffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Buffer_dealloc },
    { Py_tp_new, Buffer_new },
    { Py_tp_methods, Buffer_methods },
    { 0, nullptr },
};

static PyType_Spec Buffer_Type_spec =
{
    "Buffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::Buffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    Buffer_Type_slots
};

// ----- DataReader class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type;


PyObject* DataReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            winrt::Windows::Storage::Streams::DataReader instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void DataReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataReader__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::DataReader>::convert(instance.as<winrt::Windows::Storage::Streams::DataReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataReader_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.DetachBuffer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.DetachStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_FromBuffer(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Storage::Streams::DataReader return_value = winrt::Windows::Storage::Streams::DataReader::FromBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_LoadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Storage::Streams::DataReaderLoadOperation return_value = self->obj.LoadAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            bool return_value = self->obj.ReadBoolean();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.ReadBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint8_t return_value = self->obj.ReadByte();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*f*/ winrt::array_view<uint8_t> param0 { }; // TODO: Convert incoming python parameter

            self->obj.ReadBytes(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.ReadDateTime();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            double return_value = self->obj.ReadDouble();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = self->obj.ReadGuid();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int16_t return_value = self->obj.ReadInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int32_t return_value = self->obj.ReadInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int64_t return_value = self->obj.ReadInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            float return_value = self->obj.ReadSingle();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::hstring return_value = self->obj.ReadString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::TimeSpan return_value = self->obj.ReadTimeSpan();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint16_t return_value = self->obj.ReadUInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint32_t return_value = self->obj.ReadUInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_ReadUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint64_t return_value = self->obj.ReadUInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReader_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::ByteOrder return_value = self->obj.ByteOrder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_get_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::InputStreamOptions return_value = self->obj.InputStreamOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_get_UnconsumedBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.UnconsumedBufferLength();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::UnicodeEncoding return_value = self->obj.UnicodeEncoding();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::ByteOrder>::convert_to(args);

            self->obj.ByteOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_put_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::InputStreamOptions>::convert_to(args);

            self->obj.InputStreamOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReader_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::UnicodeEncoding>::convert_to(args);

            self->obj.UnicodeEncoding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef DataReader_methods[] = {
    { "Close", (PyCFunction)DataReader_Close, METH_VARARGS, nullptr },
    { "DetachBuffer", (PyCFunction)DataReader_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)DataReader_DetachStream, METH_VARARGS, nullptr },
    { "FromBuffer", (PyCFunction)DataReader_FromBuffer, METH_VARARGS | METH_STATIC, nullptr },
    { "LoadAsync", (PyCFunction)DataReader_LoadAsync, METH_VARARGS, nullptr },
    { "ReadBoolean", (PyCFunction)DataReader_ReadBoolean, METH_VARARGS, nullptr },
    { "ReadBuffer", (PyCFunction)DataReader_ReadBuffer, METH_VARARGS, nullptr },
    { "ReadByte", (PyCFunction)DataReader_ReadByte, METH_VARARGS, nullptr },
    { "ReadBytes", (PyCFunction)DataReader_ReadBytes, METH_VARARGS, nullptr },
    { "ReadDateTime", (PyCFunction)DataReader_ReadDateTime, METH_VARARGS, nullptr },
    { "ReadDouble", (PyCFunction)DataReader_ReadDouble, METH_VARARGS, nullptr },
    { "ReadGuid", (PyCFunction)DataReader_ReadGuid, METH_VARARGS, nullptr },
    { "ReadInt16", (PyCFunction)DataReader_ReadInt16, METH_VARARGS, nullptr },
    { "ReadInt32", (PyCFunction)DataReader_ReadInt32, METH_VARARGS, nullptr },
    { "ReadInt64", (PyCFunction)DataReader_ReadInt64, METH_VARARGS, nullptr },
    { "ReadSingle", (PyCFunction)DataReader_ReadSingle, METH_VARARGS, nullptr },
    { "ReadString", (PyCFunction)DataReader_ReadString, METH_VARARGS, nullptr },
    { "ReadTimeSpan", (PyCFunction)DataReader_ReadTimeSpan, METH_VARARGS, nullptr },
    { "ReadUInt16", (PyCFunction)DataReader_ReadUInt16, METH_VARARGS, nullptr },
    { "ReadUInt32", (PyCFunction)DataReader_ReadUInt32, METH_VARARGS, nullptr },
    { "ReadUInt64", (PyCFunction)DataReader_ReadUInt64, METH_VARARGS, nullptr },
    { "get_ByteOrder", (PyCFunction)DataReader_get_ByteOrder, METH_NOARGS, nullptr },
    { "get_InputStreamOptions", (PyCFunction)DataReader_get_InputStreamOptions, METH_NOARGS, nullptr },
    { "get_UnconsumedBufferLength", (PyCFunction)DataReader_get_UnconsumedBufferLength, METH_NOARGS, nullptr },
    { "get_UnicodeEncoding", (PyCFunction)DataReader_get_UnicodeEncoding, METH_NOARGS, nullptr },
    { "put_ByteOrder", (PyCFunction)DataReader_put_ByteOrder, METH_O, nullptr },
    { "put_InputStreamOptions", (PyCFunction)DataReader_put_InputStreamOptions, METH_O, nullptr },
    { "put_UnicodeEncoding", (PyCFunction)DataReader_put_UnicodeEncoding, METH_O, nullptr },
    { "_from", (PyCFunction)DataReader__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot DataReader_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, DataReader_dealloc },
    { Py_tp_new, DataReader_new },
    { Py_tp_methods, DataReader_methods },
    { 0, nullptr },
};

static PyType_Spec DataReader_Type_spec =
{
    "DataReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataReader_Type_slots
};

// ----- DataReaderLoadOperation class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type;


PyObject* DataReaderLoadOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DataReaderLoadOperation is not activatable");
    return nullptr;
}

static void DataReaderLoadOperation_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataReaderLoadOperation__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::convert(instance.as<winrt::Windows::Storage::Streams::DataReaderLoadOperation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataReaderLoadOperation_Cancel(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReaderLoadOperation_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReaderLoadOperation_GetResults(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint32_t return_value = self->obj.GetResults();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataReaderLoadOperation_get_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t> return_value = self->obj.Completed();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReaderLoadOperation_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = self->obj.ErrorCode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReaderLoadOperation_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReaderLoadOperation_get_Status(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = self->obj.Status();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataReaderLoadOperation_put_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>::convert_to(args);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef DataReaderLoadOperation_methods[] = {
    { "Cancel", (PyCFunction)DataReaderLoadOperation_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)DataReaderLoadOperation_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)DataReaderLoadOperation_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)DataReaderLoadOperation_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)DataReaderLoadOperation_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)DataReaderLoadOperation_get_Id, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)DataReaderLoadOperation_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)DataReaderLoadOperation_put_Completed, METH_O, nullptr },
    { "_from", (PyCFunction)DataReaderLoadOperation__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot DataReaderLoadOperation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, DataReaderLoadOperation_dealloc },
    { Py_tp_new, DataReaderLoadOperation_new },
    { Py_tp_methods, DataReaderLoadOperation_methods },
    { 0, nullptr },
};

static PyType_Spec DataReaderLoadOperation_Type_spec =
{
    "DataReaderLoadOperation",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataReaderLoadOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataReaderLoadOperation_Type_slots
};

// ----- DataWriter class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type;


PyObject* DataWriter_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);
            winrt::Windows::Storage::Streams::DataWriter instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::DataWriter instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void DataWriter_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataWriter__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::DataWriter>::convert(instance.as<winrt::Windows::Storage::Streams::DataWriter>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataWriter_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.DetachBuffer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.DetachStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_MeasureString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            uint32_t return_value = self->obj.MeasureString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_StoreAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::DataWriterStoreOperation return_value = self->obj.StoreAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);

            self->obj.WriteBoolean(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            self->obj.WriteBuffer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            self->obj.WriteBuffer(param0, param1, param2);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);

            self->obj.WriteByte(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint8_t const> param0 { }; // TODO: Convert incoming python parameter

            self->obj.WriteBytes(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            self->obj.WriteDateTime(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);

            self->obj.WriteDouble(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);

            self->obj.WriteGuid(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int16_t>(args, 0);

            self->obj.WriteInt16(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);

            self->obj.WriteInt32(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int64_t>(args, 0);

            self->obj.WriteInt64(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<float>(args, 0);

            self->obj.WriteSingle(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteString(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            uint32_t return_value = self->obj.WriteString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

            self->obj.WriteTimeSpan(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);

            self->obj.WriteUInt16(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            self->obj.WriteUInt32(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_WriteUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.WriteUInt64(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriter_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::ByteOrder return_value = self->obj.ByteOrder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriter_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::UnicodeEncoding return_value = self->obj.UnicodeEncoding();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriter_get_UnstoredBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.UnstoredBufferLength();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriter_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::ByteOrder>::convert_to(args);

            self->obj.ByteOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriter_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::UnicodeEncoding>::convert_to(args);

            self->obj.UnicodeEncoding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef DataWriter_methods[] = {
    { "Close", (PyCFunction)DataWriter_Close, METH_VARARGS, nullptr },
    { "DetachBuffer", (PyCFunction)DataWriter_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)DataWriter_DetachStream, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)DataWriter_FlushAsync, METH_VARARGS, nullptr },
    { "MeasureString", (PyCFunction)DataWriter_MeasureString, METH_VARARGS, nullptr },
    { "StoreAsync", (PyCFunction)DataWriter_StoreAsync, METH_VARARGS, nullptr },
    { "WriteBoolean", (PyCFunction)DataWriter_WriteBoolean, METH_VARARGS, nullptr },
    { "WriteBuffer", (PyCFunction)DataWriter_WriteBuffer, METH_VARARGS, nullptr },
    { "WriteByte", (PyCFunction)DataWriter_WriteByte, METH_VARARGS, nullptr },
    { "WriteBytes", (PyCFunction)DataWriter_WriteBytes, METH_VARARGS, nullptr },
    { "WriteDateTime", (PyCFunction)DataWriter_WriteDateTime, METH_VARARGS, nullptr },
    { "WriteDouble", (PyCFunction)DataWriter_WriteDouble, METH_VARARGS, nullptr },
    { "WriteGuid", (PyCFunction)DataWriter_WriteGuid, METH_VARARGS, nullptr },
    { "WriteInt16", (PyCFunction)DataWriter_WriteInt16, METH_VARARGS, nullptr },
    { "WriteInt32", (PyCFunction)DataWriter_WriteInt32, METH_VARARGS, nullptr },
    { "WriteInt64", (PyCFunction)DataWriter_WriteInt64, METH_VARARGS, nullptr },
    { "WriteSingle", (PyCFunction)DataWriter_WriteSingle, METH_VARARGS, nullptr },
    { "WriteString", (PyCFunction)DataWriter_WriteString, METH_VARARGS, nullptr },
    { "WriteTimeSpan", (PyCFunction)DataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
    { "WriteUInt16", (PyCFunction)DataWriter_WriteUInt16, METH_VARARGS, nullptr },
    { "WriteUInt32", (PyCFunction)DataWriter_WriteUInt32, METH_VARARGS, nullptr },
    { "WriteUInt64", (PyCFunction)DataWriter_WriteUInt64, METH_VARARGS, nullptr },
    { "get_ByteOrder", (PyCFunction)DataWriter_get_ByteOrder, METH_NOARGS, nullptr },
    { "get_UnicodeEncoding", (PyCFunction)DataWriter_get_UnicodeEncoding, METH_NOARGS, nullptr },
    { "get_UnstoredBufferLength", (PyCFunction)DataWriter_get_UnstoredBufferLength, METH_NOARGS, nullptr },
    { "put_ByteOrder", (PyCFunction)DataWriter_put_ByteOrder, METH_O, nullptr },
    { "put_UnicodeEncoding", (PyCFunction)DataWriter_put_UnicodeEncoding, METH_O, nullptr },
    { "_from", (PyCFunction)DataWriter__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot DataWriter_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, DataWriter_dealloc },
    { Py_tp_new, DataWriter_new },
    { Py_tp_methods, DataWriter_methods },
    { 0, nullptr },
};

static PyType_Spec DataWriter_Type_spec =
{
    "DataWriter",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriter>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataWriter_Type_slots
};

// ----- DataWriterStoreOperation class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type;


PyObject* DataWriterStoreOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "DataWriterStoreOperation is not activatable");
    return nullptr;
}

static void DataWriterStoreOperation_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* DataWriterStoreOperation__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::convert(instance.as<winrt::Windows::Storage::Streams::DataWriterStoreOperation>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DataWriterStoreOperation_Cancel(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriterStoreOperation_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriterStoreOperation_GetResults(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint32_t return_value = self->obj.GetResults();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* DataWriterStoreOperation_get_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t> return_value = self->obj.Completed();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriterStoreOperation_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = self->obj.ErrorCode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriterStoreOperation_get_Id(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriterStoreOperation_get_Status(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = self->obj.Status();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* DataWriterStoreOperation_put_Completed(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>::convert_to(args);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef DataWriterStoreOperation_methods[] = {
    { "Cancel", (PyCFunction)DataWriterStoreOperation_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)DataWriterStoreOperation_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)DataWriterStoreOperation_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)DataWriterStoreOperation_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)DataWriterStoreOperation_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)DataWriterStoreOperation_get_Id, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)DataWriterStoreOperation_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)DataWriterStoreOperation_put_Completed, METH_O, nullptr },
    { "_from", (PyCFunction)DataWriterStoreOperation__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot DataWriterStoreOperation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, DataWriterStoreOperation_dealloc },
    { Py_tp_new, DataWriterStoreOperation_new },
    { Py_tp_methods, DataWriterStoreOperation_methods },
    { 0, nullptr },
};

static PyType_Spec DataWriterStoreOperation_Type_spec =
{
    "DataWriterStoreOperation",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::DataWriterStoreOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    DataWriterStoreOperation_Type_slots
};

// ----- FileInputStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type;


PyObject* FileInputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileInputStream is not activatable");
    return nullptr;
}

static void FileInputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileInputStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::FileInputStream>::convert(instance.as<winrt::Windows::Storage::Streams::FileInputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* FileInputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileInputStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef FileInputStream_methods[] = {
    { "Close", (PyCFunction)FileInputStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)FileInputStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)FileInputStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot FileInputStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, FileInputStream_dealloc },
    { Py_tp_new, FileInputStream_new },
    { Py_tp_methods, FileInputStream_methods },
    { 0, nullptr },
};

static PyType_Spec FileInputStream_Type_spec =
{
    "FileInputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileInputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileInputStream_Type_slots
};

// ----- FileOutputStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type;


PyObject* FileOutputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileOutputStream is not activatable");
    return nullptr;
}

static void FileOutputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileOutputStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::FileOutputStream>::convert(instance.as<winrt::Windows::Storage::Streams::FileOutputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* FileOutputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileOutputStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileOutputStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef FileOutputStream_methods[] = {
    { "Close", (PyCFunction)FileOutputStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)FileOutputStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)FileOutputStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)FileOutputStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot FileOutputStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, FileOutputStream_dealloc },
    { Py_tp_new, FileOutputStream_new },
    { Py_tp_methods, FileOutputStream_methods },
    { 0, nullptr },
};

static PyType_Spec FileOutputStream_Type_spec =
{
    "FileOutputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileOutputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileOutputStream_Type_slots
};

// ----- FileRandomAccessStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type;


PyObject* FileRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "FileRandomAccessStream is not activatable");
    return nullptr;
}

static void FileRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* FileRandomAccessStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::FileRandomAccessStream>::convert(instance.as<winrt::Windows::Storage::Streams::FileRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* FileRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1, param2, param3);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 4);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2, param3, param4);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenTransactedWriteAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 2);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_OpenTransactedWriteForUserAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
            auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction> return_value = winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1, param2, param3);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* FileRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* FileRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* FileRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* FileRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* FileRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef FileRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)FileRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)FileRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)FileRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)FileRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)FileRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "OpenAsync", (PyCFunction)FileRandomAccessStream_OpenAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenForUserAsync", (PyCFunction)FileRandomAccessStream_OpenForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenTransactedWriteAsync", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenTransactedWriteForUserAsync", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "ReadAsync", (PyCFunction)FileRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)FileRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)FileRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)FileRandomAccessStream_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)FileRandomAccessStream_get_CanWrite, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)FileRandomAccessStream_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)FileRandomAccessStream_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)FileRandomAccessStream_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)FileRandomAccessStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot FileRandomAccessStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, FileRandomAccessStream_dealloc },
    { Py_tp_new, FileRandomAccessStream_new },
    { Py_tp_methods, FileRandomAccessStream_methods },
    { 0, nullptr },
};

static PyType_Spec FileRandomAccessStream_Type_spec =
{
    "FileRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::FileRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    FileRandomAccessStream_Type_slots
};

// ----- InMemoryRandomAccessStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type;


PyObject* InMemoryRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::InMemoryRandomAccessStream instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void InMemoryRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* InMemoryRandomAccessStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::convert(instance.as<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* InMemoryRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InMemoryRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* InMemoryRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* InMemoryRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* InMemoryRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* InMemoryRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef InMemoryRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)InMemoryRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)InMemoryRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)InMemoryRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)InMemoryRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)InMemoryRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)InMemoryRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)InMemoryRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)InMemoryRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)InMemoryRandomAccessStream_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)InMemoryRandomAccessStream_get_CanWrite, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)InMemoryRandomAccessStream_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)InMemoryRandomAccessStream_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)InMemoryRandomAccessStream_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)InMemoryRandomAccessStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot InMemoryRandomAccessStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, InMemoryRandomAccessStream_dealloc },
    { Py_tp_new, InMemoryRandomAccessStream_new },
    { Py_tp_methods, InMemoryRandomAccessStream_methods },
    { 0, nullptr },
};

static PyType_Spec InMemoryRandomAccessStream_Type_spec =
{
    "InMemoryRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    InMemoryRandomAccessStream_Type_slots
};

// ----- InputStreamOverStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type;


PyObject* InputStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "InputStreamOverStream is not activatable");
    return nullptr;
}

static void InputStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* InputStreamOverStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::InputStreamOverStream>::convert(instance.as<winrt::Windows::Storage::Streams::InputStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* InputStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* InputStreamOverStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef InputStreamOverStream_methods[] = {
    { "Close", (PyCFunction)InputStreamOverStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)InputStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)InputStreamOverStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot InputStreamOverStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, InputStreamOverStream_dealloc },
    { Py_tp_new, InputStreamOverStream_new },
    { Py_tp_methods, InputStreamOverStream_methods },
    { 0, nullptr },
};

static PyType_Spec InputStreamOverStream_Type_spec =
{
    "InputStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::InputStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    InputStreamOverStream_Type_slots
};

// ----- OutputStreamOverStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type;


PyObject* OutputStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "OutputStreamOverStream is not activatable");
    return nullptr;
}

static void OutputStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* OutputStreamOverStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::OutputStreamOverStream>::convert(instance.as<winrt::Windows::Storage::Streams::OutputStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* OutputStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* OutputStreamOverStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* OutputStreamOverStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef OutputStreamOverStream_methods[] = {
    { "Close", (PyCFunction)OutputStreamOverStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)OutputStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)OutputStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)OutputStreamOverStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot OutputStreamOverStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, OutputStreamOverStream_dealloc },
    { Py_tp_new, OutputStreamOverStream_new },
    { Py_tp_methods, OutputStreamOverStream_methods },
    { 0, nullptr },
};

static PyType_Spec OutputStreamOverStream_Type_spec =
{
    "OutputStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::OutputStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    OutputStreamOverStream_Type_slots
};

// ----- RandomAccessStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type;


PyObject* RandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStream is not activatable");
    return nullptr;
}

static PyObject* RandomAccessStream_CopyAndCloseAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint64_t, uint64_t> return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStream_CopyAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint64_t, uint64_t> return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
            auto param2 = py::convert_to<uint64_t>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint64_t, uint64_t> return_value = winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef RandomAccessStream_methods[] = {
    { "CopyAndCloseAsync", (PyCFunction)RandomAccessStream_CopyAndCloseAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "CopyAsync", (PyCFunction)RandomAccessStream_CopyAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot RandomAccessStream_Type_slots[] = 
{
    { Py_tp_new, RandomAccessStream_new },
    { Py_tp_methods, RandomAccessStream_methods },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStream_Type_spec =
{
    "RandomAccessStream",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStream_Type_slots
};

// ----- RandomAccessStreamOverStream class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type;


PyObject* RandomAccessStreamOverStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStreamOverStream is not activatable");
    return nullptr;
}

static void RandomAccessStreamOverStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* RandomAccessStreamOverStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::convert(instance.as<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* RandomAccessStreamOverStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamOverStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* RandomAccessStreamOverStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* RandomAccessStreamOverStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* RandomAccessStreamOverStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* RandomAccessStreamOverStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef RandomAccessStreamOverStream_methods[] = {
    { "CloneStream", (PyCFunction)RandomAccessStreamOverStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)RandomAccessStreamOverStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)RandomAccessStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)RandomAccessStreamOverStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)RandomAccessStreamOverStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)RandomAccessStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)RandomAccessStreamOverStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)RandomAccessStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)RandomAccessStreamOverStream_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)RandomAccessStreamOverStream_get_CanWrite, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)RandomAccessStreamOverStream_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)RandomAccessStreamOverStream_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)RandomAccessStreamOverStream_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)RandomAccessStreamOverStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot RandomAccessStreamOverStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, RandomAccessStreamOverStream_dealloc },
    { Py_tp_new, RandomAccessStreamOverStream_new },
    { Py_tp_methods, RandomAccessStreamOverStream_methods },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStreamOverStream_Type_spec =
{
    "RandomAccessStreamOverStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStreamOverStream_Type_slots
};

// ----- RandomAccessStreamReference class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type;


PyObject* RandomAccessStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "RandomAccessStreamReference is not activatable");
    return nullptr;
}

static void RandomAccessStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* RandomAccessStreamReference__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::convert(instance.as<winrt::Windows::Storage::Streams::RandomAccessStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* RandomAccessStreamReference_CreateFromFile(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

            winrt::Windows::Storage::Streams::RandomAccessStreamReference return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamReference_CreateFromStream(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

            winrt::Windows::Storage::Streams::RandomAccessStreamReference return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamReference_CreateFromUri(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

            winrt::Windows::Storage::Streams::RandomAccessStreamReference return_value = winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* RandomAccessStreamReference_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType> return_value = self->obj.OpenReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef RandomAccessStreamReference_methods[] = {
    { "CreateFromFile", (PyCFunction)RandomAccessStreamReference_CreateFromFile, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromStream", (PyCFunction)RandomAccessStreamReference_CreateFromStream, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateFromUri", (PyCFunction)RandomAccessStreamReference_CreateFromUri, METH_VARARGS | METH_STATIC, nullptr },
    { "OpenReadAsync", (PyCFunction)RandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)RandomAccessStreamReference__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot RandomAccessStreamReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, RandomAccessStreamReference_dealloc },
    { Py_tp_new, RandomAccessStreamReference_new },
    { Py_tp_methods, RandomAccessStreamReference_methods },
    { 0, nullptr },
};

static PyType_Spec RandomAccessStreamReference_Type_spec =
{
    "RandomAccessStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::RandomAccessStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    RandomAccessStreamReference_Type_slots
};

// ----- IBuffer interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type;


PyObject* IBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IBuffer interface is not activatable");
    return nullptr;
}

static void IBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IBuffer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IBuffer>::convert(instance.as<winrt::Windows::Storage::Streams::IBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IBuffer_get_Capacity(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Capacity();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBuffer_get_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Length();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IBuffer_put_Length(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.Length(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IBuffer_methods[] = {
    { "get_Capacity", (PyCFunction)IBuffer_get_Capacity, METH_NOARGS, nullptr },
    { "get_Length", (PyCFunction)IBuffer_get_Length, METH_NOARGS, nullptr },
    { "put_Length", (PyCFunction)IBuffer_put_Length, METH_O, nullptr },
    { "_from", (PyCFunction)IBuffer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IBuffer_dealloc },
    { Py_tp_new, IBuffer_new },
    { Py_tp_methods, IBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec IBuffer_Type_spec =
{
    "IBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    IBuffer_Type_slots
};

// ----- IContentTypeProvider interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type;


PyObject* IContentTypeProvider_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IContentTypeProvider interface is not activatable");
    return nullptr;
}

static void IContentTypeProvider_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IContentTypeProvider__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IContentTypeProvider>::convert(instance.as<winrt::Windows::Storage::Streams::IContentTypeProvider>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IContentTypeProvider_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IContentTypeProvider_methods[] = {
    { "get_ContentType", (PyCFunction)IContentTypeProvider_get_ContentType, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IContentTypeProvider__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IContentTypeProvider_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IContentTypeProvider_dealloc },
    { Py_tp_new, IContentTypeProvider_new },
    { Py_tp_methods, IContentTypeProvider_methods },
    { 0, nullptr },
};

static PyType_Spec IContentTypeProvider_Type_spec =
{
    "IContentTypeProvider",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IContentTypeProvider>),
    0,
    Py_TPFLAGS_DEFAULT,
    IContentTypeProvider_Type_slots
};

// ----- IDataReader interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type;


PyObject* IDataReader_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IDataReader interface is not activatable");
    return nullptr;
}

static void IDataReader_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IDataReader__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IDataReader>::convert(instance.as<winrt::Windows::Storage::Streams::IDataReader>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IDataReader_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.DetachBuffer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.DetachStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_LoadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Storage::Streams::DataReaderLoadOperation return_value = self->obj.LoadAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            bool return_value = self->obj.ReadBoolean();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.ReadBuffer(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint8_t return_value = self->obj.ReadByte();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*f*/ winrt::array_view<uint8_t> param0 { }; // TODO: Convert incoming python parameter

            self->obj.ReadBytes(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.ReadDateTime();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            double return_value = self->obj.ReadDouble();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = self->obj.ReadGuid();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int16_t return_value = self->obj.ReadInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int32_t return_value = self->obj.ReadInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int64_t return_value = self->obj.ReadInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            float return_value = self->obj.ReadSingle();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::hstring return_value = self->obj.ReadString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::TimeSpan return_value = self->obj.ReadTimeSpan();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint16_t return_value = self->obj.ReadUInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint32_t return_value = self->obj.ReadUInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_ReadUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint64_t return_value = self->obj.ReadUInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataReader_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::ByteOrder return_value = self->obj.ByteOrder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_get_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::InputStreamOptions return_value = self->obj.InputStreamOptions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_get_UnconsumedBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.UnconsumedBufferLength();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::UnicodeEncoding return_value = self->obj.UnicodeEncoding();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::ByteOrder>::convert_to(args);

            self->obj.ByteOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_put_InputStreamOptions(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::InputStreamOptions>::convert_to(args);

            self->obj.InputStreamOptions(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataReader_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::UnicodeEncoding>::convert_to(args);

            self->obj.UnicodeEncoding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IDataReader_methods[] = {
    { "DetachBuffer", (PyCFunction)IDataReader_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)IDataReader_DetachStream, METH_VARARGS, nullptr },
    { "LoadAsync", (PyCFunction)IDataReader_LoadAsync, METH_VARARGS, nullptr },
    { "ReadBoolean", (PyCFunction)IDataReader_ReadBoolean, METH_VARARGS, nullptr },
    { "ReadBuffer", (PyCFunction)IDataReader_ReadBuffer, METH_VARARGS, nullptr },
    { "ReadByte", (PyCFunction)IDataReader_ReadByte, METH_VARARGS, nullptr },
    { "ReadBytes", (PyCFunction)IDataReader_ReadBytes, METH_VARARGS, nullptr },
    { "ReadDateTime", (PyCFunction)IDataReader_ReadDateTime, METH_VARARGS, nullptr },
    { "ReadDouble", (PyCFunction)IDataReader_ReadDouble, METH_VARARGS, nullptr },
    { "ReadGuid", (PyCFunction)IDataReader_ReadGuid, METH_VARARGS, nullptr },
    { "ReadInt16", (PyCFunction)IDataReader_ReadInt16, METH_VARARGS, nullptr },
    { "ReadInt32", (PyCFunction)IDataReader_ReadInt32, METH_VARARGS, nullptr },
    { "ReadInt64", (PyCFunction)IDataReader_ReadInt64, METH_VARARGS, nullptr },
    { "ReadSingle", (PyCFunction)IDataReader_ReadSingle, METH_VARARGS, nullptr },
    { "ReadString", (PyCFunction)IDataReader_ReadString, METH_VARARGS, nullptr },
    { "ReadTimeSpan", (PyCFunction)IDataReader_ReadTimeSpan, METH_VARARGS, nullptr },
    { "ReadUInt16", (PyCFunction)IDataReader_ReadUInt16, METH_VARARGS, nullptr },
    { "ReadUInt32", (PyCFunction)IDataReader_ReadUInt32, METH_VARARGS, nullptr },
    { "ReadUInt64", (PyCFunction)IDataReader_ReadUInt64, METH_VARARGS, nullptr },
    { "get_ByteOrder", (PyCFunction)IDataReader_get_ByteOrder, METH_NOARGS, nullptr },
    { "get_InputStreamOptions", (PyCFunction)IDataReader_get_InputStreamOptions, METH_NOARGS, nullptr },
    { "get_UnconsumedBufferLength", (PyCFunction)IDataReader_get_UnconsumedBufferLength, METH_NOARGS, nullptr },
    { "get_UnicodeEncoding", (PyCFunction)IDataReader_get_UnicodeEncoding, METH_NOARGS, nullptr },
    { "put_ByteOrder", (PyCFunction)IDataReader_put_ByteOrder, METH_O, nullptr },
    { "put_InputStreamOptions", (PyCFunction)IDataReader_put_InputStreamOptions, METH_O, nullptr },
    { "put_UnicodeEncoding", (PyCFunction)IDataReader_put_UnicodeEncoding, METH_O, nullptr },
    { "_from", (PyCFunction)IDataReader__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IDataReader_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IDataReader_dealloc },
    { Py_tp_new, IDataReader_new },
    { Py_tp_methods, IDataReader_methods },
    { 0, nullptr },
};

static PyType_Spec IDataReader_Type_spec =
{
    "IDataReader",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataReader>),
    0,
    Py_TPFLAGS_DEFAULT,
    IDataReader_Type_slots
};

// ----- IDataWriter interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type;


PyObject* IDataWriter_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IDataWriter interface is not activatable");
    return nullptr;
}

static void IDataWriter_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IDataWriter__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IDataWriter>::convert(instance.as<winrt::Windows::Storage::Streams::IDataWriter>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IDataWriter_DetachBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IBuffer return_value = self->obj.DetachBuffer();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_DetachStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.DetachStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_MeasureString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            uint32_t return_value = self->obj.MeasureString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_StoreAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::DataWriterStoreOperation return_value = self->obj.StoreAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteBoolean(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);

            self->obj.WriteBoolean(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteBuffer(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            self->obj.WriteBuffer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            self->obj.WriteBuffer(param0, param1, param2);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteByte(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);

            self->obj.WriteByte(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteBytes(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint8_t const> param0 { }; // TODO: Convert incoming python parameter

            self->obj.WriteBytes(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteDateTime(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            self->obj.WriteDateTime(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteDouble(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);

            self->obj.WriteDouble(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteGuid(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);

            self->obj.WriteGuid(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int16_t>(args, 0);

            self->obj.WriteInt16(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);

            self->obj.WriteInt32(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int64_t>(args, 0);

            self->obj.WriteInt64(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteSingle(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<float>(args, 0);

            self->obj.WriteSingle(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteString(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            uint32_t return_value = self->obj.WriteString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteTimeSpan(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

            self->obj.WriteTimeSpan(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt16(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);

            self->obj.WriteUInt16(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt32(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            self->obj.WriteUInt32(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_WriteUInt64(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.WriteUInt64(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IDataWriter_get_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::ByteOrder return_value = self->obj.ByteOrder();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataWriter_get_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Storage::Streams::UnicodeEncoding return_value = self->obj.UnicodeEncoding();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataWriter_get_UnstoredBufferLength(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.UnstoredBufferLength();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataWriter_put_ByteOrder(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::ByteOrder>::convert_to(args);

            self->obj.ByteOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IDataWriter_put_UnicodeEncoding(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Storage::Streams::UnicodeEncoding>::convert_to(args);

            self->obj.UnicodeEncoding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IDataWriter_methods[] = {
    { "DetachBuffer", (PyCFunction)IDataWriter_DetachBuffer, METH_VARARGS, nullptr },
    { "DetachStream", (PyCFunction)IDataWriter_DetachStream, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IDataWriter_FlushAsync, METH_VARARGS, nullptr },
    { "MeasureString", (PyCFunction)IDataWriter_MeasureString, METH_VARARGS, nullptr },
    { "StoreAsync", (PyCFunction)IDataWriter_StoreAsync, METH_VARARGS, nullptr },
    { "WriteBoolean", (PyCFunction)IDataWriter_WriteBoolean, METH_VARARGS, nullptr },
    { "WriteBuffer", (PyCFunction)IDataWriter_WriteBuffer, METH_VARARGS, nullptr },
    { "WriteByte", (PyCFunction)IDataWriter_WriteByte, METH_VARARGS, nullptr },
    { "WriteBytes", (PyCFunction)IDataWriter_WriteBytes, METH_VARARGS, nullptr },
    { "WriteDateTime", (PyCFunction)IDataWriter_WriteDateTime, METH_VARARGS, nullptr },
    { "WriteDouble", (PyCFunction)IDataWriter_WriteDouble, METH_VARARGS, nullptr },
    { "WriteGuid", (PyCFunction)IDataWriter_WriteGuid, METH_VARARGS, nullptr },
    { "WriteInt16", (PyCFunction)IDataWriter_WriteInt16, METH_VARARGS, nullptr },
    { "WriteInt32", (PyCFunction)IDataWriter_WriteInt32, METH_VARARGS, nullptr },
    { "WriteInt64", (PyCFunction)IDataWriter_WriteInt64, METH_VARARGS, nullptr },
    { "WriteSingle", (PyCFunction)IDataWriter_WriteSingle, METH_VARARGS, nullptr },
    { "WriteString", (PyCFunction)IDataWriter_WriteString, METH_VARARGS, nullptr },
    { "WriteTimeSpan", (PyCFunction)IDataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
    { "WriteUInt16", (PyCFunction)IDataWriter_WriteUInt16, METH_VARARGS, nullptr },
    { "WriteUInt32", (PyCFunction)IDataWriter_WriteUInt32, METH_VARARGS, nullptr },
    { "WriteUInt64", (PyCFunction)IDataWriter_WriteUInt64, METH_VARARGS, nullptr },
    { "get_ByteOrder", (PyCFunction)IDataWriter_get_ByteOrder, METH_NOARGS, nullptr },
    { "get_UnicodeEncoding", (PyCFunction)IDataWriter_get_UnicodeEncoding, METH_NOARGS, nullptr },
    { "get_UnstoredBufferLength", (PyCFunction)IDataWriter_get_UnstoredBufferLength, METH_NOARGS, nullptr },
    { "put_ByteOrder", (PyCFunction)IDataWriter_put_ByteOrder, METH_O, nullptr },
    { "put_UnicodeEncoding", (PyCFunction)IDataWriter_put_UnicodeEncoding, METH_O, nullptr },
    { "_from", (PyCFunction)IDataWriter__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IDataWriter_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IDataWriter_dealloc },
    { Py_tp_new, IDataWriter_new },
    { Py_tp_methods, IDataWriter_methods },
    { 0, nullptr },
};

static PyType_Spec IDataWriter_Type_spec =
{
    "IDataWriter",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IDataWriter>),
    0,
    Py_TPFLAGS_DEFAULT,
    IDataWriter_Type_slots
};

// ----- IInputStream interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type;


PyObject* IInputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IInputStream interface is not activatable");
    return nullptr;
}

static void IInputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IInputStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IInputStream>::convert(instance.as<winrt::Windows::Storage::Streams::IInputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IInputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IInputStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IInputStream_methods[] = {
    { "Close", (PyCFunction)IInputStream_Close, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IInputStream_ReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IInputStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IInputStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IInputStream_dealloc },
    { Py_tp_new, IInputStream_new },
    { Py_tp_methods, IInputStream_methods },
    { 0, nullptr },
};

static PyType_Spec IInputStream_Type_spec =
{
    "IInputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IInputStream_Type_slots
};

// ----- IInputStreamReference interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type;


PyObject* IInputStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IInputStreamReference interface is not activatable");
    return nullptr;
}

static void IInputStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IInputStreamReference__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IInputStreamReference>::convert(instance.as<winrt::Windows::Storage::Streams::IInputStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IInputStreamReference_OpenSequentialReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream> return_value = self->obj.OpenSequentialReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IInputStreamReference_methods[] = {
    { "OpenSequentialReadAsync", (PyCFunction)IInputStreamReference_OpenSequentialReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IInputStreamReference__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IInputStreamReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IInputStreamReference_dealloc },
    { Py_tp_new, IInputStreamReference_new },
    { Py_tp_methods, IInputStreamReference_methods },
    { 0, nullptr },
};

static PyType_Spec IInputStreamReference_Type_spec =
{
    "IInputStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IInputStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IInputStreamReference_Type_slots
};

// ----- IOutputStream interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type;


PyObject* IOutputStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IOutputStream interface is not activatable");
    return nullptr;
}

static void IOutputStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IOutputStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IOutputStream>::convert(instance.as<winrt::Windows::Storage::Streams::IOutputStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IOutputStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IOutputStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IOutputStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IOutputStream_methods[] = {
    { "Close", (PyCFunction)IOutputStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IOutputStream_FlushAsync, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IOutputStream_WriteAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IOutputStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IOutputStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IOutputStream_dealloc },
    { Py_tp_new, IOutputStream_new },
    { Py_tp_methods, IOutputStream_methods },
    { 0, nullptr },
};

static PyType_Spec IOutputStream_Type_spec =
{
    "IOutputStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IOutputStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IOutputStream_Type_slots
};

// ----- IRandomAccessStream interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type;


PyObject* IRandomAccessStream_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStream interface is not activatable");
    return nullptr;
}

static void IRandomAccessStream_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStream__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IRandomAccessStream>::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStream>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStream_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStream_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStream_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStream_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStream_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStream_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IRandomAccessStream_methods[] = {
    { "CloneStream", (PyCFunction)IRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IRandomAccessStream_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)IRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)IRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)IRandomAccessStream_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)IRandomAccessStream_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)IRandomAccessStream_get_CanWrite, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)IRandomAccessStream_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)IRandomAccessStream_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)IRandomAccessStream_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)IRandomAccessStream__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IRandomAccessStream_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IRandomAccessStream_dealloc },
    { Py_tp_new, IRandomAccessStream_new },
    { Py_tp_methods, IRandomAccessStream_methods },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStream_Type_spec =
{
    "IRandomAccessStream",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStream>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStream_Type_slots
};

// ----- IRandomAccessStreamReference interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type;


PyObject* IRandomAccessStreamReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStreamReference interface is not activatable");
    return nullptr;
}

static void IRandomAccessStreamReference_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStreamReference__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStreamReference_OpenReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType> return_value = self->obj.OpenReadAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IRandomAccessStreamReference_methods[] = {
    { "OpenReadAsync", (PyCFunction)IRandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IRandomAccessStreamReference__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IRandomAccessStreamReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IRandomAccessStreamReference_dealloc },
    { Py_tp_new, IRandomAccessStreamReference_new },
    { Py_tp_methods, IRandomAccessStreamReference_methods },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStreamReference_Type_spec =
{
    "IRandomAccessStreamReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStreamReference_Type_slots
};

// ----- IRandomAccessStreamWithContentType interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type;


PyObject* IRandomAccessStreamWithContentType_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IRandomAccessStreamWithContentType interface is not activatable");
    return nullptr;
}

static void IRandomAccessStreamWithContentType_dealloc(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IRandomAccessStreamWithContentType__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::convert(instance.as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IRandomAccessStreamWithContentType_CloneStream(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Storage::Streams::IRandomAccessStream return_value = self->obj.CloneStream();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_Close(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_FlushAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<bool> return_value = self->obj.FlushAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_GetInputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IInputStream return_value = self->obj.GetInputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_GetOutputStreamAt(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Storage::Streams::IOutputStream return_value = self->obj.GetOutputStreamAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_ReadAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
            auto param1 = py::convert_to<uint32_t>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t> return_value = self->obj.ReadAsync(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_Seek(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            self->obj.Seek(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_WriteAsync(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

            winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t> return_value = self->obj.WriteAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IRandomAccessStreamWithContentType_get_CanRead(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanRead();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStreamWithContentType_get_CanWrite(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.CanWrite();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStreamWithContentType_get_ContentType(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.ContentType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStreamWithContentType_get_Position(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStreamWithContentType_get_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint64_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IRandomAccessStreamWithContentType_put_Size(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint64_t>::convert_to(args);

            self->obj.Size(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IRandomAccessStreamWithContentType_methods[] = {
    { "CloneStream", (PyCFunction)IRandomAccessStreamWithContentType_CloneStream, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IRandomAccessStreamWithContentType_Close, METH_VARARGS, nullptr },
    { "FlushAsync", (PyCFunction)IRandomAccessStreamWithContentType_FlushAsync, METH_VARARGS, nullptr },
    { "GetInputStreamAt", (PyCFunction)IRandomAccessStreamWithContentType_GetInputStreamAt, METH_VARARGS, nullptr },
    { "GetOutputStreamAt", (PyCFunction)IRandomAccessStreamWithContentType_GetOutputStreamAt, METH_VARARGS, nullptr },
    { "ReadAsync", (PyCFunction)IRandomAccessStreamWithContentType_ReadAsync, METH_VARARGS, nullptr },
    { "Seek", (PyCFunction)IRandomAccessStreamWithContentType_Seek, METH_VARARGS, nullptr },
    { "WriteAsync", (PyCFunction)IRandomAccessStreamWithContentType_WriteAsync, METH_VARARGS, nullptr },
    { "get_CanRead", (PyCFunction)IRandomAccessStreamWithContentType_get_CanRead, METH_NOARGS, nullptr },
    { "get_CanWrite", (PyCFunction)IRandomAccessStreamWithContentType_get_CanWrite, METH_NOARGS, nullptr },
    { "get_ContentType", (PyCFunction)IRandomAccessStreamWithContentType_get_ContentType, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)IRandomAccessStreamWithContentType_get_Position, METH_NOARGS, nullptr },
    { "get_Size", (PyCFunction)IRandomAccessStreamWithContentType_get_Size, METH_NOARGS, nullptr },
    { "put_Size", (PyCFunction)IRandomAccessStreamWithContentType_put_Size, METH_O, nullptr },
    { "_from", (PyCFunction)IRandomAccessStreamWithContentType__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IRandomAccessStreamWithContentType_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IRandomAccessStreamWithContentType_dealloc },
    { Py_tp_new, IRandomAccessStreamWithContentType_new },
    { Py_tp_methods, IRandomAccessStreamWithContentType_methods },
    { 0, nullptr },
};

static PyType_Spec IRandomAccessStreamWithContentType_Type_spec =
{
    "IRandomAccessStreamWithContentType",
    sizeof(py::winrt_wrapper<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>),
    0,
    Py_TPFLAGS_DEFAULT,
    IRandomAccessStreamWithContentType_Type_slots
};

// ----- Windows.Storage.Streams Initialization --------------------

int initialize_Windows_Storage_Streams(PyObject* module)
{
    PyObject* type_object{ nullptr };


    Buffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Buffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Buffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    DataReader_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&DataReader_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DataReader", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    DataReaderLoadOperation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&DataReaderLoadOperation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DataReaderLoadOperation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    DataWriter_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&DataWriter_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DataWriter", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    DataWriterStoreOperation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&DataWriterStoreOperation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DataWriterStoreOperation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    FileInputStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&FileInputStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "FileInputStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    FileOutputStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&FileOutputStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "FileOutputStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    FileRandomAccessStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&FileRandomAccessStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "FileRandomAccessStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    InMemoryRandomAccessStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&InMemoryRandomAccessStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "InMemoryRandomAccessStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    InputStreamOverStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&InputStreamOverStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "InputStreamOverStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    OutputStreamOverStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&OutputStreamOverStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "OutputStreamOverStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&RandomAccessStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "RandomAccessStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    RandomAccessStreamOverStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&RandomAccessStreamOverStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "RandomAccessStreamOverStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    RandomAccessStreamReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&RandomAccessStreamReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "RandomAccessStreamReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IContentTypeProvider_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IContentTypeProvider_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IContentTypeProvider", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IDataReader_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IDataReader_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IDataReader", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IDataWriter_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IDataWriter_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IDataWriter", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IInputStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IInputStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IInputStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IInputStreamReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IInputStreamReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IInputStreamReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IOutputStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IOutputStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IOutputStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IRandomAccessStream_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IRandomAccessStream_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IRandomAccessStream", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IRandomAccessStreamReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IRandomAccessStreamReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IRandomAccessStreamReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IRandomAccessStreamWithContentType_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IRandomAccessStreamWithContentType_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IRandomAccessStreamWithContentType", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
